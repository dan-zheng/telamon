var searchIndex = {};
searchIndex["telamon"] = {"doc":"","items":[[0,"codegen","telamon","Helpers to generate code from an IR instance and fully specified decisions.",null,null],[3,"Dimension","telamon::codegen","An iteration dimension composed of one or mure fused dimensions.",null,null],[3,"InductionLevel","","An induction level associated to a dimension.",null,null],[12,"ind_var","","",0,null],[12,"increment","","",0,null],[12,"base","","",0,null],[3,"InductionVar","","An induction variable, composed of multiple induction variable levels.",null,null],[12,"id","","",1,null],[12,"value","","",1,null],[3,"Function","","A function ready to execute on a device, derived from a constrained IR instance.",null,null],[3,"InternalMemBlock","","A memory block allocated by the kernel.",null,null],[3,"Instruction","","An instruction to execute.",null,null],[3,"NameMap","","Maps variables to names.",null,null],[4,"Cfg","","Represents a CFG of the targeted device.",null,null],[13,"Root","","Represents the root node of the CFG.",2,null],[13,"Loop","","Represents a loop in the CFG.",2,null],[13,"Instruction","","Represents an instruction in the CFG.",2,null],[13,"Threads","","Defines the set of active thread dimensions.",2,null],[4,"ParamVal","","Represents the value of a parameter passed to the kernel by the host.",null,null],[13,"External","","A parameter given by the caller.",3,null],[13,"Size","","A tiled dimension size computed on the host.",3,null],[13,"GlobalMem","","A pointer to a global memory block, allocated by the wrapper.",3,null],[4,"ParamValKey","","Uniquely identifies a `ParamVal`.",null,null],[13,"External","","",4,null],[13,"Size","","",4,null],[13,"GlobalMem","","",4,null],[4,"AllocationScheme","","Indicates how is a memory block allocated.",null,null],[13,"Global","","",5,null],[13,"PrivatisedGlobal","","",5,null],[13,"Shared","","",5,null],[4,"Value","","A value that can be named.",null,null],[13,"InductionLevel","","",6,null],[13,"Operand","","",6,null],[4,"MulMode","","",null,null],[13,"Wide","","",7,null],[13,"Low","","",7,null],[13,"High","","",7,null],[13,"Empty","","",7,null],[11,"dimensions","","Iterates over the dimensions of the `Cfg`.",2,null],[11,"instructions","","Iterates over the instructions of the `Cfg`.",2,null],[11,"induction_levels","","Iterates over the induction levels in the `Cfg`.",2,null],[11,"fmt","","",2,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",8,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"id","","Returns the ID of the representant.",8,{"inputs":[{"name":"self"}],"output":{"name":"id"}}],[11,"kind","","Returns the kind of the dimension.",8,{"inputs":[{"name":"self"}],"output":{"name":"dimkind"}}],[11,"size","","Returns the size of the dimensions.",8,{"inputs":[{"name":"self"}],"output":{"name":"size"}}],[11,"dim_ids","","Returns the ids of the `ir::Dimensions` represented by this dimension.",8,null],[11,"induction_levels","","Returns the induction levels handled by this loop.",8,null],[11,"drain_induction_levels","","Gives the ownership on the induction levels computed by the dimension.",8,{"inputs":[{"name":"self"}],"output":{"generics":["inductionlevel"],"name":"vec"}}],[11,"merge_from","","Merge another `Dimension` into this one.",8,{"inputs":[{"name":"self"},{"name":"self"}],"output":null}],[11,"host_values","","Returns the values to pass from the host to the device to implement `self`.",8,null],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"t","","Returns the type of the value created by the induction level.",0,{"inputs":[{"name":"self"}],"output":{"name":"type"}}],[11,"host_values","","Returns the values to pass from the host to the device to implement `self`.",0,null],[11,"host_values","","Returns the values to pass from the host to the device to implement `self`.",1,null],[11,"build","","Creates a device `Function` from an IR instance.",9,{"inputs":[{"name":"searchspace"}],"output":{"name":"function"}}],[11,"thread_dims","","Returns the ordered list of thread dimensions.",9,null],[11,"block_dims","","Returns the ordered list of block dimensions.",9,null],[11,"dimensions","","Iterates other all `codegen::Dimension`.",9,null],[11,"induction_vars","","Returns the list of induction variables.",9,null],[11,"num_threads","","Returns the total number of threads to allocate.",9,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"device_code_args","","Returns the values to pass from the host to the device.",9,null],[11,"cfg","","Returns the control flow graph.",9,{"inputs":[{"name":"self"}],"output":{"name":"cfg"}}],[11,"induction_levels","","Returns all the induction levels in the function.",9,null],[11,"mem_blocks","","Returns the memory blocks allocated by the function.",9,null],[11,"space","","Returns the underlying implementation space.",9,{"inputs":[{"name":"self"}],"output":{"name":"searchspace"}}],[11,"init_induction_levels","","Returns the induction levels computed at the beginning of the kernel. Levels must be computed in the provided order.",9,null],[11,"deref","","",9,null],[11,"from_operand","","Builds the `ParamVal` needed to implement an operand, if any.",3,{"inputs":[{"name":"operand"},{"name":"searchspace"}],"output":{"name":"option"}}],[11,"from_size","","Builds the `ParamVal` needed to get a size value, if any.",3,{"inputs":[{"name":"size"}],"output":{"name":"option"}}],[11,"t","","Returns the type of the parameter.",3,{"inputs":[{"name":"self"}],"output":{"name":"type"}}],[11,"is_pointer","","Indicates if the parameter is a pointer.",3,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"key","","Returns a unique identifier for the `ParamVal`.",3,{"inputs":[{"name":"self"}],"output":{"name":"paramvalkey"}}],[11,"eq","","",4,{"inputs":[{"name":"self"},{"name":"paramvalkey"}],"output":{"name":"bool"}}],[11,"ne","","",4,{"inputs":[{"name":"self"},{"name":"paramvalkey"}],"output":{"name":"bool"}}],[11,"hash","","",4,null],[11,"clone","","",4,{"inputs":[{"name":"self"}],"output":{"name":"paramvalkey"}}],[11,"eq","","",5,{"inputs":[{"name":"self"},{"name":"allocationscheme"}],"output":{"name":"bool"}}],[11,"new","","Creates a new InternalMemBlock from an `ir::mem::Internal`.",10,{"inputs":[{"name":"internalblock"},{"name":"option"},{"name":"searchspace"}],"output":{"name":"self"}}],[11,"host_values","","Returns the value to pass from the host to the device to implement `self`.",10,null],[11,"id","","Returns the memory ID.",10,{"inputs":[{"name":"self"}],"output":{"name":"internalid"}}],[11,"alloc_scheme","","Indicates how is the memory block allocated.",10,{"inputs":[{"name":"self"}],"output":{"name":"allocationscheme"}}],[11,"alloc_size","","Generates the size of the memory to allocate.",10,{"inputs":[{"name":"self"}],"output":{"name":"size"}}],[11,"local_size","","Returns the size of the part of the allocated memory accessible by each thread.",10,{"inputs":[{"name":"self"}],"output":{"name":"size"}}],[11,"mem_space","","Returns the memory space the block is allocated in.",10,{"inputs":[{"name":"self"}],"output":{"name":"memspace"}}],[11,"ptr_type","","Returns the type of the pointer to the memory block.",10,{"inputs":[{"name":"self"}],"output":{"name":"type"}}],[11,"new","","Creates a new `Instruction`.",11,{"inputs":[{"name":"instruction"},{"name":"searchspace"}],"output":{"name":"self"}}],[11,"id","","Returns the ID of the instruction.",11,{"inputs":[{"name":"self"}],"output":{"name":"instid"}}],[11,"host_values","","Returns the values to pass from the host to implement this instruction.",11,null],[11,"t","","Returns the type of the instruction.",11,{"inputs":[{"name":"self"}],"output":{"generics":["type"],"name":"option"}}],[11,"operator","","Returns the operator computed by the instruction.",11,{"inputs":[{"name":"self"}],"output":{"name":"operator"}}],[11,"instantiation_dims","","Returns the dimensions on which to instantiate the instruction.",11,null],[11,"as_reduction","","Indicates if the instruction performs a reduction, in wich case it returns the instruction that initializes the reduction, the `DimMap` to readh it and the reduction dimensions.",11,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"mem_flag","","Returns the memory flag of the intruction, if any.",11,{"inputs":[{"name":"self"}],"output":{"generics":["instflag"],"name":"option"}}],[11,"has_side_effects","","Indicates if the instruction has observable side effects.",11,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"clone","","",6,{"inputs":[{"name":"self"}],"output":{"name":"value"}}],[11,"new","","Creates a new `NameMap`.",12,{"inputs":[{"name":"function"},{"name":"namer"}],"output":{"name":"self"}}],[11,"gen_name","","Generates a variable of the given `Type`.",12,{"inputs":[{"name":"self"},{"name":"type"}],"output":{"name":"string"}}],[11,"gen_loop_id","","Generates an ID for a loop.",12,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"name","","",12,{"inputs":[{"name":"self"},{"name":"value"}],"output":{"generics":["str"],"name":"cow"}}],[11,"name_op","","Asigns a name to an operand.",12,{"inputs":[{"name":"self"},{"name":"operand"}],"output":{"generics":["str"],"name":"cow"}}],[11,"name_inst","","Returns the name of the instruction.",12,{"inputs":[{"name":"self"},{"name":"instruction"}],"output":{"name":"str"}}],[11,"name_inst_id","","Returns the name of the instruction.",12,{"inputs":[{"name":"self"},{"name":"instid"},{"name":"dimmap"}],"output":{"name":"str"}}],[11,"name_index","","Returns the name of an index.",12,{"inputs":[{"name":"self"},{"name":"id"}],"output":{"name":"str"}}],[11,"set_current_index","","Set the current index of an unrolled dimension.",12,{"inputs":[{"name":"self"},{"name":"dimension"},{"name":"u32"}],"output":null}],[11,"unset_current_index","","Unset the current index of an unrolled dimension.",12,{"inputs":[{"name":"self"},{"name":"dimension"}],"output":null}],[11,"indexed_inst_name","","",12,{"inputs":[{"name":"self"},{"name":"instruction"},{"name":"id"},{"name":"u32"}],"output":{"name":"string"}}],[11,"indexed_op_name","","",12,{"inputs":[{"name":"self"},{"name":"operand"},{"name":"id"},{"name":"u32"}],"output":{"name":"string"}}],[11,"name_param","","Returns the name of a variable representing a parameter.",12,{"inputs":[{"name":"self"},{"name":"paramvalkey"}],"output":{"generics":["str"],"name":"cow"}}],[11,"name_param_val","","Returns the name of a variable representing a parameter value.",12,{"inputs":[{"name":"self"},{"name":"paramvalkey"}],"output":{"generics":["str"],"name":"cow"}}],[11,"name_addr","","Returns the name of the address of a memory block.",12,{"inputs":[{"name":"self"},{"name":"internalid"}],"output":{"generics":["str"],"name":"cow"}}],[11,"name_induction_var","","Assigns a name to an induction variable.",12,{"inputs":[{"name":"self"},{"name":"indvarid"},{"generics":["id"],"name":"option"}],"output":{"generics":["str"],"name":"cow"}}],[11,"declare_size_cast","","Declares a size cast. Returns the name of the variable only if a new variable was allcoated.",12,{"inputs":[{"name":"self"},{"name":"size"},{"name":"type"}],"output":{"generics":["string"],"name":"option"}}],[11,"name_size","","Assigns a name of a value to a size.",12,{"inputs":[{"name":"self"},{"name":"size"},{"name":"type"}],"output":{"generics":["str"],"name":"cow"}}],[11,"side_effect_guard","","Returns the side-effect guard, if any is set.",12,{"inputs":[{"name":"self"}],"output":{"generics":["rcstr"],"name":"option"}}],[11,"set_side_effect_guard","","Sets the predicate to use in front of side-effect instruction.",12,{"inputs":[{"name":"self"},{"generics":["rcstr"],"name":"option"}],"output":null}],[11,"clone","","",7,{"inputs":[{"name":"self"}],"output":{"name":"mulmode"}}],[8,"Namer","","Assign names to variables.",null,null],[10,"name","","Provides a name for a variable of the given type.",13,{"inputs":[{"name":"self"},{"name":"type"}],"output":{"name":"string"}}],[10,"name_param","","Generates a name for a parameter.",13,{"inputs":[{"name":"self"},{"name":"paramvalkey"}],"output":{"name":"string"}}],[10,"name_float","","Provides a name for a floating point constant.",13,{"inputs":[{"name":"self"},{"name":"ratio"},{"name":"u16"}],"output":{"name":"string"}}],[10,"name_int","","Provides a name for an integer constant.",13,{"inputs":[{"name":"self"},{"name":"bigint"},{"name":"u16"}],"output":{"name":"string"}}],[8,"Printer","","",null,null],[10,"get_int","","Get a proper string representation of an integer in target language",14,{"inputs":[{"name":"u32"}],"output":{"name":"string"}}],[10,"get_float","","Get a proper string representation of an float in target language",14,{"inputs":[{"name":"f64"}],"output":{"name":"string"}}],[10,"get_type","","Print a type in the backend",14,{"inputs":[{"name":"type"}],"output":{"name":"string"}}],[10,"print_binop","","Print return_id = lhs op rhs",14,{"inputs":[{"name":"self"},{"name":"binop"},{"name":"type"},{"name":"rounding"},{"name":"str"},{"name":"str"},{"name":"str"}],"output":null}],[10,"print_mul","","Print return_id = op1 * op2",14,{"inputs":[{"name":"self"},{"name":"type"},{"name":"rounding"},{"name":"mulmode"},{"name":"str"},{"name":"str"},{"name":"str"}],"output":null}],[10,"print_mad","","Print return_id = mlhs * mrhs + arhs",14,{"inputs":[{"name":"self"},{"name":"type"},{"name":"rounding"},{"name":"mulmode"},{"name":"str"},{"name":"str"},{"name":"str"},{"name":"str"}],"output":null}],[10,"print_mov","","Print return_id = op",14,{"inputs":[{"name":"self"},{"name":"type"},{"name":"str"},{"name":"str"}],"output":null}],[10,"print_ld","","Print return_id = load [addr]",14,{"inputs":[{"name":"self"},{"name":"type"},{"name":"instflag"},{"name":"str"},{"name":"str"}],"output":null}],[10,"print_st","","Print store val [addr]",14,{"inputs":[{"name":"self"},{"name":"type"},{"name":"instflag"},{"name":"str"},{"name":"str"}],"output":null}],[10,"print_cond_st","","Print if (cond) store val [addr]",14,{"inputs":[{"name":"self"},{"name":"type"},{"name":"instflag"},{"name":"str"},{"name":"str"},{"name":"str"}],"output":null}],[10,"print_cast","","Print return_id = (val_type) val",14,{"inputs":[{"name":"self"},{"name":"type"},{"name":"type"},{"name":"rounding"},{"name":"str"},{"name":"str"}],"output":null}],[10,"print_label","","print a label where to jump",14,{"inputs":[{"name":"self"},{"name":"str"}],"output":null}],[10,"print_and","","Print return_id = op1 && op2",14,{"inputs":[{"name":"self"},{"name":"str"},{"name":"str"},{"name":"str"}],"output":null}],[10,"print_or","","Print return_id = op1 || op2",14,{"inputs":[{"name":"self"},{"name":"str"},{"name":"str"},{"name":"str"}],"output":null}],[10,"print_equal","","Print return_id = op1 == op2",14,{"inputs":[{"name":"self"},{"name":"str"},{"name":"str"},{"name":"str"}],"output":null}],[10,"print_lt","","Print return_id = op1 < op2",14,{"inputs":[{"name":"self"},{"name":"str"},{"name":"str"},{"name":"str"}],"output":null}],[10,"print_gt","","Print return_id = op1 > op2",14,{"inputs":[{"name":"self"},{"name":"str"},{"name":"str"},{"name":"str"}],"output":null}],[10,"print_cond_jump","","Print if (cond) jump label(label_id)",14,{"inputs":[{"name":"self"},{"name":"str"},{"name":"str"}],"output":null}],[10,"print_sync","","Print wait on all threads",14,{"inputs":[{"name":"self"}],"output":null}],[10,"print_vector_inst","","",14,{"inputs":[{"name":"self"},{"name":"instruction"},{"name":"dimension"},{"name":"namemap"},{"name":"function"}],"output":null}],[11,"mul_mode","","",14,{"inputs":[{"name":"type"},{"name":"type"}],"output":{"name":"mulmode"}}],[11,"lower_type","","",14,{"inputs":[{"name":"type"},{"name":"function"}],"output":{"name":"type"}}],[11,"cfg_vec","","",14,null],[11,"cfg","","Prints a cfg.",14,{"inputs":[{"name":"self"},{"name":"function"},{"name":"cfg"},{"name":"namemap"}],"output":null}],[11,"parallel_induction_level","","Prints a multiplicative induction var level.",14,{"inputs":[{"name":"self"},{"name":"inductionlevel"},{"name":"namemap"}],"output":null}],[11,"enable_threads","","Change the side-effect guards so that only the specified threads are enabled.",14,null],[11,"gen_loop","","Prints a Loop",14,null],[11,"standard_loop","","Prints a classic loop - that is, a sequential loop with an index and a jump to the beginning at the end of the block",14,null],[11,"unroll_loop","","Prints an unroll loop - loop without jumps",14,null],[11,"privatise_global_block","","",14,{"inputs":[{"name":"self"},{"name":"internalmemblock"},{"name":"namemap"},{"name":"function"}],"output":null}],[11,"inst","","Prints an instruction.",14,{"inputs":[{"name":"self"},{"name":"instruction"},{"name":"namemap"},{"name":"function"}],"output":null}],[0,"helper","telamon","Helper functions to build an IR instance.",null,null],[3,"Builder","telamon::helper","Helper to build a `Function`.",null,null],[3,"SignatureBuilder","","Helper struct to build a `Signature`.",null,null],[3,"Reduce","","Helper to build `Reduce` operands.",null,null],[12,"0","","",15,null],[3,"TmpArray","","Helper to build dim maps that can be lowered to temporary memory.",null,null],[12,"0","","",16,null],[3,"DimGroup","","A groups of dimensions that act as a single logical dimension.",null,null],[11,"new","","Creates a new `Builder` for a `Function` with the given signature.",17,{"inputs":[{"name":"signature"},{"name":"device"}],"output":{"name":"builder"}}],[11,"get","","Returns the function created by the builder",17,{"inputs":[{"name":"self"}],"output":{"name":"searchspace"}}],[11,"get_clone","","Returns the function created by the builder",17,{"inputs":[{"name":"self"}],"output":{"name":"searchspace"}}],[11,"binop","","Creates a binary operator.",17,{"inputs":[{"name":"self"},{"name":"binop"},{"name":"autooperand"},{"name":"autooperand"}],"output":{"name":"instid"}}],[11,"add","","Adds an `Add` instruction to the fuction.",17,{"inputs":[{"name":"self"},{"name":"autooperand"},{"name":"autooperand"}],"output":{"name":"instid"}}],[11,"sub","","Adds a `Sub` instruction to the function.",17,{"inputs":[{"name":"self"},{"name":"autooperand"},{"name":"autooperand"}],"output":{"name":"instid"}}],[11,"mul","","Adds a `Mul` instruction to the function. Defaults to low mode.",17,{"inputs":[{"name":"self"},{"name":"autooperand"},{"name":"autooperand"}],"output":{"name":"instid"}}],[11,"mul_ex","","Adds a 'Mul` instruction with a wide mode to the function.",17,{"inputs":[{"name":"self"},{"name":"autooperand"},{"name":"autooperand"},{"name":"type"}],"output":{"name":"instid"}}],[11,"mad","","Adds a `Mad` or `Fma` instruction to the function. Defaults to low or wide mode depending on the operand types.",17,{"inputs":[{"name":"self"},{"name":"autooperand"},{"name":"autooperand"},{"name":"autooperand"}],"output":{"name":"instid"}}],[11,"div","","Adds a `Div` instruction to the fuction.",17,{"inputs":[{"name":"self"},{"name":"autooperand"},{"name":"autooperand"}],"output":{"name":"instid"}}],[11,"mov","","Adds a `Mov` instruction to the function.",17,{"inputs":[{"name":"self"},{"name":"autooperand"}],"output":{"name":"instid"}}],[11,"ld","","Adds a coherent load from global memory instruction to the function.",17,{"inputs":[{"name":"self"},{"name":"type"},{"name":"autooperand"},{"name":"accesspattern"}],"output":{"name":"instid"}}],[11,"ld_nc","","Adds a non-coherent load from global memory instruction to the function.",17,{"inputs":[{"name":"self"},{"name":"type"},{"name":"autooperand"},{"name":"accesspattern"}],"output":{"name":"instid"}}],[11,"ld_ex","","Adds a load instruction with the given flags and memory block.",17,{"inputs":[{"name":"self"},{"name":"type"},{"name":"autooperand"},{"name":"accesspattern"},{"name":"instflag"}],"output":{"name":"instid"}}],[11,"st","","Adds a store instruction.",17,{"inputs":[{"name":"self"},{"name":"autooperand"},{"name":"autooperand"},{"name":"accesspattern"}],"output":{"name":"instid"}}],[11,"st_ex","","Adds a store instruction with the given flags and memory block.",17,{"inputs":[{"name":"self"},{"name":"autooperand"},{"name":"autooperand"},{"name":"bool"},{"name":"accesspattern"},{"name":"instflag"}],"output":{"name":"instid"}}],[11,"cast","","Adds a cast instruction to the given type.",17,{"inputs":[{"name":"self"},{"name":"autooperand"},{"name":"type"}],"output":{"name":"instid"}}],[11,"type_of","","Returns the type of an operand.",17,{"inputs":[{"name":"self"},{"name":"autooperand"}],"output":{"name":"type"}}],[11,"order","","Restricts the order between two basic blocks. Does not restricts LINK and NPACK flags.",17,{"inputs":[{"name":"self"},{"name":"metabasicblock"},{"name":"metabasicblock"},{"name":"order"}],"output":null}],[11,"tensor_access","","Builds both an induction variable for a tensor memory access and the corresponding access pattern.",17,null],[11,"action","","Applies an action on the function.",17,{"inputs":[{"name":"self"},{"name":"action"}],"output":null}],[11,"open_dim","","Opens a new dimension.",17,{"inputs":[{"name":"self"},{"name":"size"}],"output":{"name":"id"}}],[11,"open_dim_ex","","Opens a nest of new dimension with the given kinds and sizes.",17,{"inputs":[{"name":"self"},{"name":"size"},{"name":"dimkind"}],"output":{"name":"id"}}],[11,"open_tiled_dim","","Open multiple dimensions to represent a tiled dimension.",17,null],[11,"open_mapped_dim","","Opens a new dimension mapped to an existing one.",17,{"inputs":[{"name":"self"},{"name":"metadimension"}],"output":{"name":"dimgroup"}}],[11,"reopen_dim","","Opens an existing dimension.",17,{"inputs":[{"name":"self"},{"name":"metadimension"}],"output":null}],[11,"reopen_mapped_dim","","Opens an existing dimension and maps it to another one. The dimension mapped to is closed if needed.",17,{"inputs":[{"name":"self"},{"name":"metadimension"},{"name":"metadimension"}],"output":null}],[11,"close_dim","","Closes a dimension.",17,{"inputs":[{"name":"self"},{"name":"metadimension"}],"output":null}],[11,"cst_size","","Returns a constant size.",17,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"size"}}],[11,"param_size","","Returns a parameter size.",17,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"size"}}],[11,"tile_size","","Returns a tiled size.",17,{"inputs":[{"name":"self"},{"name":"str"},{"name":"u32"}],"output":{"name":"size"}}],[11,"size","","Returns a size from the given parameters, dividend and divisor.",17,null],[11,"allocate_shared","","Allocates a memory block in shared memory.",17,{"inputs":[{"name":"self"},{"name":"size"}],"output":{"name":"internalid"}}],[11,"allocate","","Allocates a memory block.",17,{"inputs":[{"name":"self"},{"name":"size"},{"name":"bool"}],"output":{"name":"internalid"}}],[11,"unknown_access_pattern","","Generates an access paterns with all the strides unknown on the opened dimensions.",17,{"inputs":[{"name":"self"},{"name":"id"}],"output":{"name":"accesspattern"}}],[11,"tensor_access_pattern","","Generates the access pattern corresponding to accessing a tensor of the given type. The data is assumed to be laid out contiguously in the order given by dimensions. The last dimension is the major order.",17,null],[11,"induction_var","","Builds an induction variable.",17,{"inputs":[{"name":"self"},{"name":"autooperand"},{"name":"vec"}],"output":{"name":"indvarid"}}],[11,"dim_map","","Creates a dim-map operand.",17,null],[11,"find_param","","Finds a paramter given its name.",17,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"parameter"}}],[11,"get","","",15,{"inputs":[{"name":"self"},{"name":"function"},{"name":"hashmap"}],"output":{"name":"operand"}}],[11,"get","","",16,{"inputs":[{"name":"self"},{"name":"function"},{"name":"hashmap"}],"output":{"name":"operand"}}],[11,"new","","Creates a new builder for a function with the given name.",18,{"inputs":[{"name":"str"},{"name":"am"}],"output":{"name":"self"}}],[11,"scalar","","Creates a new parameter and binds it to the given value.",18,{"inputs":[{"name":"self"},{"name":"str"},{"name":"t"}],"output":null}],[11,"array","","Creates a new parameter and binds it to a freshly allocated an array.",18,null],[11,"tensor","","Allocates an n-dimensional array.",18,{"inputs":[{"name":"self"},{"name":"str"},{"generics":["dimsize"],"name":"vec"},{"name":"bool"}],"output":{"name":"tensor"}}],[11,"get","","Returns the `Signature` created by the builder.",18,{"inputs":[{"name":"self"}],"output":{"name":"signature"}}],[11,"context","","Returns the underlying context.",18,{"inputs":[{"name":"self"}],"output":{"name":"am"}}],[0,"tensor","","Utilities to allocate and operate on tensors.",null,null],[3,"DimSize","telamon::helper::tensor","A dimension size, before tiling.",null,null],[3,"TensorBuilder","","An helper to build a tensor.",null,null],[3,"Tensor","","A tensor allocated in main memory.",null,null],[3,"VirtualTensor","","A tensor loaded in registers.",null,null],[11,"clone","","",19,{"inputs":[{"name":"self"}],"output":{"name":"dimsize"}}],[11,"into_ir_size","","Convert the size into the size type used by the IR.",19,{"inputs":[{"name":"self"},{"name":"builder"}],"output":{"name":"size"}}],[11,"eval","","Converts the size into a numerical value for a given context.",19,{"inputs":[{"name":"self"},{"name":"context"}],"output":{"name":"u32"}}],[11,"from","","",19,{"inputs":[{"name":"u32"}],"output":{"name":"self"}}],[11,"from","","",19,{"inputs":[{"name":"str"}],"output":{"name":"self"}}],[11,"new","","Start building a `Tensor` with the given logical layout.",20,{"inputs":[{"name":"str"},{"generics":["dimsize"],"name":"vec"}],"output":{"name":"self"}}],[11,"transpose","","Swap two dimensions in the memory layout of the tensor. Keeps the logical layout untouched.",20,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"usize"}],"output":{"name":"self"}}],[11,"stride_dim","","Removes a logical dimension but keeps it in the storage.",20,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"self"}}],[11,"enable_writes","","Allows writing to the tensor.",20,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"finish","","Builds the `Tensor`.",20,{"inputs":[{"name":"self"},{"name":"signaturebuilder"}],"output":{"name":"tensor"}}],[11,"new","","Allocates a new `Tensor` in the context.",21,{"inputs":[{"name":"str"},{"generics":["dimsize"],"name":"vec"},{"name":"bool"},{"name":"id"},{"generics":["arrayargument"],"name":"arc"}],"output":{"name":"self"}}],[11,"load","","Creates a `VirtualTensor` that contains the values of `self`, loaded in registers.",21,null],[11,"read_to_host","","Reads the tensor value in the context and copies it on the host.",21,{"inputs":[{"name":"self"},{"name":"context"}],"output":{"name":"arrayd"}}],[11,"new","","Creates a new `VirtualTensor`.",22,{"inputs":[{"name":"instid"},{"generics":["dimgroup"],"name":"vec"}],"output":{"name":"self"}}],[11,"dim_map","","Creates an operand that yeilds the values of the tensor in the given loop nest.",22,null],[11,"store","","Stores the `VirtualTensor` in memory.",22,{"inputs":[{"name":"self"},{"name":"tensor"},{"name":"builder"}],"output":{"name":"virtualtensor"}}],[11,"inst","","Returns the underlying instruction.",22,{"inputs":[{"name":"self"}],"output":{"name":"instid"}}],[11,"index","","",22,null],[8,"AutoOperand","telamon::helper","Represents values that can be turned into an `Operand`.",null,null],[10,"get","","Returns the corresponding `Operand`.",23,{"inputs":[{"name":"self"},{"name":"function"},{"name":"hashmap"}],"output":{"name":"operand"}}],[8,"MetaDimension","","A logical dimension, possible composed of multiple nested dimensions.",null,null],[10,"ids","","Returns the ids of the underlying dimensions.",24,{"inputs":[{"name":"self"}],"output":{"generics":["doubleendediterator"],"name":"box"}}],[8,"MetaBasicBlock","","A logical basic block, that can actually be implemented by multiple ones.",null,null],[10,"ids","","Returns the ids on the underlying basic blocks.",25,{"inputs":[{"name":"self"}],"output":{"generics":["iterator"],"name":"box"}}],[11,"clone","","",26,{"inputs":[{"name":"self"}],"output":{"name":"dimgroup"}}],[11,"default","","",26,{"inputs":[],"output":{"name":"dimgroup"}}],[11,"new","","Creates a dimension group containing the given dimensions.",26,{"inputs":[{"generics":["id"],"name":"vec"}],"output":{"name":"self"}}],[11,"iter","","Iterates over the sub-dimensions of the group.",26,{"inputs":[{"name":"self"}],"output":{"generics":["iter"],"name":"cloned"}}],[11,"ids","","",26,{"inputs":[{"name":"self"}],"output":{"generics":["doubleendediterator"],"name":"box"}}],[11,"index","","",26,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"id"}}],[0,"device","telamon","Code generation and candidate evaluation for specific targets.",null,null],[4,"EvalMode","telamon::device","Indicates how evaluation should be performed.",null,null],[13,"FindBest","","Find the best candidate, skip bad candidates and allow optimizations.",27,null],[13,"TestBound","","Test the performance model, do not skip candidates and do not optimize.",27,null],[5,"read_array","","Copies the array to the host, interpreting it as an array of `T`.",null,{"inputs":[{"name":"arrayargument"}],"output":{"name":"vec"}}],[5,"write_array","","Copies an values to the device array from the host array given as argument.",null,null],[0,"cuda","","Defines the CUDA target.",null,null],[3,"Array","telamon::device::cuda","An array on the CUDA device.",null,null],[3,"Context","","A CUDA evaluation context.",null,null],[3,"Gpu","","Represents CUDA GPUs.",null,null],[12,"name","","The name of the GPU.",28,null],[12,"sm_major","","The compute capability major number.",28,null],[12,"sm_minor","","The compute capability minor number.",28,null],[12,"addr_size","","The size of pointers.",28,null],[12,"shared_mem_per_smx","","The amount of shared memory per SMX.",28,null],[12,"shared_mem_per_block","","The amount of shared memory available per block.",28,null],[12,"allow_nc_load","","`true` when non-coherent loads are enabled on the GPU.",28,null],[12,"allow_l1_for_global_mem","","`ture` when L1 caching is enabled for global memory accesses.",28,null],[12,"wrap_size","","The size of a wrap.",28,null],[12,"thread_per_smx","","The maximal number of resident thread per SMX.",28,null],[12,"l1_cache_size","","The size in bytes of the L1 cache.",28,null],[12,"l1_cache_line","","The size in bytes of a L1 cache line.",28,null],[12,"l2_cache_size","","The size in bytes of the L2 cache.",28,null],[12,"l2_cache_line","","The size in bytes of a L2 cache line.",28,null],[12,"load_l2_latency","","Latency of an L2 access.",28,null],[12,"load_ram_latency","","Latency of a RAM access.",28,null],[12,"shared_bank_stride","","The stride at wich replays occur in shared memory.",28,null],[12,"load_shared_latency","","Latency of a shared memory access.",28,null],[12,"num_smx","","The number of SMX in the GPU.",28,null],[12,"max_block_per_smx","","Maximum number of block per SMX.",28,null],[12,"smx_clock","","The clock of an SMX, in GHz.",28,null],[12,"thread_rates","","Amount of processing power available on a single thread.",28,null],[12,"smx_rates","","Amount of processing power available on a single SMX.",28,null],[12,"gpu_rates","","Amount of processing power available on the whole GPU.",28,null],[12,"add_f32_inst","","",28,null],[12,"add_f64_inst","","",28,null],[12,"add_i32_inst","","",28,null],[12,"add_i64_inst","","",28,null],[12,"mul_f32_inst","","",28,null],[12,"mul_f64_inst","","",28,null],[12,"mul_i32_inst","","",28,null],[12,"mul_i64_inst","","",28,null],[12,"mul_wide_inst","","",28,null],[12,"mad_f32_inst","","",28,null],[12,"mad_f64_inst","","",28,null],[12,"mad_i32_inst","","",28,null],[12,"mad_i64_inst","","",28,null],[12,"mad_wide_inst","","",28,null],[12,"div_f32_inst","","",28,null],[12,"div_f64_inst","","",28,null],[12,"div_i32_inst","","",28,null],[12,"div_i64_inst","","",28,null],[12,"syncthread_inst","","",28,null],[12,"loop_init_overhead","","Overhead for entring the loop.",28,null],[12,"loop_iter_overhead","","Overhead for a single iteration of the loop.",28,null],[12,"loop_end_latency","","Latency for exiting the loop.",28,null],[3,"InstDesc","","Specifies the performance parameters of an instruction.",null,null],[12,"latency","","The latency of the instruction.",29,null],[12,"issue","","The number of instruction to issue.",29,null],[12,"alu","","The number of instruction on the ALUs.",29,null],[12,"sync","","The number of syncthread units used.",29,null],[12,"mem","","The number of instruction on Load/Store units.",29,null],[12,"l1_lines_from_l2","","The number of L1 cache lines that are fetched from the L2.",29,null],[12,"l2_lines_read","","The number of L2 cache lines read.",29,null],[12,"l2_lines_stored","","Number of l2 cache lines stored.",29,null],[12,"ram_bw","","The ram bandwidth used.",29,null],[3,"Kernel","","An IR instance compiled into a CUDA kernel.",null,null],[3,"CudaPrinter","","",null,null],[4,"Executor","","Interface with a CUDA device.",null,null],[4,"JITDaemon","","A process that compiles PTX in a separate process.",null,null],[11,"clone","","",30,{"inputs":[{"name":"self"}],"output":{"name":"array"}}],[11,"read_i8","","",30,{"inputs":[{"name":"self"}],"output":{"generics":["i8"],"name":"vec"}}],[11,"write_i8","","",30,null],[11,"try_init","","Initializes the `Executor`.",31,{"inputs":[],"output":{"generics":["executor","initerror"],"name":"result"}}],[11,"spawn_jit","","Spawns a `JITDaemon`.",31,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"jitdaemon"}}],[11,"allocate_array","","Allocates an array on the CUDA device.",31,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"array"}}],[11,"device_name","","Returns the name of the device.",31,{"inputs":[{"name":"self"}],"output":{"name":"string"}}],[11,"compile_ptx","","Compiles a PTX module.",31,{"inputs":[{"name":"self"},{"name":"str"},{"name":"usize"}],"output":{"name":"module"}}],[11,"compile_remote","","Compiles a PTX module using a separate process.",31,{"inputs":[{"name":"self"},{"name":"jitdaemon"},{"name":"str"}],"output":{"name":"module"}}],[11,"new","","Create a new evaluation context. The GPU model if infered.",32,{"inputs":[{"name":"executor"}],"output":{"name":"context"}}],[11,"from_gpu","","Creates a context from the given GPU.",32,{"inputs":[{"name":"gpu"},{"name":"executor"}],"output":{"name":"self"}}],[11,"gpu","","Returns the GPU description.",32,{"inputs":[{"name":"self"}],"output":{"name":"gpu"}}],[11,"executor","","Returns the execution queue.",32,{"inputs":[{"name":"self"}],"output":{"name":"executor"}}],[11,"get_param","","Returns a parameter given its name.",32,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"argument"}}],[11,"bind_param","","Binds a parameter to the gien name.",32,{"inputs":[{"name":"self"},{"name":"string"},{"generics":["argument"],"name":"arc"}],"output":null}],[11,"bind_scalar","","",32,{"inputs":[{"name":"self"},{"name":"parameter"},{"name":"s"}],"output":null}],[11,"bind_array","","",32,{"inputs":[{"name":"self"},{"name":"parameter"},{"name":"usize"}],"output":{"name":"arc"}}],[11,"device","","",32,{"inputs":[{"name":"self"}],"output":{"name":"device"}}],[11,"param_as_size","","",32,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"generics":["u32"],"name":"option"}}],[11,"evaluate","","",32,{"inputs":[{"name":"self"},{"name":"function"},{"name":"evalmode"}],"output":{"generics":["f64"],"name":"result"}}],[11,"benchmark","","",32,{"inputs":[{"name":"self"},{"name":"function"},{"name":"usize"}],"output":{"generics":["f64"],"name":"vec"}}],[11,"async_eval","","",32,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"evalmode"},{"name":"fn"}],"output":null}],[11,"compile","","Compiles a device function.",33,{"inputs":[{"name":"function"},{"name":"gpu"},{"name":"executor"},{"name":"usize"}],"output":{"name":"self"}}],[11,"compile_remote","","Compiles a device function, using a separate process.",33,{"inputs":[{"name":"function"},{"name":"gpu"},{"name":"executor"},{"name":"jitdaemon"}],"output":{"name":"self"}}],[11,"evaluate","","Runs a kernel and returns the number of cycles it takes to execute in cycles.",33,{"inputs":[{"name":"self"},{"name":"context"}],"output":{"generics":["u64"],"name":"result"}}],[11,"evaluate_real","","Runs a kernel and returns the number of cycles it takes to execute in nanoseconds, measured using cuda event rather than hardware counters.",33,{"inputs":[{"name":"self"},{"name":"context"},{"name":"usize"}],"output":{"generics":["f64"],"name":"vec"}}],[11,"gen_thunk","","Generates a Thunk than can then be run on the GPU.",33,{"inputs":[{"name":"self"},{"name":"context"}],"output":{"name":"thunk"}}],[11,"default","","",29,{"inputs":[],"output":{"name":"instdesc"}}],[11,"clone","","",29,{"inputs":[{"name":"self"}],"output":{"name":"instdesc"}}],[11,"fmt","","",29,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"into","","",29,{"inputs":[{"name":"self"}],"output":{"name":"hwpressure"}}],[11,"clone","","",28,{"inputs":[{"name":"self"}],"output":{"name":"gpu"}}],[11,"from_executor","","Returns the GPU model corresponding to `name.",28,{"inputs":[{"name":"executor"}],"output":{"name":"gpu"}}],[11,"dummy","","Creates a dummy GPU, to use for tests and benchmarks without evaluation.",28,{"inputs":[],"output":{"name":"self"}}],[11,"print_ptx","","Returns the PTX code for a Function.",28,{"inputs":[{"name":"self"},{"name":"function"}],"output":{"name":"string"}}],[11,"blocks_per_smx","","Computes the number of blocks that can fit in an smx.",28,{"inputs":[{"name":"self"},{"name":"searchspace"}],"output":{"name":"u32"}}],[11,"print","","",28,{"inputs":[{"name":"self"},{"name":"function"},{"name":"write"}],"output":null}],[11,"check_type","","",28,{"inputs":[{"name":"self"},{"name":"type"}],"output":{"generics":["typeerror"],"name":"result"}}],[11,"max_block_dims","","",28,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"max_threads","","",28,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"max_unrolling","","",28,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"can_vectorize","","",28,{"inputs":[{"name":"self"},{"name":"dimension"},{"name":"operator"}],"output":{"name":"bool"}}],[11,"shared_mem","","",28,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"supports_nc_access","","",28,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"supports_l1_access","","",28,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"supports_l2_access","","",28,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"name","","",28,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"lower_type","","",28,{"inputs":[{"name":"self"},{"name":"type"},{"name":"searchspace"}],"output":{"generics":["type"],"name":"option"}}],[11,"hw_pressure","","",28,{"inputs":[{"name":"self"},{"name":"searchspace"},{"name":"hashmap"},{"name":"hashmap"},{"name":"basicblock"},{"name":"context"}],"output":{"name":"hwpressure"}}],[11,"loop_iter_pressure","","",28,null],[11,"thread_rates","","",28,{"inputs":[{"name":"self"}],"output":{"name":"hwpressure"}}],[11,"block_rates","","",28,{"inputs":[{"name":"self"}],"output":{"name":"hwpressure"}}],[11,"total_rates","","",28,{"inputs":[{"name":"self"}],"output":{"name":"hwpressure"}}],[11,"bottlenecks","","",28,null],[11,"block_parallelism","","",28,{"inputs":[{"name":"self"},{"name":"searchspace"}],"output":{"name":"u32"}}],[11,"additive_indvar_pressure","","",28,{"inputs":[{"name":"self"},{"name":"type"}],"output":{"name":"hwpressure"}}],[11,"multiplicative_indvar_pressure","","",28,{"inputs":[{"name":"self"},{"name":"type"}],"output":{"name":"hwpressure"}}],[11,"add_block_overhead","","",28,{"inputs":[{"name":"self"},{"name":"u64"},{"name":"u64"},{"name":"hwpressure"}],"output":null}],[11,"new","","",34,{"inputs":[],"output":{"name":"self"}}],[11,"function","","Prints a `Function`.",34,{"inputs":[{"name":"self"},{"name":"function"},{"name":"gpu"}],"output":{"name":"string"}}],[11,"host_function","","",34,{"inputs":[{"name":"self"},{"name":"function"},{"name":"gpu"},{"name":"write"}],"output":null}],[11,"get_int","","Get a proper string representation of an integer in target language",34,{"inputs":[{"name":"u32"}],"output":{"name":"string"}}],[11,"get_float","","Get a proper string representation of an integer in target language",34,{"inputs":[{"name":"f64"}],"output":{"name":"string"}}],[11,"get_type","","Print a type in the backend",34,{"inputs":[{"name":"type"}],"output":{"name":"string"}}],[11,"print_binop","","Print return_id = op1 op op2",34,{"inputs":[{"name":"self"},{"name":"binop"},{"name":"type"},{"name":"rounding"},{"name":"str"},{"name":"str"},{"name":"str"}],"output":null}],[11,"print_mul","","Print return_id = op1 * op2",34,{"inputs":[{"name":"self"},{"name":"type"},{"name":"rounding"},{"name":"mulmode"},{"name":"str"},{"name":"str"},{"name":"str"}],"output":null}],[11,"print_mad","","Print return_id = mlhs * mrhs + arhs",34,{"inputs":[{"name":"self"},{"name":"type"},{"name":"rounding"},{"name":"mulmode"},{"name":"str"},{"name":"str"},{"name":"str"},{"name":"str"}],"output":null}],[11,"print_mov","","Print return_id = op",34,{"inputs":[{"name":"self"},{"name":"type"},{"name":"str"},{"name":"str"}],"output":null}],[11,"print_ld","","Print return_id = load [addr]",34,{"inputs":[{"name":"self"},{"name":"type"},{"name":"instflag"},{"name":"str"},{"name":"str"}],"output":null}],[11,"print_st","","Print store val [addr]",34,{"inputs":[{"name":"self"},{"name":"type"},{"name":"instflag"},{"name":"str"},{"name":"str"}],"output":null}],[11,"print_cond_st","","Print if (cond) store val [addr]",34,{"inputs":[{"name":"self"},{"name":"type"},{"name":"instflag"},{"name":"str"},{"name":"str"},{"name":"str"}],"output":null}],[11,"print_cast","","Print return_id = (val_type) val",34,{"inputs":[{"name":"self"},{"name":"type"},{"name":"type"},{"name":"rounding"},{"name":"str"},{"name":"str"}],"output":null}],[11,"print_label","","print a label where to jump",34,{"inputs":[{"name":"self"},{"name":"str"}],"output":null}],[11,"print_and","","Print return_id = op1 && op2",34,{"inputs":[{"name":"self"},{"name":"str"},{"name":"str"},{"name":"str"}],"output":null}],[11,"print_or","","Print return_id = op1 || op2",34,{"inputs":[{"name":"self"},{"name":"str"},{"name":"str"},{"name":"str"}],"output":null}],[11,"print_equal","","Print return_id = op1 == op2",34,{"inputs":[{"name":"self"},{"name":"str"},{"name":"str"},{"name":"str"}],"output":null}],[11,"print_lt","","Print return_id = op1 < op2",34,{"inputs":[{"name":"self"},{"name":"str"},{"name":"str"},{"name":"str"}],"output":null}],[11,"print_gt","","Print return_id = op1 > op2",34,{"inputs":[{"name":"self"},{"name":"str"},{"name":"str"},{"name":"str"}],"output":null}],[11,"print_cond_jump","","Print if (cond) jump label(label_id)",34,{"inputs":[{"name":"self"},{"name":"str"},{"name":"str"}],"output":null}],[11,"print_sync","","Print wait on all threads",34,{"inputs":[{"name":"self"}],"output":null}],[11,"print_vector_inst","","",34,{"inputs":[{"name":"self"},{"name":"instruction"},{"name":"dimension"},{"name":"namemap"},{"name":"function"}],"output":null}],[0,"x86","telamon::device","Defines the CPU target.",null,null],[3,"Context","telamon::device::x86","A CPU evaluation context.",null,null],[3,"Cpu","","Represents CUDA GPUs.",null,null],[12,"name","","The name of the CPU.",35,null],[3,"X86printer","","",null,null],[11,"new","","Create a new evaluation context.",36,{"inputs":[],"output":{"name":"context"}}],[11,"get_param","","Returns a parameter given its name.",36,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"argument"}}],[11,"bind_scalar","","",36,{"inputs":[{"name":"self"},{"name":"parameter"},{"name":"s"}],"output":null}],[11,"bind_array","","",36,{"inputs":[{"name":"self"},{"name":"parameter"},{"name":"usize"}],"output":{"name":"arc"}}],[11,"device","","",36,{"inputs":[{"name":"self"}],"output":{"name":"device"}}],[11,"param_as_size","","",36,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"generics":["u32"],"name":"option"}}],[11,"evaluate","","Evaluation in sequential mode",36,{"inputs":[{"name":"self"},{"name":"function"},{"name":"evalmode"}],"output":{"generics":["f64"],"name":"result"}}],[11,"benchmark","","returns a vec containing num_sample runs of function_evaluate",36,{"inputs":[{"name":"self"},{"name":"function"},{"name":"usize"}],"output":{"generics":["f64"],"name":"vec"}}],[11,"async_eval","","",36,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"evalmode"},{"name":"fn"}],"output":null}],[11,"clone","","",35,{"inputs":[{"name":"self"}],"output":{"name":"cpu"}}],[11,"dummy_cpu","","",35,{"inputs":[],"output":{"name":"self"}}],[11,"print","","",35,{"inputs":[{"name":"self"},{"name":"function"},{"name":"write"}],"output":null}],[11,"check_type","","",35,{"inputs":[{"name":"self"},{"name":"type"}],"output":{"generics":["typeerror"],"name":"result"}}],[11,"max_block_dims","","",35,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"max_threads","","",35,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"max_unrolling","","",35,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"can_vectorize","","",35,{"inputs":[{"name":"self"},{"name":"dimension"},{"name":"operator"}],"output":{"name":"bool"}}],[11,"shared_mem","","",35,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"supports_nc_access","","",35,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"supports_l1_access","","",35,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"supports_l2_access","","",35,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"name","","",35,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"add_block_overhead","","",35,{"inputs":[{"name":"self"},{"name":"u64"},{"name":"u64"},{"name":"hwpressure"}],"output":null}],[11,"lower_type","","",35,{"inputs":[{"name":"self"},{"name":"type"},{"name":"searchspace"}],"output":{"generics":["type"],"name":"option"}}],[11,"hw_pressure","","",35,{"inputs":[{"name":"self"},{"name":"searchspace"},{"name":"hashmap"},{"name":"hashmap"},{"name":"basicblock"},{"name":"context"}],"output":{"name":"hwpressure"}}],[11,"loop_iter_pressure","","",35,null],[11,"thread_rates","","",35,{"inputs":[{"name":"self"}],"output":{"name":"hwpressure"}}],[11,"block_rates","","",35,{"inputs":[{"name":"self"}],"output":{"name":"hwpressure"}}],[11,"total_rates","","",35,{"inputs":[{"name":"self"}],"output":{"name":"hwpressure"}}],[11,"bottlenecks","","",35,null],[11,"block_parallelism","","",35,{"inputs":[{"name":"self"},{"name":"searchspace"}],"output":{"name":"u32"}}],[11,"additive_indvar_pressure","","",35,{"inputs":[{"name":"self"},{"name":"type"}],"output":{"name":"hwpressure"}}],[11,"multiplicative_indvar_pressure","","",35,{"inputs":[{"name":"self"},{"name":"type"}],"output":{"name":"hwpressure"}}],[11,"default","","",37,{"inputs":[],"output":{"name":"x86printer"}}],[11,"function","","Prints a `Function`.",37,{"inputs":[{"name":"self"},{"name":"function"}],"output":{"name":"string"}}],[11,"wrapper_function","","wrap the kernel call into a function with a fixed interface",37,{"inputs":[{"name":"self"},{"name":"function"}],"output":{"name":"string"}}],[11,"get_int","","",37,{"inputs":[{"name":"u32"}],"output":{"name":"string"}}],[11,"get_float","","",37,{"inputs":[{"name":"f64"}],"output":{"name":"string"}}],[11,"get_type","","",37,{"inputs":[{"name":"type"}],"output":{"name":"string"}}],[11,"print_vector_inst","","",37,{"inputs":[{"name":"self"},{"name":"instruction"},{"name":"dimension"},{"name":"namemap"},{"name":"function"}],"output":null}],[11,"print_binop","","",37,{"inputs":[{"name":"self"},{"name":"binop"},{"name":"type"},{"name":"rounding"},{"name":"str"},{"name":"str"},{"name":"str"}],"output":null}],[11,"print_mul","","",37,{"inputs":[{"name":"self"},{"name":"type"},{"name":"rounding"},{"name":"mulmode"},{"name":"str"},{"name":"str"},{"name":"str"}],"output":null}],[11,"print_mad","","",37,{"inputs":[{"name":"self"},{"name":"type"},{"name":"rounding"},{"name":"mulmode"},{"name":"str"},{"name":"str"},{"name":"str"},{"name":"str"}],"output":null}],[11,"print_mov","","",37,{"inputs":[{"name":"self"},{"name":"type"},{"name":"str"},{"name":"str"}],"output":null}],[11,"print_ld","","",37,{"inputs":[{"name":"self"},{"name":"type"},{"name":"instflag"},{"name":"str"},{"name":"str"}],"output":null}],[11,"print_st","","",37,{"inputs":[{"name":"self"},{"name":"type"},{"name":"instflag"},{"name":"str"},{"name":"str"}],"output":null}],[11,"print_cond_st","","",37,{"inputs":[{"name":"self"},{"name":"type"},{"name":"instflag"},{"name":"str"},{"name":"str"},{"name":"str"}],"output":null}],[11,"print_cast","","",37,{"inputs":[{"name":"self"},{"name":"type"},{"name":"type"},{"name":"rounding"},{"name":"str"},{"name":"str"}],"output":null}],[11,"print_label","","",37,{"inputs":[{"name":"self"},{"name":"str"}],"output":null}],[11,"print_and","","",37,{"inputs":[{"name":"self"},{"name":"str"},{"name":"str"},{"name":"str"}],"output":null}],[11,"print_or","","",37,{"inputs":[{"name":"self"},{"name":"str"},{"name":"str"},{"name":"str"}],"output":null}],[11,"print_equal","","",37,{"inputs":[{"name":"self"},{"name":"str"},{"name":"str"},{"name":"str"}],"output":null}],[11,"print_lt","","",37,{"inputs":[{"name":"self"},{"name":"str"},{"name":"str"},{"name":"str"}],"output":null}],[11,"print_gt","","",37,{"inputs":[{"name":"self"},{"name":"str"},{"name":"str"},{"name":"str"}],"output":null}],[11,"print_cond_jump","","",37,{"inputs":[{"name":"self"},{"name":"str"},{"name":"str"}],"output":null}],[11,"print_sync","","",37,{"inputs":[{"name":"self"}],"output":null}],[11,"clone","telamon::device","",27,{"inputs":[{"name":"self"}],"output":{"name":"evalmode"}}],[11,"fmt","","",27,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",27,{"inputs":[{"name":"self"},{"name":"evalmode"}],"output":{"name":"bool"}}],[6,"AsyncCallback","","A callback that is called after evaluating a kernel.",null,null],[8,"ScalarArgument","","Represents a value that can be used as a `Function` argument. Must ensures the type is a scalar and does not contains any reference.",null,null],[11,"as_size","","Returns the argument interpreted as an iteration dimension size, if applicable.",38,{"inputs":[{"name":"self"}],"output":{"generics":["u32"],"name":"option"}}],[10,"t","","Returns the type of the argument.",38,{"inputs":[],"output":{"name":"type"}}],[10,"raw_ptr","","Returns a raw pointer to the object.",38,null],[10,"as_operand","","Returns an operand holding the argument value as a constant.",38,{"inputs":[{"name":"self"}],"output":{"name":"operand"}}],[10,"gen_random","","Generates a random instance of the argument type.",38,{"inputs":[{"name":"r"}],"output":{"name":"self"}}],[8,"ArrayArgument","","Represents an array on the device.",null,null],[10,"read_i8","","Copies the array to the host as a vector of bytes.",39,{"inputs":[{"name":"self"}],"output":{"generics":["i8"],"name":"vec"}}],[10,"write_i8","","Copies an array to the device from a slice of bytes.",39,null],[8,"Context","","Describes the context for which a function must be optimized.",null,null],[10,"device","","Returns the description of the device the code runs on.",40,{"inputs":[{"name":"self"}],"output":{"name":"device"}}],[10,"evaluate","","Returns the execution time of a fully specified implementation in nanoseconds.",40,{"inputs":[{"name":"self"},{"name":"function"},{"name":"evalmode"}],"output":{"generics":["f64"],"name":"result"}}],[10,"benchmark","","Compiles and benchmarks a functions. As opposed to `Self::evaluate`, the measured time contains potential startup times.",40,{"inputs":[{"name":"self"},{"name":"function"},{"name":"usize"}],"output":{"generics":["f64"],"name":"vec"}}],[10,"async_eval","","Calls the `inner` closure in parallel, and gives it a pointer to an `AsyncEvaluator` to evaluate candidates in the context. `skip_bad_bounds` indicates than candidates whose bound is aboive the best candidate should be skiped.",40,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"evalmode"},{"name":"fn"}],"output":null}],[10,"param_as_size","","Returns a parameter interpreted as a size, if possible.",40,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"generics":["u32"],"name":"option"}}],[11,"eval_size","","Evaluate a size.",40,{"inputs":[{"name":"self"},{"name":"size"}],"output":{"name":"u32"}}],[8,"ArgMap","","Binds the argument names to their values.",null,null],[16,"Array","","",41,null],[10,"bind_scalar","","Binds a parameter to a given value.",41,{"inputs":[{"name":"self"},{"name":"parameter"},{"name":"s"}],"output":null}],[10,"bind_array","","Allocates an array of the given size in bytes.",41,{"inputs":[{"name":"self"},{"name":"parameter"},{"name":"usize"}],"output":{"name":"arc"}}],[8,"AsyncEvaluator","","An evaluation context that runs kernels asynchronously on the target device.",null,null],[10,"add_kernel","","Add a kernel to evaluate.",42,{"inputs":[{"name":"self"},{"name":"candidate"},{"name":"asynccallback"}],"output":null}],[8,"Device","","Holds the specifications of a target.",null,null],[10,"print","","Prints the code corresponding to a device `Function`.",43,{"inputs":[{"name":"self"},{"name":"function"},{"name":"write"}],"output":null}],[10,"check_type","","Indicates if a `Type` can be implemented on the device.",43,{"inputs":[{"name":"self"},{"name":"type"}],"output":{"generics":["typeerror"],"name":"result"}}],[10,"max_block_dims","","Returns the maximal number of block dimensions.",43,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[10,"max_threads","","Returns the maximal number of threads.",43,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[10,"max_unrolling","","Returns the maximal unrolling factor.",43,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[10,"can_vectorize","","Indicates if vectorization is possible on a loop with size Size on this instruction.",43,{"inputs":[{"name":"self"},{"name":"dimension"},{"name":"operator"}],"output":{"name":"bool"}}],[10,"shared_mem","","Returns the amount of shared memory available for each thread block.",43,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[10,"supports_nc_access","","Indicates if the device supports non-coherent memory accesses.",43,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[10,"supports_l1_access","","Indicates if the device supports L1 for global memory accesses.",43,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[10,"supports_l2_access","","Indicates if the device supports L2 for global memory accesses.",43,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[10,"name","","Returns the name of the device.",43,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[10,"hw_pressure","","Returns the pressure cause by a `BasicBlock`. For a dimension, returns the pressure for the full loop execution.",43,{"inputs":[{"name":"self"},{"name":"searchspace"},{"name":"hashmap"},{"name":"hashmap"},{"name":"basicblock"},{"name":"context"}],"output":{"name":"hwpressure"}}],[10,"loop_iter_pressure","","Returns the pressure produced by a single iteration of a loop and the latency overhead of iterations.",43,null],[10,"thread_rates","","Returns the processing rates of a single thread, in units/ns",43,{"inputs":[{"name":"self"}],"output":{"name":"hwpressure"}}],[10,"block_rates","","Returns the processing rates of a single block, in units/ns.",43,{"inputs":[{"name":"self"}],"output":{"name":"hwpressure"}}],[10,"total_rates","","Returns the processing rates of the whole accelerator un units/ns.",43,{"inputs":[{"name":"self"}],"output":{"name":"hwpressure"}}],[10,"bottlenecks","","Returns the names of potential bottlenecks.",43,null],[10,"block_parallelism","","Returns the number of blocks that can be executed in parallel on the device.",43,{"inputs":[{"name":"self"},{"name":"searchspace"}],"output":{"name":"u32"}}],[10,"additive_indvar_pressure","","Returns the pressure caused by an additive induction variable level.",43,{"inputs":[{"name":"self"},{"name":"type"}],"output":{"name":"hwpressure"}}],[10,"multiplicative_indvar_pressure","","Returns the pressure caused by a multiplicative induction variable level.",43,{"inputs":[{"name":"self"},{"name":"type"}],"output":{"name":"hwpressure"}}],[10,"add_block_overhead","","Adds the overhead (per instance) due to partial wraps and predicated dimensions to the pressure. If the instruction is not predicated, `predicated_dims_size` should be `1`.",43,{"inputs":[{"name":"self"},{"name":"u64"},{"name":"u64"},{"name":"hwpressure"}],"output":null}],[10,"lower_type","","Lowers a type using the memory space information. Returns `None` if some information is not yet specified.",43,{"inputs":[{"name":"self"},{"name":"type"},{"name":"searchspace"}],"output":{"generics":["type"],"name":"option"}}],[11,"gen_code","","Builds and outputs a constrained IR instance.",43,{"inputs":[{"name":"self"},{"name":"searchspace"},{"name":"write"}],"output":null}],[0,"explorer","telamon","exploration of the search space.",null,null],[3,"Candidate","telamon::explorer","A node of the search tree.",null,null],[12,"space","","Represents a part of the full search space.",44,null],[12,"bound","","Gives a lower bound in nanoseconds on the execution time of `fun`.",44,null],[12,"depth","","The depth of the candidate in the search tree.",44,null],[12,"actions","","The list of actions already taken.",44,null],[5,"find_best","","Entry point of the exploration. This function returns the best candidate that it has found in the given time (or at whatever point we decided to stop the search - potentially after an exhaustive search)",null,{"inputs":[{"name":"config"},{"name":"context"},{"generics":["searchspace"],"name":"vec"}],"output":{"generics":["searchspace"],"name":"option"}}],[5,"find_best_ex","","Same as `find_best`, but allows to specify pre-existing actions and also returns the actionsfor the best candidate.",null,{"inputs":[{"name":"config"},{"name":"context"},{"generics":["candidate"],"name":"vec"}],"output":{"generics":["candidate"],"name":"option"}}],[5,"gen_space","","Explores the full search space.",null,{"inputs":[{"name":"context"},{"name":"searchspace"},{"name":"f"},{"name":"g"}],"output":null}],[11,"clone","","",44,{"inputs":[{"name":"self"}],"output":{"name":"candidate"}}],[11,"new","","Creates a new candidate, with depth 0.",44,{"inputs":[{"name":"searchspace"},{"name":"bound"}],"output":{"name":"self"}}],[11,"apply_choice","","",44,{"inputs":[{"name":"self"},{"name":"context"},{"generics":["actionex"],"name":"vec"}],"output":{"generics":["candidate"],"name":"vec"}}],[11,"apply_decision","","Applies a choice to a candidate.",44,{"inputs":[{"name":"self"},{"name":"context"},{"name":"actionex"}],"output":{"name":"result"}}],[11,"fmt","","",44,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",44,{"inputs":[{"name":"self"},{"name":"candidate"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",44,{"inputs":[{"name":"self"},{"name":"candidate"}],"output":{"generics":["ordering"],"name":"option"}}],[11,"cmp","","",44,{"inputs":[{"name":"self"},{"name":"candidate"}],"output":{"name":"ordering"}}],[0,"config","","Defines a structure to store the configuration of the exploration. The configuration is read from the `Setting.toml` file if it exists. Some parameters can be overridden from the command line.",null,null],[3,"Config","telamon::explorer::config","Stores the configuration of the exploration.",null,null],[12,"log_file","","Name of the file in wich to store the logs.",45,null],[12,"num_workers","","Number of exploration threads.",45,null],[12,"stop_bound","","Indicates the search must be stopped if a candidate with an execution time better than the bound (in ns) is found.",45,null],[12,"timeout","","Indicates the search must be stopped after the given number of minutes.",45,null],[12,"max_evaluations","","Indicates the search must be stopped after the given number of candidates have been evaluated.",45,null],[12,"distance_to_best","","A percentage cut indicate that we only care to find a candidate that is in a certain range above the best Therefore, if cut_under is 20%, we can discard any candidate whose bound is above 80% of the current best.",45,null],[12,"algorithm","","Exploration algorithm to use. Needs to be last for TOML serialization, because it is a table.",45,null],[3,"BanditConfig","","Configuration parameters specific to the multi-armed bandit algorithm.",null,null],[12,"new_nodes_order","","Indicates how to select between nodes of the search tree when none of their children have been evaluated.",46,null],[12,"old_nodes_order","","Indicates how to choose between nodes with at least one children evaluated.",46,null],[12,"threshold","","The number of best execution times to remember.",46,null],[12,"delta","","The biggest delta is, the more focused on the previous best candidates the exploration is.",46,null],[12,"monte_carlo","","If true, does not expand tree until end - instead, starts a montecarlo descend after each expansion of a node",46,null],[4,"SearchAlgorithm","","Exploration algorithm to use.",null,null],[13,"BoundOrder","","Evaluate all the candidates that cannot be pruned.",47,null],[13,"MultiArmedBandit","","Use a multi-armed bandit algorithm.",47,null],[4,"NewNodeOrder","","Indicates how to choose between nodes of the search tree when no children have been evaluated.",null,null],[13,"Api","","Consider the nodes in the order given by the search space API.",48,null],[13,"Random","","Consider the nodes in a random order.",48,null],[13,"Bound","","Consider the nodes with the lowest bound first.",48,null],[13,"WeightedRandom","","Consider the nodes with a probability proportional to the distance between the cut and the bound.",48,null],[4,"OldNodeOrder","","Indicates how to choose between nodes of the search tree with at least one descendent evaluated.",null,null],[13,"Bandit","","Use the weights from the bandit algorithm.",49,null],[13,"Bound","","Take the candidate with the best bound.",49,null],[13,"WeightedRandom","","Consider the nodes with a probability proportional to the distance between the cut and the bound.",49,null],[11,"clone","","",45,{"inputs":[{"name":"self"}],"output":{"name":"config"}}],[11,"read","","Reads the configuration from the \"Settings.toml\" file and from the command line.",45,{"inputs":[],"output":{"name":"self"}}],[11,"read_from_file","","Extract the configuration from the configuration file, if any.",45,{"inputs":[],"output":{"name":"self"}}],[11,"from_json","","Parse the configuration from a JSON string. Primary user is the Python API (through the C API).",45,{"inputs":[{"name":"str"}],"output":{"name":"self"}}],[11,"fmt","","",45,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"default","","",45,{"inputs":[],"output":{"name":"self"}}],[11,"clone","","",47,{"inputs":[{"name":"self"}],"output":{"name":"searchalgorithm"}}],[11,"default","","",47,{"inputs":[],"output":{"name":"self"}}],[11,"clone","","",46,{"inputs":[{"name":"self"}],"output":{"name":"banditconfig"}}],[11,"default","","",46,{"inputs":[],"output":{"name":"self"}}],[11,"clone","","",48,{"inputs":[{"name":"self"}],"output":{"name":"newnodeorder"}}],[11,"default","","",48,{"inputs":[],"output":{"name":"self"}}],[11,"clone","","",49,{"inputs":[{"name":"self"}],"output":{"name":"oldnodeorder"}}],[11,"default","","",49,{"inputs":[],"output":{"name":"self"}}],[0,"choice","telamon::explorer","Choices that can be applied to split the search space.",null,null],[4,"ActionEx","telamon::explorer::choice","Either a regular action or a manually applied action.",null,null],[13,"TileSizes","","",50,null],[13,"Action","","",50,null],[13,"LowerLayout","","",50,null],[12,"mem","telamon::explorer::choice::ActionEx","",50,null],[12,"st_dims","","",50,null],[12,"ld_dims","","",50,null],[5,"list","telamon::explorer::choice","Lists the choices that can be applied to a function.",null,null],[5,"fix_order","","Chooses an order between instructions and dimensions when multiple are possible. The function assumes the order between dimensions is already fixed.",null,{"inputs":[{"name":"searchspace"}],"output":{"name":"searchspace"}}],[6,"Choice","","Represents a choice that splits a search space in multiple ones.",null,null],[11,"fmt","","",50,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",50,{"inputs":[{"name":"self"}],"output":{"name":"actionex"}}],[11,"eq","","",50,{"inputs":[{"name":"self"},{"name":"actionex"}],"output":{"name":"bool"}}],[11,"ne","","",50,{"inputs":[{"name":"self"},{"name":"actionex"}],"output":{"name":"bool"}}],[0,"local_selection","telamon::explorer","Provides different methods to select a candidate in a list.",null,null],[5,"descend","telamon::explorer::local_selection","A recursive function that takes a candidate and expands it until we have a completely specified candidate that we can pass to the evaluator, or we find a dead-end",null,{"inputs":[{"name":"newnodeorder"},{"name":"context"},{"name":"candidate"},{"name":"f64"}],"output":{"generics":["candidate"],"name":"option"}}],[5,"pick_candidate","","Called in montecarlo_descend, dispatch the choice of the next candidate according to our configuration",null,{"inputs":[{"name":"newnodeorder"},{"generics":["candidate"],"name":"vec"},{"name":"f64"}],"output":{"generics":["candidate"],"name":"option"}}],[5,"pick_index","","Returns the index of the next candidate to consider.",null,{"inputs":[{"name":"newnodeorder"},{"name":"it"},{"name":"f64"}],"output":{"generics":["usize"],"name":"option"}}],[0,"ir","telamon","Representation and manipulation of a set of possible implementation.",null,null],[3,"DimMap","telamon::ir","Represents a mapping between dimenions.",null,null],[3,"Dimension","","Represents an iteration dimension.",null,null],[3,"Function","","Describes a function and the set of its possible implementation.",null,null],[3,"Signature","","Holds the signature of a function.",null,null],[12,"name","","Mame of the function.",51,null],[12,"params","","Arguments of the function.",51,null],[12,"mem_blocks","","The number of external memory blocks.",51,null],[3,"Parameter","","Represents an argument of a function.",null,null],[12,"name","","The name of the `Parameter`",52,null],[12,"t","","The type of the `Parameter`.",52,null],[3,"InstId","","Uniquely identifies an instruction.",null,null],[12,"0","","",53,null],[3,"Instruction","","Represents an instruction.",null,null],[3,"IndVarId","","Unique identifier for `InductionVar`",null,null],[12,"0","","",54,null],[3,"InductionVar","","A multidimentional induction variable. No dimension should appear twice in dims.",null,null],[3,"Size","","The size of an iteration dimension. The size is of the form: `(factor * dividend_0 * dividend_1 * ...)) / divisor` where the reminder of the division is null.",null,null],[3,"NewObjs","","Stores the objects created by a lowering.",null,null],[12,"instructions","","",55,null],[12,"dimensions","","",55,null],[12,"basic_blocks","","",55,null],[12,"mem_blocks","","",55,null],[12,"internal_mem_blocks","","",55,null],[12,"mem_insts","","",55,null],[12,"iteration_dims","","",55,null],[12,"thread_dims","","",55,null],[3,"LoweredDimMap","","A point-to-point communication lowered into a store and a load.",null,null],[12,"mem","","",56,null],[12,"store","","",56,null],[12,"load","","",56,null],[12,"dimensions","","",56,null],[4,"Stride","","A stride on a given dimensions.",null,null],[13,"Int","","A fixed stride.",57,null],[13,"Unknown","","A stride that is not statically known.",57,null],[4,"AccessPattern","","",null,null],[13,"Unknown","","Unknown access pattern.",58,null],[12,"mem_id","telamon::ir::AccessPattern","",58,null],[13,"Tensor","telamon::ir","Access with a fixed stride on each dimensions. Accesses on two different dimensions should not overlap.",58,null],[12,"mem_id","telamon::ir::AccessPattern","",58,null],[12,"dims","","",58,null],[4,"BBId","telamon::ir","Provides a unique identifer for a basic block.",null,null],[13,"Inst","","",59,null],[13,"Dim","","",59,null],[4,"Error","","An error occuring while manipulating an ir instance.",null,null],[13,"Type","","",60,null],[13,"InvalidDimSize","","",60,null],[13,"DuplicateIncrement","","",60,null],[12,"dim","telamon::ir::Error","",60,null],[4,"TypeError","telamon::ir","Errors that can be raised when creating an IR instance.",null,null],[13,"InvalidType","","",61,null],[12,"t","telamon::ir::TypeError","",61,null],[13,"ExpectedReturnType","telamon::ir","",61,null],[12,"inst","telamon::ir::TypeError","",61,null],[13,"InvalidRounding","telamon::ir","",61,null],[12,"rounding","telamon::ir::TypeError","",61,null],[12,"t","","",61,null],[13,"WrongType","telamon::ir","",61,null],[12,"given","telamon::ir::TypeError","",61,null],[12,"expected","","",61,null],[13,"UnexpectedType","telamon::ir","",61,null],[12,"t","telamon::ir::TypeError","",61,null],[4,"Operand","telamon::ir","Represents an instruction operand.",null,null],[13,"Int","","An integer constant, on a given number of bits.",62,null],[13,"Float","","A float constant, on a given number of bits.",62,null],[13,"Inst","","A value produced by an instruction. The boolean indicates if the `DimMap` can be lowered.",62,null],[13,"Index","","The current index in a loop.",62,null],[13,"Size","","The size of a dimension.",62,null],[13,"Param","","A parameter of the function.",62,null],[13,"Addr","","The address of a memory block.",62,null],[13,"Reduce","","The value of the current instruction at a previous iteration.",62,null],[13,"InductionVar","","A variable increased by a fixed amount at every step of some loops.",62,null],[4,"DimMapScope","","Indicates how dimensions can be mapped.",null,null],[13,"Local","","The dimensions are mapped within registers, without producing syncthreads.",63,null],[13,"Thread","","The dimensions are mapped within registers.",63,null],[13,"Global","","The dimensions are mapped, possibly using temporary memory.",63,null],[4,"BinOp","","Represents binary arithmetic operators.",null,null],[13,"Add","","Adds two operands.",64,null],[13,"Sub","","Substracts two operands.",64,null],[13,"Div","","Divides two operands,",64,null],[4,"Operator","","The operation performed by an instruction.",null,null],[13,"BinOp","","A binary arithmetic operator.",65,null],[13,"Mul","","Performs a multiplication with the given return type.",65,null],[13,"Mad","","Performs s multiplication between the first two operands and adds the result to the third.",65,null],[13,"Mov","","Moves a value into a register.",65,null],[13,"Ld","","Loads a value of the given type from the given address.",65,null],[13,"St","","Stores the second operand at the address given by the first. The boolean specifies if the instruction has side effects. A store has no side effects when it writes into a cell that previously had an undefined value.",65,null],[13,"TmpLd","","Represents a load from a temporary memory that is not fully defined yet.",65,null],[13,"TmpSt","","Represents a store to a temporary memory that is not fully defined yet.",65,null],[13,"Cast","","Casts a value into another type.",65,null],[4,"Type","","Values and intructions types.",null,null],[13,"I","","Type for integer values, with a fixed number of bits.",66,null],[13,"F","","Type for floating point values, with a fixed number of bits.",66,null],[13,"PtrTo","","Pointer type of the given memory space.",66,null],[11,"eq","","",57,{"inputs":[{"name":"self"},{"name":"stride"}],"output":{"name":"bool"}}],[11,"ne","","",57,{"inputs":[{"name":"self"},{"name":"stride"}],"output":{"name":"bool"}}],[11,"clone","","",57,{"inputs":[{"name":"self"}],"output":{"name":"stride"}}],[11,"fmt","","",57,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"unwrap_or","","Unwrap the stride or return the given value.",57,{"inputs":[{"name":"self"},{"name":"i32"}],"output":{"name":"i32"}}],[11,"clone","","",58,{"inputs":[{"name":"self"}],"output":{"name":"accesspattern"}}],[11,"fmt","","",58,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",58,{"inputs":[{"name":"self"},{"name":"accesspattern"}],"output":{"name":"bool"}}],[11,"ne","","",58,{"inputs":[{"name":"self"},{"name":"accesspattern"}],"output":{"name":"bool"}}],[11,"stride","","Returns the stride on a given dimension.",58,{"inputs":[{"name":"self"},{"name":"id"}],"output":{"name":"stride"}}],[11,"mem_block","","Returns the id of the memory block accessed.",58,{"inputs":[{"name":"self"}],"output":{"name":"id"}}],[11,"clone","","",59,{"inputs":[{"name":"self"}],"output":{"name":"bbid"}}],[11,"fmt","","",59,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",59,{"inputs":[{"name":"self"},{"name":"bbid"}],"output":{"name":"bool"}}],[11,"ne","","",59,{"inputs":[{"name":"self"},{"name":"bbid"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",59,{"inputs":[{"name":"self"},{"name":"bbid"}],"output":{"generics":["ordering"],"name":"option"}}],[11,"lt","","",59,{"inputs":[{"name":"self"},{"name":"bbid"}],"output":{"name":"bool"}}],[11,"le","","",59,{"inputs":[{"name":"self"},{"name":"bbid"}],"output":{"name":"bool"}}],[11,"gt","","",59,{"inputs":[{"name":"self"},{"name":"bbid"}],"output":{"name":"bool"}}],[11,"ge","","",59,{"inputs":[{"name":"self"},{"name":"bbid"}],"output":{"name":"bool"}}],[11,"cmp","","",59,{"inputs":[{"name":"self"},{"name":"bbid"}],"output":{"name":"ordering"}}],[11,"hash","","",59,null],[11,"from","","",59,{"inputs":[{"name":"instid"}],"output":{"name":"self"}}],[11,"from","","",59,{"inputs":[{"name":"id"}],"output":{"name":"self"}}],[11,"clone","","",67,{"inputs":[{"name":"self"}],"output":{"name":"dimension"}}],[11,"fmt","","",67,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Creates a new dimension.",67,{"inputs":[{"name":"size"},{"name":"id"}],"output":{"generics":["dimension","error"],"name":"result"}}],[11,"size","","Retruns the size of the dimension.",67,{"inputs":[{"name":"self"}],"output":{"name":"size"}}],[11,"id","","Returns the id of the dimension.",67,{"inputs":[{"name":"self"}],"output":{"name":"id"}}],[11,"iterated","","Returns the constructs iterated along this dimension.",67,null],[11,"add_iterated","","Adds a bb that is iterated along self.",67,{"inputs":[{"name":"self"},{"name":"instid"}],"output":null}],[11,"is_thread_dim","","Indicates if the dimension is a thread dimension.",67,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"set_thread_dim","","Sets the dimension as a thread dimension.",67,{"inputs":[{"name":"self"}],"output":null}],[11,"bb_id","","",67,{"inputs":[{"name":"self"}],"output":{"name":"bbid"}}],[11,"as_dim","","",67,{"inputs":[{"name":"self"}],"output":{"generics":["dimension"],"name":"option"}}],[11,"eq","","",67,{"inputs":[{"name":"self"},{"name":"dimension"}],"output":{"name":"bool"}}],[11,"hash","","",67,{"inputs":[{"name":"self"},{"name":"h"}],"output":null}],[11,"clone","","",68,{"inputs":[{"name":"self"}],"output":{"name":"dimmap"}}],[11,"fmt","","",68,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Create a new `DimMap`.",68,{"inputs":[{"name":"it"}],"output":{"name":"self"}}],[11,"empty","","Returns an empty `DimMap`.",68,{"inputs":[],"output":{"name":"dimmap"}}],[11,"merge_dims","","Renames a basic block into an other. Indicates if some mapping were removed.",68,{"inputs":[{"name":"self"},{"name":"id"},{"name":"id"}],"output":{"name":"bool"}}],[11,"iter","","Iterates over the DimMap.",68,{"inputs":[{"name":"self"}],"output":{"name":"iter"}}],[11,"filter","","Filters the DimMap.",68,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"filterlist"}}],[11,"is_empty","","Returns true if the `DimMap` is empty.",68,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"into_iter","","",68,null],[11,"fmt","","",61,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"cause","","",61,{"inputs":[{"name":"self"}],"output":{"generics":["fail"],"name":"option"}}],[11,"backtrace","","",61,{"inputs":[{"name":"self"}],"output":{"generics":["backtrace"],"name":"option"}}],[11,"fmt","","",61,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"check_equals","","Ensures a type is equal to the expected one.",61,{"inputs":[{"name":"type"},{"name":"type"}],"output":{"name":"result"}}],[11,"check_integer","","Ensures the given type is an integer type.",61,{"inputs":[{"name":"type"}],"output":{"name":"result"}}],[11,"fmt","","",60,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"cause","","",60,{"inputs":[{"name":"self"}],"output":{"generics":["fail"],"name":"option"}}],[11,"backtrace","","",60,{"inputs":[{"name":"self"}],"output":{"generics":["backtrace"],"name":"option"}}],[11,"fmt","","",60,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from","","",60,{"inputs":[{"name":"typeerror"}],"output":{"name":"self"}}],[11,"eq","","",52,{"inputs":[{"name":"self"},{"name":"parameter"}],"output":{"name":"bool"}}],[11,"ne","","",52,{"inputs":[{"name":"self"},{"name":"parameter"}],"output":{"name":"bool"}}],[11,"hash","","",52,null],[11,"clone","","",52,{"inputs":[{"name":"self"}],"output":{"name":"parameter"}}],[11,"fmt","","",52,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",51,{"inputs":[{"name":"self"}],"output":{"name":"signature"}}],[11,"eq","","",51,{"inputs":[{"name":"self"},{"name":"signature"}],"output":{"name":"bool"}}],[11,"ne","","",51,{"inputs":[{"name":"self"},{"name":"signature"}],"output":{"name":"bool"}}],[11,"hash","","",51,null],[11,"new","","Creates a new signature without any parameter.",51,{"inputs":[{"name":"string"}],"output":{"name":"self"}}],[11,"add_scalar","","Adds a scalar parameter.",51,{"inputs":[{"name":"self"},{"name":"string"},{"name":"type"}],"output":null}],[11,"add_array","","Adds a parameter with the given name and type to the signature.",51,{"inputs":[{"name":"self"},{"name":"string"}],"output":{"name":"id"}}],[11,"clone","","",69,{"inputs":[{"name":"self"}],"output":{"name":"function"}}],[11,"new","","Creates a new function.",69,{"inputs":[{"name":"signature"},{"name":"device"}],"output":{"name":"self"}}],[11,"signature","","Returns the function signature.",69,{"inputs":[{"name":"self"}],"output":{"name":"signature"}}],[11,"device","","Returns the device the function is compiled for.",69,{"inputs":[{"name":"self"}],"output":{"name":"device"}}],[11,"add_inst","","Adds an instruction to the function.",69,{"inputs":[{"name":"self"},{"name":"operator"},{"generics":["id"],"name":"hashset"}],"output":{"generics":["instid","error"],"name":"result"}}],[11,"add_dim","","Creates a new dimension.",69,{"inputs":[{"name":"self"},{"name":"size"}],"output":{"generics":["id","error"],"name":"result"}}],[11,"add_mem_block","","Allocates a new memory block.",69,{"inputs":[{"name":"self"},{"name":"size"},{"name":"bool"}],"output":{"name":"internalid"}}],[11,"add_ind_var","","Adds an induction variable.",69,{"inputs":[{"name":"self"},{"name":"inductionvar"}],"output":{"name":"indvarid"}}],[11,"insts","","Returns the list of instructions of the function.",69,null],[11,"dims","","Returns the list of dimensions of the function.",69,null],[11,"blocks","","Lists all `BasicBlock`s.",69,null],[11,"thread_dims","","Returns the list of thread dimensions.",69,null],[11,"inst","","Returns an instruction given its id.",69,{"inputs":[{"name":"self"},{"name":"instid"}],"output":{"name":"instruction"}}],[11,"dim","","Retuns a dimension given its id.",69,{"inputs":[{"name":"self"},{"name":"id"}],"output":{"name":"dimension"}}],[11,"block","","Returns a `BasicBlock` given its id.",69,{"inputs":[{"name":"self"},{"name":"bbid"}],"output":{"name":"basicblock"}}],[11,"mem_blocks","","Returns the list of memory blocks. The block with id `i` is in i-th position.",69,null],[11,"mem_insts","","Iterates over memory instructions.",69,null],[11,"internal_mem_blocks","","Returns the internal memory blocks.",69,null],[11,"mem_block","","Returns a memory block given its id.",69,{"inputs":[{"name":"self"},{"name":"id"}],"output":{"name":"block"}}],[11,"internal_mem_block","","Returns an internal memory block given its id.",69,{"inputs":[{"name":"self"},{"name":"internalid"}],"output":{"name":"internalblock"}}],[11,"induction_var","","Retrieves an induction variable given its Id.",69,{"inputs":[{"name":"self"},{"name":"indvarid"}],"output":{"name":"inductionvar"}}],[11,"induction_vars","","Iterates over induction variables.",69,null],[11,"set_iteration_dim","","Sets a dimension as an iteration dimension for an instruction. Indicates if the iteration dimension was not aleady present in the set.",69,{"inputs":[{"name":"self"},{"name":"instid"},{"name":"id"}],"output":{"name":"bool"}}],[11,"add_thread_dim","","Adds a thread dimension. Indicates if the the dimension was not already present in the set.",69,{"inputs":[{"name":"self"},{"name":"id"}],"output":{"name":"bool"}}],[11,"deref","","",69,null],[11,"fmt","","",54,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",54,{"inputs":[{"name":"self"}],"output":{"name":"indvarid"}}],[11,"hash","","",54,null],[11,"eq","","",54,{"inputs":[{"name":"self"},{"name":"indvarid"}],"output":{"name":"bool"}}],[11,"ne","","",54,{"inputs":[{"name":"self"},{"name":"indvarid"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",54,{"inputs":[{"name":"self"},{"name":"indvarid"}],"output":{"generics":["ordering"],"name":"option"}}],[11,"lt","","",54,{"inputs":[{"name":"self"},{"name":"indvarid"}],"output":{"name":"bool"}}],[11,"le","","",54,{"inputs":[{"name":"self"},{"name":"indvarid"}],"output":{"name":"bool"}}],[11,"gt","","",54,{"inputs":[{"name":"self"},{"name":"indvarid"}],"output":{"name":"bool"}}],[11,"ge","","",54,{"inputs":[{"name":"self"},{"name":"indvarid"}],"output":{"name":"bool"}}],[11,"cmp","","",54,{"inputs":[{"name":"self"},{"name":"indvarid"}],"output":{"name":"ordering"}}],[11,"clone","","",70,{"inputs":[{"name":"self"}],"output":{"name":"inductionvar"}}],[11,"fmt","","",70,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Creates a new induction var. Size represents the increment over each diemnsion taken independenly.",70,{"inputs":[{"name":"vec"},{"name":"operand"}],"output":{"generics":["error"],"name":"result"}}],[11,"merge_dims","","Renames a dimension.",70,{"inputs":[{"name":"self"},{"name":"id"},{"name":"id"}],"output":null}],[11,"base","","Returns the base operand of the induction variable.",70,{"inputs":[{"name":"self"}],"output":{"name":"operand"}}],[11,"dims","","Returns the list of induction dimensions along with the corresponding increments.",70,null],[11,"clone","","",53,{"inputs":[{"name":"self"}],"output":{"name":"instid"}}],[11,"fmt","","",53,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",53,{"inputs":[{"name":"self"},{"name":"instid"}],"output":{"name":"bool"}}],[11,"ne","","",53,{"inputs":[{"name":"self"},{"name":"instid"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",53,{"inputs":[{"name":"self"},{"name":"instid"}],"output":{"generics":["ordering"],"name":"option"}}],[11,"lt","","",53,{"inputs":[{"name":"self"},{"name":"instid"}],"output":{"name":"bool"}}],[11,"le","","",53,{"inputs":[{"name":"self"},{"name":"instid"}],"output":{"name":"bool"}}],[11,"gt","","",53,{"inputs":[{"name":"self"},{"name":"instid"}],"output":{"name":"bool"}}],[11,"ge","","",53,{"inputs":[{"name":"self"},{"name":"instid"}],"output":{"name":"bool"}}],[11,"cmp","","",53,{"inputs":[{"name":"self"},{"name":"instid"}],"output":{"name":"ordering"}}],[11,"hash","","",53,null],[11,"fmt","","",53,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",71,{"inputs":[{"name":"self"}],"output":{"name":"instruction"}}],[11,"fmt","","",71,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Creates a new instruction and type-check the operands.",71,{"inputs":[{"name":"operator"},{"name":"instid"},{"generics":["id"],"name":"hashset"},{"name":"device"}],"output":{"generics":["instruction","error"],"name":"result"}}],[11,"operands","","Returns the list of operands of an `Instruction`.",71,{"inputs":[{"name":"self"}],"output":{"generics":["operand"],"name":"vec"}}],[11,"t","","Returns the type of the value produced by an instruction.",71,{"inputs":[{"name":"self"}],"output":{"generics":["type"],"name":"option"}}],[11,"operator","","Returns the operator of the instruction.",71,{"inputs":[{"name":"self"}],"output":{"name":"operator"}}],[11,"id","","Returns the `InstId` representing the instruction.",71,{"inputs":[{"name":"self"}],"output":{"name":"instid"}}],[11,"has_side_effects","","Returns true if the instruction has side effects.",71,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"lower_layout","","Applies the lowering of a layout to the instruction.",71,{"inputs":[{"name":"self"},{"name":"operand"},{"name":"accesspattern"},{"name":"operand"},{"name":"accesspattern"}],"output":null}],[11,"lower_dim_map","","Lowers the `DimMap` of an operand into an access to a temporary memory.",71,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"instid"},{"name":"dimmap"}],"output":null}],[11,"dim_maps_to_lower","","Indicates the operands for wich a `DimMap` must be lowered if lhs and rhs are not mapped.",71,{"inputs":[{"name":"self"},{"name":"id"},{"name":"id"}],"output":{"generics":["usize"],"name":"vec"}}],[11,"as_mem_inst","","Returns 'self' if it is a memory instruction.",71,{"inputs":[{"name":"self"}],"output":{"generics":["instruction"],"name":"option"}}],[11,"as_reduction","","Indicates if the instruction performs a reduction.",71,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"is_reduction_common_dim","","Returns 'true' if `self` is a reduction initialized by init, and if 'dim' should have the same nesting with 'init' that with 'self'.",71,{"inputs":[{"name":"self"},{"name":"instid"},{"name":"id"}],"output":{"name":"bool"}}],[11,"merge_dims","","Rename a dimension to another ID.",71,{"inputs":[{"name":"self"},{"name":"id"},{"name":"id"}],"output":null}],[11,"iteration_dims","","The list of dimensions the instruction must be nested in.",71,{"inputs":[{"name":"self"}],"output":{"name":"hashset"}}],[11,"add_iteration_dimension","","Adds a new iteration dimension. Indicates if the dimension was not already an iteration dimension.",71,{"inputs":[{"name":"self"},{"name":"id"}],"output":{"name":"bool"}}],[11,"bb_id","","",71,{"inputs":[{"name":"self"}],"output":{"name":"bbid"}}],[11,"as_inst","","",71,{"inputs":[{"name":"self"}],"output":{"generics":["instruction"],"name":"option"}}],[11,"eq","","",71,{"inputs":[{"name":"self"},{"name":"instruction"}],"output":{"name":"bool"}}],[11,"hash","","",71,{"inputs":[{"name":"self"},{"name":"h"}],"output":null}],[11,"fmt","","",63,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",63,{"inputs":[{"name":"self"}],"output":{"name":"dimmapscope"}}],[11,"eq","","",63,{"inputs":[{"name":"self"},{"name":"dimmapscope"}],"output":{"name":"bool"}}],[11,"clone","","",62,{"inputs":[{"name":"self"}],"output":{"name":"operand"}}],[11,"fmt","","",62,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"t","","Returns the type of the `Operand`.",62,{"inputs":[{"name":"self"}],"output":{"name":"type"}}],[11,"new_inst","","Create an operand from an instruction.",62,{"inputs":[{"name":"instruction"},{"name":"dimmap"},{"name":"dimmapscope"}],"output":{"name":"operand"}}],[11,"new_reduce","","Creates a reduce operand from an instruction and a set of dimensions to reduce on.",62,{"inputs":[{"name":"instruction"},{"name":"dimmap"},{"generics":["id"],"name":"vec"}],"output":{"name":"operand"}}],[11,"new_int","","Creates a new Int operand and checks its number of bits.",62,{"inputs":[{"name":"bigint"},{"name":"u16"}],"output":{"name":"operand"}}],[11,"new_float","","Creates a new Float operand.",62,{"inputs":[{"generics":["bigint"],"name":"ratio"},{"name":"u16"}],"output":{"name":"operand"}}],[11,"merge_dims","","Renames a basic block id.",62,{"inputs":[{"name":"self"},{"name":"id"},{"name":"id"}],"output":null}],[11,"should_lower_map","","Indicates if a `DimMap` should be lowered if lhs and rhs are not mapped.",62,{"inputs":[{"name":"self"},{"name":"id"},{"name":"id"}],"output":{"name":"bool"}}],[11,"as_reduction","","If the operand is a reduction, returns the instruction initializing the reduction.",62,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"is_constant","","Indicates if the operand stays constant during the execution.",62,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"clone","","",64,{"inputs":[{"name":"self"}],"output":{"name":"binop"}}],[11,"fmt","","",64,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",65,{"inputs":[{"name":"self"}],"output":{"name":"operator"}}],[11,"fmt","","",65,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"type_check","","Ensures the types of the operands are valid.",65,{"inputs":[{"name":"self"},{"name":"device"}],"output":{"generics":["typeerror"],"name":"result"}}],[11,"t","","Returns the type of the value produced.",65,{"inputs":[{"name":"self"}],"output":{"generics":["type"],"name":"option"}}],[11,"operands","","Retruns the list of operands.",65,{"inputs":[{"name":"self"}],"output":{"generics":["operand"],"name":"vec"}}],[11,"operands_mut","","Retruns the list of mutable references to operands.",65,{"inputs":[{"name":"self"}],"output":{"generics":["operand"],"name":"vec"}}],[11,"has_side_effects","","Returns true if the operator has side effects.",65,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"merge_dims","","Renames a basic block.",65,{"inputs":[{"name":"self"},{"name":"id"},{"name":"id"}],"output":null}],[11,"mem_access_pattern","","Returns the pattern of access to the memory by the instruction, if any.",65,{"inputs":[{"name":"self"}],"output":{"generics":["cow"],"name":"option"}}],[11,"mem_used","","Returns the memory blocks referenced by the instruction.",65,{"inputs":[{"name":"self"}],"output":{"generics":["id"],"name":"option"}}],[11,"supports_nc_access","","Indicates if the operator supports non-coherent memory accesses.",65,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"fmt","","",65,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",72,{"inputs":[{"name":"self"}],"output":{"name":"size"}}],[11,"fmt","","",72,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"hash","","",72,null],[11,"eq","","",72,{"inputs":[{"name":"self"},{"name":"size"}],"output":{"name":"bool"}}],[11,"ne","","",72,{"inputs":[{"name":"self"},{"name":"size"}],"output":{"name":"bool"}}],[11,"new","","Creates a new 'Size'.",72,{"inputs":[{"name":"u32"},{"generics":["parameter"],"name":"vec"},{"name":"u32"}],"output":{"name":"self"}}],[11,"as_int","","Returns the size of a dimension if it is staticaly known.",72,{"inputs":[{"name":"self"}],"output":{"generics":["u32"],"name":"option"}}],[11,"is_constant","","Indicates if the size is constant.",72,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"dividend","","Returns the dividends.",72,null],[11,"divisor","","Returns the divisor.",72,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"factor","","Returns the factor.",72,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"mul_divisor","","Multiplies the divisor by the given factor.",72,{"inputs":[{"name":"self"},{"name":"u32"}],"output":null}],[11,"mul_factor","","Multiplies the factor by the given factor.",72,{"inputs":[{"name":"self"},{"name":"u32"}],"output":null}],[11,"mul_assign","","",72,{"inputs":[{"name":"self"},{"name":"size"}],"output":null}],[11,"clone","","",66,{"inputs":[{"name":"self"}],"output":{"name":"type"}}],[11,"eq","","",66,{"inputs":[{"name":"self"},{"name":"type"}],"output":{"name":"bool"}}],[11,"ne","","",66,{"inputs":[{"name":"self"},{"name":"type"}],"output":{"name":"bool"}}],[11,"hash","","",66,null],[11,"fmt","","",66,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"is_integer","","Returns true if the type is an integer.",66,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_float","","Returns true if the type is a float.",66,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"len_byte","","Returns the number of bytes of the type.",66,{"inputs":[{"name":"self"}],"output":{"generics":["u32"],"name":"option"}}],[11,"fmt","","",66,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[0,"mem","","A module for handling accesses to the device memory.",null,null],[3,"InternalId","telamon::ir::mem","",null,null],[12,"0","","",73,null],[3,"InternalBlock","","A block of memory allocated on the device by the kernel.",null,null],[3,"ExternalBlock","","A memory block allocated by the user.",null,null],[3,"BlockMap","","Holds the blocks of memory to allocate on the device.",null,null],[4,"Id","","Uniquely identifies a block.",null,null],[13,"Internal","","",74,null],[13,"External","","",74,null],[8,"Block","","Represents a memory block.",null,null],[10,"mem_id","","The ID of the block.",75,{"inputs":[{"name":"self"}],"output":{"name":"id"}}],[11,"as_internal","","Returns self if it is an internal memory block.",75,{"inputs":[{"name":"self"}],"output":{"generics":["internalblock"],"name":"option"}}],[10,"uses","","The list of instructions referencing the memory block.",75,null],[10,"add_use","","Add a use to the block.",75,{"inputs":[{"name":"self"},{"name":"instid"}],"output":null}],[11,"clone","","",74,{"inputs":[{"name":"self"}],"output":{"name":"id"}}],[11,"eq","","",74,{"inputs":[{"name":"self"},{"name":"id"}],"output":{"name":"bool"}}],[11,"ne","","",74,{"inputs":[{"name":"self"},{"name":"id"}],"output":{"name":"bool"}}],[11,"hash","","",74,null],[11,"fmt","","",74,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",73,{"inputs":[{"name":"self"}],"output":{"name":"internalid"}}],[11,"eq","","",73,{"inputs":[{"name":"self"},{"name":"internalid"}],"output":{"name":"bool"}}],[11,"ne","","",73,{"inputs":[{"name":"self"},{"name":"internalid"}],"output":{"name":"bool"}}],[11,"hash","","",73,null],[11,"fmt","","",73,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from","","",74,{"inputs":[{"name":"internalid"}],"output":{"name":"self"}}],[11,"clone","","",76,{"inputs":[{"name":"self"}],"output":{"name":"internalblock"}}],[11,"eq","","",76,{"inputs":[{"name":"self"},{"name":"internalblock"}],"output":{"name":"bool"}}],[11,"hash","","",76,{"inputs":[{"name":"self"},{"name":"h"}],"output":null}],[11,"clone","","",77,{"inputs":[{"name":"self"}],"output":{"name":"externalblock"}}],[11,"id","","Returns the unique identifer of the memory block.",76,{"inputs":[{"name":"self"}],"output":{"name":"internalid"}}],[11,"size","","The size of the dimensions of the memory block.",76,{"inputs":[{"name":"self"}],"output":{"name":"size"}}],[11,"maps_dims","","Indicates if two dimensions are mapped by a temporary memory block.",76,{"inputs":[{"name":"self"},{"name":"id"},{"name":"id"}],"output":{"name":"bool"}}],[11,"mapped_dims","","Returns the list of mapped dimensions.",76,null],[11,"is_private","","Indicates if the block is privatised per block of thread.",76,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"base_size","","Return the base size of the block, if it is statically known.",76,{"inputs":[{"name":"self"}],"output":{"generics":["u32"],"name":"option"}}],[11,"mem_id","","",76,{"inputs":[{"name":"self"}],"output":{"name":"id"}}],[11,"as_internal","","",76,{"inputs":[{"name":"self"}],"output":{"generics":["internalblock"],"name":"option"}}],[11,"uses","","",76,null],[11,"add_use","","",76,{"inputs":[{"name":"self"},{"name":"instid"}],"output":null}],[11,"mem_id","","",77,{"inputs":[{"name":"self"}],"output":{"name":"id"}}],[11,"uses","","",77,null],[11,"add_use","","",77,{"inputs":[{"name":"self"},{"name":"instid"}],"output":null}],[11,"clone","","",78,{"inputs":[{"name":"self"}],"output":{"name":"blockmap"}}],[11,"new","","Creates a new `BlocksMap`.",78,{"inputs":[{"name":"u32"}],"output":{"name":"blockmap"}}],[11,"alloc_block","","Allocates a new `Block` with the given type and sizes. Must call not merged on the dimensions that cannot be merged upon creation.",78,{"inputs":[{"name":"self"},{"name":"size"},{"name":"bool"},{"generics":["dimmap"],"name":"option"}],"output":{"name":"internalid"}}],[11,"new_tmp","","Inserts a new temporary memory. Must be inserted before not_merged is called on dimensions.",78,{"inputs":[{"name":"self"},{"name":"type"},{"name":"it"}],"output":{"name":"internalid"}}],[11,"register_use","","Registers a use of a memory block by an instruction.",78,{"inputs":[{"name":"self"},{"name":"id"},{"name":"instid"}],"output":null}],[11,"block","","Returns a block given its Id.",78,{"inputs":[{"name":"self"},{"name":"id"}],"output":{"name":"block"}}],[11,"block_mut","","Returns a block given its Id.",78,{"inputs":[{"name":"self"},{"name":"id"}],"output":{"name":"block"}}],[11,"internal_block","","Returns the internal block given its ID.",78,{"inputs":[{"name":"self"},{"name":"internalid"}],"output":{"name":"internalblock"}}],[11,"internal_blocks","","Retuns the list of internal blocks.",78,null],[11,"blocks","","Returns the list of memory blocks.",78,null],[11,"merge_dims","","Rename a basic block. Returns the lyaouts to lower.",78,{"inputs":[{"name":"self"},{"name":"id"},{"name":"id"}],"output":{"generics":["internalid"],"name":"vec"}}],[11,"not_merged","","Registers that two dimensions may not be merged. Returns a list of dimensions removed from the memory blocks and a list of layouts to lower.",78,{"inputs":[{"name":"self"},{"name":"dimension"},{"name":"id"}],"output":{"generics":["internalid"],"name":"vec"}}],[11,"lower_layout","","Lowers a fully defined layout. Returns the mapping of dimensions.",78,{"inputs":[{"name":"self"},{"name":"internalid"}],"output":{"name":"vec"}}],[0,"dim","telamon::ir","Defines iteration dimensions properties.",null,null],[3,"Id","telamon::ir::dim","Provides a unique identifier for iteration dimensions.",null,null],[12,"0","","",79,null],[3,"Map","","Represents a mapping between dimenions.",null,null],[0,"op","telamon::ir","Defines operators.",null,null],[4,"Rounding","telamon::ir::op","The rounding mode of an arithmetic operation.",null,null],[13,"Exact","","No rounding occurs.",80,null],[13,"Nearest","","Rounds toward the nearest number.",80,null],[13,"Zero","","Rounds toward zero.",80,null],[13,"Positive","","Rounds toward positive infinite.",80,null],[13,"Negative","","Rounds toward negative infinite.",80,null],[4,"BinOp","","Represents binary arithmetic operators.",null,null],[13,"Add","","Adds two operands.",64,null],[13,"Sub","","Substracts two operands.",64,null],[13,"Div","","Divides two operands,",64,null],[0,"prelude","telamon::ir","Defines traits to import in the environment to use the IR.",null,null],[8,"BasicBlock","telamon::ir::prelude","Represents a basic block in an Exhaust function.",null,null],[10,"bb_id","","Returns the unique identifier of the `BasicBlock`.",81,{"inputs":[{"name":"self"}],"output":{"name":"bbid"}}],[11,"as_inst","","Returns 'self' if it is an instruction.",81,{"inputs":[{"name":"self"}],"output":{"generics":["instruction"],"name":"option"}}],[11,"as_dim","","Returns 'self' if it is a dimension",81,{"inputs":[{"name":"self"}],"output":{"generics":["dimension"],"name":"option"}}],[8,"BasicBlock","telamon::ir","Represents a basic block in an Exhaust function.",null,null],[10,"bb_id","","Returns the unique identifier of the `BasicBlock`.",81,{"inputs":[{"name":"self"}],"output":{"name":"bbid"}}],[11,"as_inst","telamon::ir::prelude","Returns 'self' if it is an instruction.",81,{"inputs":[{"name":"self"}],"output":{"generics":["instruction"],"name":"option"}}],[11,"as_dim","","Returns 'self' if it is a dimension",81,{"inputs":[{"name":"self"}],"output":{"generics":["dimension"],"name":"option"}}],[11,"default","telamon::ir","",55,{"inputs":[],"output":{"name":"newobjs"}}],[11,"fmt","","",55,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"add_instruction","","Registers a new instruction.",55,{"inputs":[{"name":"self"},{"name":"instruction"}],"output":null}],[11,"add_mem_instruction","","Registers a new memory instruction.",55,{"inputs":[{"name":"self"},{"name":"instruction"}],"output":null}],[11,"add_dimension","","Registers a new dimension.",55,{"inputs":[{"name":"self"},{"name":"dimension"}],"output":null}],[11,"add_bb","","Registers a new basic block.",55,{"inputs":[{"name":"self"},{"name":"basicblock"}],"output":null}],[11,"add_iteration_dim","","Sets a dimension as a new iteration dimension.",55,{"inputs":[{"name":"self"},{"name":"instid"},{"name":"id"}],"output":null}],[11,"add_thread_dim","","Sets a dimension as a new thread dimension.",55,{"inputs":[{"name":"self"},{"name":"id"}],"output":null}],[11,"add_mem_block","","Registers a new memory block.",55,{"inputs":[{"name":"self"},{"name":"internalid"}],"output":null}],[0,"model","telamon","Building Blocks for lower bound performance models.",null,null],[3,"HwPressure","telamon::model","The pressure on the hardware induced by a computation.",null,null],[3,"Nesting","","Nesting of an object.",null,null],[12,"inner_dims","","Dimensions nested inside the current BB.",82,null],[12,"inner_bbs","","Basic blocks nested inside the current BB.",82,null],[12,"outer_dims","","Dimensions nested outsidethe current BB.",82,null],[12,"before_self","","Dimensions to be processed before the current BB.",82,null],[12,"after_self","","Dimensions that should not take the current BB into account when processed.",82,null],[12,"bigger_merged_dims","","The dimensions that can be merged to this one and have a bigger ID.",82,null],[12,"num_unmapped_threads","","Number of threads that are not represented in the active dimensions of the block.",82,null],[12,"max_threads_per_block","","Maximal number of threads this block can be in, considering only outer and mapped out dimensions.",82,null],[4,"BottleneckLevel","","The level at which a bottleneck is computed.",null,null],[13,"Global","","",83,null],[13,"Block","","",83,null],[13,"Thread","","",83,null],[5,"bound","","Returns a lower bound on the execution time of all the implementation candidates in `space`, when executed in `context`.",null,{"inputs":[{"name":"searchspace"},{"name":"context"}],"output":{"name":"bound"}}],[11,"fmt","","",83,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",83,{"inputs":[{"name":"self"}],"output":{"name":"bottlenecklevel"}}],[11,"eq","","",83,{"inputs":[{"name":"self"},{"name":"bottlenecklevel"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",83,{"inputs":[{"name":"self"},{"name":"bottlenecklevel"}],"output":{"generics":["ordering"],"name":"option"}}],[11,"cmp","","",83,{"inputs":[{"name":"self"},{"name":"bottlenecklevel"}],"output":{"name":"ordering"}}],[11,"accounts_for_dim","","Indicates if a dimension should be taken into account for the bottleneck level.",83,{"inputs":[{"name":"self"},{"name":"dimkind"}],"output":{"name":"bool"}}],[11,"fmt","","",83,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",84,{"inputs":[{"name":"self"}],"output":{"name":"hwpressure"}}],[11,"fmt","","",84,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Creates a new `Pressure`",84,{"inputs":[{"name":"f64"},{"generics":["f64"],"name":"vec"}],"output":{"name":"self"}}],[11,"zero","","Creates a null `Pressure` for the given device.",84,{"inputs":[{"name":"device"}],"output":{"name":"self"}}],[11,"bound","","Derive a bound on the execution time from the pressure on the hardware.",84,{"inputs":[{"name":"self"},{"name":"bottlenecklevel"},{"name":"hwpressure"}],"output":{"generics":["rc"],"name":"explainedbound"}}],[11,"add_parallel","","Adds the pressure of another computation, performed in parallel.",84,{"inputs":[{"name":"self"},{"name":"hwpressure"}],"output":null}],[11,"add_sequential","","Adds the pressure of another computation, performed sequentially.",84,{"inputs":[{"name":"self"},{"name":"hwpressure"}],"output":null}],[11,"repeat_parallel","","Computes the pressure obtained by duplicating this one in parallel.",84,{"inputs":[{"name":"self"},{"name":"f64"}],"output":null}],[11,"repeat_and_add_bottlenecks","","Adds the pressure of another computation, repeated in parallel. Ignores the latency.",84,{"inputs":[{"name":"self"},{"name":"f64"},{"name":"hwpressure"}],"output":null}],[11,"repeat_sequential","","Computes the pressure obtained by repeating this one sequentially.",84,{"inputs":[{"name":"self"},{"name":"f64"}],"output":null}],[11,"minimize","","Take the minimum of `self` and `other` for each bottleneck.",84,{"inputs":[{"name":"self"},{"name":"hwpressure"}],"output":null}],[11,"min","","Returns the pointwise minimum of a serie of `HwPressure`",84,{"inputs":[{"name":"it"}],"output":{"name":"option"}}],[11,"multiply","","Pointwise multiplication of the pressure on each resource.",84,{"inputs":[{"name":"self"},{"name":"hwpressure"}],"output":null}],[11,"fmt","","",82,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[6,"Bound","","A lower bound on the execution time, with a detailed explanation of the origin of the bound.",null,null],[0,"search_space","telamon","Search space datastructures and constraint propagation.",null,null],[3,"Bool","telamon::search_space","",null,null],[3,"DimKind","","Specifies how iteration dimensions are implemented.",null,null],[3,"DomainStore","","Stores the domains of each variable.",null,null],[3,"InstFlag","","Specifies the version of an instruction to use.",null,null],[3,"Order","","Defines how two basic blocks are ordered.",null,null],[3,"MemSpace","","Indicates where a memory block is located.",null,null],[3,"ThreadMapping","","Indicates how are thread dimensions mapped on the GPU.",null,null],[3,"SearchSpace","","A partially specified implementation.",null,null],[4,"Action","","A decision to apply to the domain.",null,null],[13,"ThreadMapping","","",85,null],[13,"NumBlockDims","","",85,null],[13,"IncrementMemSize","","",85,null],[13,"MemSize","","",85,null],[13,"Order","","",85,null],[13,"NumThreadDims","","",85,null],[13,"IsThreadDimClassCounter","","",85,null],[13,"DimKind","","",85,null],[13,"InstFlag","","",85,null],[13,"SharedMemUsed","","",85,null],[13,"IsIterationDim","","",85,null],[13,"IsThreadDim","","",85,null],[13,"NumNestedInst","","",85,null],[13,"MemSpace","","",85,null],[13,"UnrollFactor","","",85,null],[13,"IncrementUnrollFactor","","",85,null],[13,"IncrementNumBlockDims","","",85,null],[13,"DimMapping","","",85,null],[13,"IsIterationDimClassCounter","","",85,null],[13,"NumThreads","","",85,null],[11,"clone","","",86,{"inputs":[{"name":"self"}],"output":{"name":"domainstore"}}],[11,"fmt","","",86,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"default","","",86,{"inputs":[],"output":{"name":"domainstore"}}],[11,"new","","Creates a new domain store and allocates the variables for the given BBMap.",86,{"inputs":[{"name":"function"}],"output":{"name":"self"}}],[11,"alloc","","Allocates the choices when new objects are created.",86,{"inputs":[{"name":"self"},{"name":"function"},{"name":"newobjs"}],"output":null}],[11,"get_thread_mapping","","Returns the domain of {name} for the given arguments.",86,{"inputs":[{"name":"self"},{"name":"id"},{"name":"id"}],"output":{"name":"threadmapping"}}],[11,"get_old_thread_mapping","","Returns the domain of {name} for the given arguments. If the domain has been restricted but the change not yet applied, returns the old value.",86,{"inputs":[{"name":"self"},{"name":"id"},{"name":"id"},{"name":"domaindiff"}],"output":{"name":"threadmapping"}}],[11,"set_thread_mapping","","Sets the domain of {name} for the given arguments.",86,{"inputs":[{"name":"self"},{"name":"id"},{"name":"id"},{"name":"threadmapping"}],"output":null}],[11,"restrict_thread_mapping","","Restricts the domain of {name} for the given arguments. Put the old value in `diff` and indicates if the new domain is failed.",86,{"inputs":[{"name":"self"},{"name":"id"},{"name":"id"},{"name":"threadmapping"},{"name":"domaindiff"}],"output":{"name":"result"}}],[11,"get_num_block_dims","","Returns the domain of {name} for the given arguments.",86,{"inputs":[{"name":"self"},{"name":"instid"}],"output":{"name":"halfrange"}}],[11,"get_old_num_block_dims","","Returns the domain of {name} for the given arguments. If the domain has been restricted but the change not yet applied, returns the old value.",86,{"inputs":[{"name":"self"},{"name":"instid"},{"name":"domaindiff"}],"output":{"name":"halfrange"}}],[11,"set_num_block_dims","","Sets the domain of {name} for the given arguments.",86,{"inputs":[{"name":"self"},{"name":"instid"},{"name":"halfrange"}],"output":null}],[11,"restrict_num_block_dims","","Restricts the domain of {name} for the given arguments. Put the old value in `diff` and indicates if the new domain is failed.",86,{"inputs":[{"name":"self"},{"name":"instid"},{"name":"halfrange"},{"name":"domaindiff"}],"output":{"name":"result"}}],[11,"get_increment_mem_size","","Returns the domain of {name} for the given arguments.",86,{"inputs":[{"name":"self"},{"name":"internalid"},{"name":"id"},{"name":"id"}],"output":{"name":"bool"}}],[11,"get_old_increment_mem_size","","Returns the domain of {name} for the given arguments. If the domain has been restricted but the change not yet applied, returns the old value.",86,{"inputs":[{"name":"self"},{"name":"internalid"},{"name":"id"},{"name":"id"},{"name":"domaindiff"}],"output":{"name":"bool"}}],[11,"set_increment_mem_size","","Sets the domain of {name} for the given arguments.",86,{"inputs":[{"name":"self"},{"name":"internalid"},{"name":"id"},{"name":"id"},{"name":"bool"}],"output":null}],[11,"restrict_increment_mem_size","","Restricts the domain of {name} for the given arguments. Put the old value in `diff` and indicates if the new domain is failed.",86,{"inputs":[{"name":"self"},{"name":"internalid"},{"name":"id"},{"name":"id"},{"name":"bool"},{"name":"domaindiff"}],"output":{"name":"result"}}],[11,"get_mem_size","","Returns the domain of {name} for the given arguments.",86,{"inputs":[{"name":"self"},{"name":"internalid"}],"output":{"name":"halfrange"}}],[11,"get_old_mem_size","","Returns the domain of {name} for the given arguments. If the domain has been restricted but the change not yet applied, returns the old value.",86,{"inputs":[{"name":"self"},{"name":"internalid"},{"name":"domaindiff"}],"output":{"name":"halfrange"}}],[11,"set_mem_size","","Sets the domain of {name} for the given arguments.",86,{"inputs":[{"name":"self"},{"name":"internalid"},{"name":"halfrange"}],"output":null}],[11,"restrict_mem_size","","Restricts the domain of {name} for the given arguments. Put the old value in `diff` and indicates if the new domain is failed.",86,{"inputs":[{"name":"self"},{"name":"internalid"},{"name":"halfrange"},{"name":"domaindiff"}],"output":{"name":"result"}}],[11,"get_order","","Returns the domain of {name} for the given arguments.",86,{"inputs":[{"name":"self"},{"name":"bbid"},{"name":"bbid"}],"output":{"name":"order"}}],[11,"get_old_order","","Returns the domain of {name} for the given arguments. If the domain has been restricted but the change not yet applied, returns the old value.",86,{"inputs":[{"name":"self"},{"name":"bbid"},{"name":"bbid"},{"name":"domaindiff"}],"output":{"name":"order"}}],[11,"set_order","","Sets the domain of {name} for the given arguments.",86,{"inputs":[{"name":"self"},{"name":"bbid"},{"name":"bbid"},{"name":"order"}],"output":null}],[11,"restrict_order","","Restricts the domain of {name} for the given arguments. Put the old value in `diff` and indicates if the new domain is failed.",86,{"inputs":[{"name":"self"},{"name":"bbid"},{"name":"bbid"},{"name":"order"},{"name":"domaindiff"}],"output":{"name":"result"}}],[11,"get_num_thread_dims","","Returns the domain of {name} for the given arguments.",86,{"inputs":[{"name":"self"}],"output":{"name":"halfrange"}}],[11,"get_old_num_thread_dims","","Returns the domain of {name} for the given arguments. If the domain has been restricted but the change not yet applied, returns the old value.",86,{"inputs":[{"name":"self"},{"name":"domaindiff"}],"output":{"name":"halfrange"}}],[11,"set_num_thread_dims","","Sets the domain of {name} for the given arguments.",86,{"inputs":[{"name":"self"},{"name":"halfrange"}],"output":null}],[11,"restrict_num_thread_dims","","Restricts the domain of {name} for the given arguments. Put the old value in `diff` and indicates if the new domain is failed.",86,{"inputs":[{"name":"self"},{"name":"halfrange"},{"name":"domaindiff"}],"output":{"name":"result"}}],[11,"get_is_thread_dim_class_counter","","Returns the domain of {name} for the given arguments.",86,{"inputs":[{"name":"self"},{"name":"id"}],"output":{"name":"range"}}],[11,"get_old_is_thread_dim_class_counter","","Returns the domain of {name} for the given arguments. If the domain has been restricted but the change not yet applied, returns the old value.",86,{"inputs":[{"name":"self"},{"name":"id"},{"name":"domaindiff"}],"output":{"name":"range"}}],[11,"set_is_thread_dim_class_counter","","Sets the domain of {name} for the given arguments.",86,{"inputs":[{"name":"self"},{"name":"id"},{"name":"range"}],"output":null}],[11,"restrict_is_thread_dim_class_counter","","Restricts the domain of {name} for the given arguments. Put the old value in `diff` and indicates if the new domain is failed.",86,{"inputs":[{"name":"self"},{"name":"id"},{"name":"range"},{"name":"domaindiff"}],"output":{"name":"result"}}],[11,"get_dim_kind","","Returns the domain of {name} for the given arguments.",86,{"inputs":[{"name":"self"},{"name":"id"}],"output":{"name":"dimkind"}}],[11,"get_old_dim_kind","","Returns the domain of {name} for the given arguments. If the domain has been restricted but the change not yet applied, returns the old value.",86,{"inputs":[{"name":"self"},{"name":"id"},{"name":"domaindiff"}],"output":{"name":"dimkind"}}],[11,"set_dim_kind","","Sets the domain of {name} for the given arguments.",86,{"inputs":[{"name":"self"},{"name":"id"},{"name":"dimkind"}],"output":null}],[11,"restrict_dim_kind","","Restricts the domain of {name} for the given arguments. Put the old value in `diff` and indicates if the new domain is failed.",86,{"inputs":[{"name":"self"},{"name":"id"},{"name":"dimkind"},{"name":"domaindiff"}],"output":{"name":"result"}}],[11,"get_inst_flag","","Returns the domain of {name} for the given arguments.",86,{"inputs":[{"name":"self"},{"name":"instid"}],"output":{"name":"instflag"}}],[11,"get_old_inst_flag","","Returns the domain of {name} for the given arguments. If the domain has been restricted but the change not yet applied, returns the old value.",86,{"inputs":[{"name":"self"},{"name":"instid"},{"name":"domaindiff"}],"output":{"name":"instflag"}}],[11,"set_inst_flag","","Sets the domain of {name} for the given arguments.",86,{"inputs":[{"name":"self"},{"name":"instid"},{"name":"instflag"}],"output":null}],[11,"restrict_inst_flag","","Restricts the domain of {name} for the given arguments. Put the old value in `diff` and indicates if the new domain is failed.",86,{"inputs":[{"name":"self"},{"name":"instid"},{"name":"instflag"},{"name":"domaindiff"}],"output":{"name":"result"}}],[11,"get_shared_mem_used","","Returns the domain of {name} for the given arguments.",86,{"inputs":[{"name":"self"}],"output":{"name":"halfrange"}}],[11,"get_old_shared_mem_used","","Returns the domain of {name} for the given arguments. If the domain has been restricted but the change not yet applied, returns the old value.",86,{"inputs":[{"name":"self"},{"name":"domaindiff"}],"output":{"name":"halfrange"}}],[11,"set_shared_mem_used","","Sets the domain of {name} for the given arguments.",86,{"inputs":[{"name":"self"},{"name":"halfrange"}],"output":null}],[11,"restrict_shared_mem_used","","Restricts the domain of {name} for the given arguments. Put the old value in `diff` and indicates if the new domain is failed.",86,{"inputs":[{"name":"self"},{"name":"halfrange"},{"name":"domaindiff"}],"output":{"name":"result"}}],[11,"get_is_iteration_dim","","Returns the domain of {name} for the given arguments.",86,{"inputs":[{"name":"self"},{"name":"instid"},{"name":"id"}],"output":{"name":"bool"}}],[11,"get_old_is_iteration_dim","","Returns the domain of {name} for the given arguments. If the domain has been restricted but the change not yet applied, returns the old value.",86,{"inputs":[{"name":"self"},{"name":"instid"},{"name":"id"},{"name":"domaindiff"}],"output":{"name":"bool"}}],[11,"set_is_iteration_dim","","Sets the domain of {name} for the given arguments.",86,{"inputs":[{"name":"self"},{"name":"instid"},{"name":"id"},{"name":"bool"}],"output":null}],[11,"restrict_is_iteration_dim","","Restricts the domain of {name} for the given arguments. Put the old value in `diff` and indicates if the new domain is failed.",86,{"inputs":[{"name":"self"},{"name":"instid"},{"name":"id"},{"name":"bool"},{"name":"domaindiff"}],"output":{"name":"result"}}],[11,"get_is_thread_dim","","Returns the domain of {name} for the given arguments.",86,{"inputs":[{"name":"self"},{"name":"id"}],"output":{"name":"bool"}}],[11,"get_old_is_thread_dim","","Returns the domain of {name} for the given arguments. If the domain has been restricted but the change not yet applied, returns the old value.",86,{"inputs":[{"name":"self"},{"name":"id"},{"name":"domaindiff"}],"output":{"name":"bool"}}],[11,"set_is_thread_dim","","Sets the domain of {name} for the given arguments.",86,{"inputs":[{"name":"self"},{"name":"id"},{"name":"bool"}],"output":null}],[11,"restrict_is_thread_dim","","Restricts the domain of {name} for the given arguments. Put the old value in `diff` and indicates if the new domain is failed.",86,{"inputs":[{"name":"self"},{"name":"id"},{"name":"bool"},{"name":"domaindiff"}],"output":{"name":"result"}}],[11,"get_num_nested_inst","","Returns the domain of {name} for the given arguments.",86,{"inputs":[{"name":"self"},{"name":"id"}],"output":{"name":"halfrange"}}],[11,"get_old_num_nested_inst","","Returns the domain of {name} for the given arguments. If the domain has been restricted but the change not yet applied, returns the old value.",86,{"inputs":[{"name":"self"},{"name":"id"},{"name":"domaindiff"}],"output":{"name":"halfrange"}}],[11,"set_num_nested_inst","","Sets the domain of {name} for the given arguments.",86,{"inputs":[{"name":"self"},{"name":"id"},{"name":"halfrange"}],"output":null}],[11,"restrict_num_nested_inst","","Restricts the domain of {name} for the given arguments. Put the old value in `diff` and indicates if the new domain is failed.",86,{"inputs":[{"name":"self"},{"name":"id"},{"name":"halfrange"},{"name":"domaindiff"}],"output":{"name":"result"}}],[11,"get_mem_space","","Returns the domain of {name} for the given arguments.",86,{"inputs":[{"name":"self"},{"name":"id"}],"output":{"name":"memspace"}}],[11,"get_old_mem_space","","Returns the domain of {name} for the given arguments. If the domain has been restricted but the change not yet applied, returns the old value.",86,{"inputs":[{"name":"self"},{"name":"id"},{"name":"domaindiff"}],"output":{"name":"memspace"}}],[11,"set_mem_space","","Sets the domain of {name} for the given arguments.",86,{"inputs":[{"name":"self"},{"name":"id"},{"name":"memspace"}],"output":null}],[11,"restrict_mem_space","","Restricts the domain of {name} for the given arguments. Put the old value in `diff` and indicates if the new domain is failed.",86,{"inputs":[{"name":"self"},{"name":"id"},{"name":"memspace"},{"name":"domaindiff"}],"output":{"name":"result"}}],[11,"get_unroll_factor","","Returns the domain of {name} for the given arguments.",86,{"inputs":[{"name":"self"},{"name":"instid"}],"output":{"name":"halfrange"}}],[11,"get_old_unroll_factor","","Returns the domain of {name} for the given arguments. If the domain has been restricted but the change not yet applied, returns the old value.",86,{"inputs":[{"name":"self"},{"name":"instid"},{"name":"domaindiff"}],"output":{"name":"halfrange"}}],[11,"set_unroll_factor","","Sets the domain of {name} for the given arguments.",86,{"inputs":[{"name":"self"},{"name":"instid"},{"name":"halfrange"}],"output":null}],[11,"restrict_unroll_factor","","Restricts the domain of {name} for the given arguments. Put the old value in `diff` and indicates if the new domain is failed.",86,{"inputs":[{"name":"self"},{"name":"instid"},{"name":"halfrange"},{"name":"domaindiff"}],"output":{"name":"result"}}],[11,"get_increment_unroll_factor","","Returns the domain of {name} for the given arguments.",86,{"inputs":[{"name":"self"},{"name":"instid"},{"name":"id"}],"output":{"name":"bool"}}],[11,"get_old_increment_unroll_factor","","Returns the domain of {name} for the given arguments. If the domain has been restricted but the change not yet applied, returns the old value.",86,{"inputs":[{"name":"self"},{"name":"instid"},{"name":"id"},{"name":"domaindiff"}],"output":{"name":"bool"}}],[11,"set_increment_unroll_factor","","Sets the domain of {name} for the given arguments.",86,{"inputs":[{"name":"self"},{"name":"instid"},{"name":"id"},{"name":"bool"}],"output":null}],[11,"restrict_increment_unroll_factor","","Restricts the domain of {name} for the given arguments. Put the old value in `diff` and indicates if the new domain is failed.",86,{"inputs":[{"name":"self"},{"name":"instid"},{"name":"id"},{"name":"bool"},{"name":"domaindiff"}],"output":{"name":"result"}}],[11,"get_increment_num_block_dims","","Returns the domain of {name} for the given arguments.",86,{"inputs":[{"name":"self"},{"name":"instid"},{"name":"id"}],"output":{"name":"bool"}}],[11,"get_old_increment_num_block_dims","","Returns the domain of {name} for the given arguments. If the domain has been restricted but the change not yet applied, returns the old value.",86,{"inputs":[{"name":"self"},{"name":"instid"},{"name":"id"},{"name":"domaindiff"}],"output":{"name":"bool"}}],[11,"set_increment_num_block_dims","","Sets the domain of {name} for the given arguments.",86,{"inputs":[{"name":"self"},{"name":"instid"},{"name":"id"},{"name":"bool"}],"output":null}],[11,"restrict_increment_num_block_dims","","Restricts the domain of {name} for the given arguments. Put the old value in `diff` and indicates if the new domain is failed.",86,{"inputs":[{"name":"self"},{"name":"instid"},{"name":"id"},{"name":"bool"},{"name":"domaindiff"}],"output":{"name":"result"}}],[11,"get_dim_mapping","","Returns the domain of {name} for the given arguments.",86,{"inputs":[{"name":"self"},{"name":"id"},{"name":"id"}],"output":{"name":"dimmapping"}}],[11,"get_old_dim_mapping","","Returns the domain of {name} for the given arguments. If the domain has been restricted but the change not yet applied, returns the old value.",86,{"inputs":[{"name":"self"},{"name":"id"},{"name":"id"},{"name":"domaindiff"}],"output":{"name":"dimmapping"}}],[11,"set_dim_mapping","","Sets the domain of {name} for the given arguments.",86,{"inputs":[{"name":"self"},{"name":"id"},{"name":"id"},{"name":"dimmapping"}],"output":null}],[11,"restrict_dim_mapping","","Restricts the domain of {name} for the given arguments. Put the old value in `diff` and indicates if the new domain is failed.",86,{"inputs":[{"name":"self"},{"name":"id"},{"name":"id"},{"name":"dimmapping"},{"name":"domaindiff"}],"output":{"name":"result"}}],[11,"get_is_iteration_dim_class_counter","","Returns the domain of {name} for the given arguments.",86,{"inputs":[{"name":"self"},{"name":"instid"},{"name":"id"}],"output":{"name":"range"}}],[11,"get_old_is_iteration_dim_class_counter","","Returns the domain of {name} for the given arguments. If the domain has been restricted but the change not yet applied, returns the old value.",86,{"inputs":[{"name":"self"},{"name":"instid"},{"name":"id"},{"name":"domaindiff"}],"output":{"name":"range"}}],[11,"set_is_iteration_dim_class_counter","","Sets the domain of {name} for the given arguments.",86,{"inputs":[{"name":"self"},{"name":"instid"},{"name":"id"},{"name":"range"}],"output":null}],[11,"restrict_is_iteration_dim_class_counter","","Restricts the domain of {name} for the given arguments. Put the old value in `diff` and indicates if the new domain is failed.",86,{"inputs":[{"name":"self"},{"name":"instid"},{"name":"id"},{"name":"range"},{"name":"domaindiff"}],"output":{"name":"result"}}],[11,"get_num_threads","","Returns the domain of {name} for the given arguments.",86,{"inputs":[{"name":"self"}],"output":{"name":"halfrange"}}],[11,"get_old_num_threads","","Returns the domain of {name} for the given arguments. If the domain has been restricted but the change not yet applied, returns the old value.",86,{"inputs":[{"name":"self"},{"name":"domaindiff"}],"output":{"name":"halfrange"}}],[11,"set_num_threads","","Sets the domain of {name} for the given arguments.",86,{"inputs":[{"name":"self"},{"name":"halfrange"}],"output":null}],[11,"restrict_num_threads","","Restricts the domain of {name} for the given arguments. Put the old value in `diff` and indicates if the new domain is failed.",86,{"inputs":[{"name":"self"},{"name":"halfrange"},{"name":"domaindiff"}],"output":{"name":"result"}}],[11,"clone","","",87,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"eq","","",87,{"inputs":[{"name":"self"},{"name":"bool"}],"output":{"name":"bool"}}],[11,"ne","","",87,{"inputs":[{"name":"self"},{"name":"bool"}],"output":{"name":"bool"}}],[11,"hash","","",87,null],[18,"FALSE","","",87,null],[18,"TRUE","","",87,null],[18,"ALL","","",87,null],[18,"FAILED","","Returns the empty domain.",87,null],[11,"all","","Returns the full domain.",87,{"inputs":[],"output":{"name":"self"}}],[11,"insert","","Insert values in the domain.",87,{"inputs":[{"name":"self"},{"name":"self"}],"output":null}],[11,"list","","Lists the alternatives contained in the domain.",87,null],[11,"eq","","Indicates if two choices will have the same value.",87,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"bool"}}],[11,"neq","","Indicates if two choices cannot be equal.",87,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"bool"}}],[11,"is_failed","","",87,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_constrained","","",87,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"contains","","",87,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"bool"}}],[11,"intersects","","",87,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"bool"}}],[11,"restrict","","",87,{"inputs":[{"name":"self"},{"name":"self"}],"output":null}],[11,"bitand","","",87,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[11,"bitor","","",87,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[11,"bitxor","","",87,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[11,"not","","",87,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"bitor_assign","","",87,{"inputs":[{"name":"self"},{"name":"self"}],"output":null}],[11,"bitand_assign","","",87,{"inputs":[{"name":"self"},{"name":"self"}],"output":null}],[11,"fmt","","",87,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",88,{"inputs":[{"name":"self"}],"output":{"name":"dimkind"}}],[11,"eq","","",88,{"inputs":[{"name":"self"},{"name":"dimkind"}],"output":{"name":"bool"}}],[11,"ne","","",88,{"inputs":[{"name":"self"},{"name":"dimkind"}],"output":{"name":"bool"}}],[11,"hash","","",88,null],[18,"VECTOR","","The dimension is implemented by using a vector instruction.",88,null],[18,"BLOCK","","The dimension is mapped to a block dimension on the device.",88,null],[18,"THREAD","","The dimension is mapped to a thread dimension on the device.",88,null],[18,"LOOP","","The dimension is implemented as a regular loop.",88,null],[18,"UNROLL","","The dimension is fully unrolled.",88,null],[18,"SEQUENTIAL","","The dimension is sequential.",88,null],[18,"PARALLEL","","The dimension is parallel.",88,null],[18,"ALL","","",88,null],[18,"FAILED","","Returns the empty domain.",88,null],[11,"all","","Returns the full domain.",88,{"inputs":[],"output":{"name":"self"}}],[11,"insert","","Insert values in the domain.",88,{"inputs":[{"name":"self"},{"name":"self"}],"output":null}],[11,"list","","Lists the alternatives contained in the domain.",88,null],[11,"eq","","Indicates if two choices will have the same value.",88,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"bool"}}],[11,"neq","","Indicates if two choices cannot be equal.",88,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"bool"}}],[11,"is_failed","","",88,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_constrained","","",88,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"contains","","",88,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"bool"}}],[11,"intersects","","",88,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"bool"}}],[11,"restrict","","",88,{"inputs":[{"name":"self"},{"name":"self"}],"output":null}],[11,"bitand","","",88,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[11,"bitor","","",88,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[11,"bitxor","","",88,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[11,"not","","",88,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"bitor_assign","","",88,{"inputs":[{"name":"self"},{"name":"self"}],"output":null}],[11,"bitand_assign","","",88,{"inputs":[{"name":"self"},{"name":"self"}],"output":null}],[11,"fmt","","",88,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",89,{"inputs":[{"name":"self"}],"output":{"name":"threadmapping"}}],[11,"eq","","",89,{"inputs":[{"name":"self"},{"name":"threadmapping"}],"output":{"name":"bool"}}],[11,"ne","","",89,{"inputs":[{"name":"self"},{"name":"threadmapping"}],"output":{"name":"bool"}}],[11,"hash","","",89,null],[18,"MAPPED_OUT","","The two dimensions are threads, but `lhs` is mapped to a dimension outside of `rhs`.",89,null],[18,"MAPPED_IN","","The two dimensions are threads, but `lhs` is mapped to a dimension inside of `rhs`.",89,null],[18,"NOT_THREADS","","One of the dimensions is a not thread.",89,null],[18,"MAPPED","","The two dimensions are threads mapped to the same dimension on the GPU.",89,null],[18,"ALL","","",89,null],[18,"FAILED","","Returns the empty domain.",89,null],[11,"all","","Returns the full domain.",89,{"inputs":[],"output":{"name":"self"}}],[11,"insert","","Insert values in the domain.",89,{"inputs":[{"name":"self"},{"name":"self"}],"output":null}],[11,"list","","Lists the alternatives contained in the domain.",89,null],[11,"eq","","Indicates if two choices will have the same value.",89,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"bool"}}],[11,"neq","","Indicates if two choices cannot be equal.",89,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"bool"}}],[11,"inverse","","",89,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"is_failed","","",89,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_constrained","","",89,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"contains","","",89,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"bool"}}],[11,"intersects","","",89,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"bool"}}],[11,"restrict","","",89,{"inputs":[{"name":"self"},{"name":"self"}],"output":null}],[11,"bitand","","",89,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[11,"bitor","","",89,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[11,"bitxor","","",89,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[11,"not","","",89,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"bitor_assign","","",89,{"inputs":[{"name":"self"},{"name":"self"}],"output":null}],[11,"bitand_assign","","",89,{"inputs":[{"name":"self"},{"name":"self"}],"output":null}],[11,"fmt","","",89,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",90,{"inputs":[{"name":"self"}],"output":{"name":"instflag"}}],[11,"eq","","",90,{"inputs":[{"name":"self"},{"name":"instflag"}],"output":{"name":"bool"}}],[11,"ne","","",90,{"inputs":[{"name":"self"},{"name":"instflag"}],"output":{"name":"bool"}}],[11,"hash","","",90,null],[18,"MEM_NC","","Access the global memory using the read-only cache. Coherence is not guaranteed.",90,null],[18,"MEM_SHARED","","Access the shared memory.",90,null],[18,"MEM_CS","","Access the global memory without using caches.",90,null],[18,"MEM_CA","","Access the global memory using both L1 and L2 cache. Coherence is not guaranteed between blocks.",90,null],[18,"MEM_CG","","Access the global memory using the L2 cache.",90,null],[18,"MEM_BLOCK_COHERENT","","Ensure coherency within a block between memory accesses.",90,null],[18,"MEM_COHERENT","","Ensure coherency between memory accesses.",90,null],[18,"MEM_GLOBAL","","Access the global memory.",90,null],[18,"ALL","","",90,null],[18,"FAILED","","Returns the empty domain.",90,null],[11,"all","","Returns the full domain.",90,{"inputs":[],"output":{"name":"self"}}],[11,"insert","","Insert values in the domain.",90,{"inputs":[{"name":"self"},{"name":"self"}],"output":null}],[11,"list","","Lists the alternatives contained in the domain.",90,null],[11,"eq","","Indicates if two choices will have the same value.",90,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"bool"}}],[11,"neq","","Indicates if two choices cannot be equal.",90,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"bool"}}],[11,"is_failed","","",90,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_constrained","","",90,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"contains","","",90,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"bool"}}],[11,"intersects","","",90,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"bool"}}],[11,"restrict","","",90,{"inputs":[{"name":"self"},{"name":"self"}],"output":null}],[11,"bitand","","",90,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[11,"bitor","","",90,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[11,"bitxor","","",90,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[11,"not","","",90,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"bitor_assign","","",90,{"inputs":[{"name":"self"},{"name":"self"}],"output":null}],[11,"bitand_assign","","",90,{"inputs":[{"name":"self"},{"name":"self"}],"output":null}],[11,"fmt","","",90,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",91,{"inputs":[{"name":"self"}],"output":{"name":"memspace"}}],[11,"eq","","",91,{"inputs":[{"name":"self"},{"name":"memspace"}],"output":{"name":"bool"}}],[11,"ne","","",91,{"inputs":[{"name":"self"},{"name":"memspace"}],"output":{"name":"bool"}}],[11,"hash","","",91,null],[18,"GLOBAL","","The block is in the device RAM.",91,null],[18,"SHARED","","The block is in the memory shared between the threads of a block.",91,null],[18,"ALL","","",91,null],[18,"FAILED","","Returns the empty domain.",91,null],[11,"all","","Returns the full domain.",91,{"inputs":[],"output":{"name":"self"}}],[11,"insert","","Insert values in the domain.",91,{"inputs":[{"name":"self"},{"name":"self"}],"output":null}],[11,"list","","Lists the alternatives contained in the domain.",91,null],[11,"eq","","Indicates if two choices will have the same value.",91,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"bool"}}],[11,"neq","","Indicates if two choices cannot be equal.",91,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"bool"}}],[11,"is_failed","","",91,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_constrained","","",91,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"contains","","",91,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"bool"}}],[11,"intersects","","",91,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"bool"}}],[11,"restrict","","",91,{"inputs":[{"name":"self"},{"name":"self"}],"output":null}],[11,"bitand","","",91,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[11,"bitor","","",91,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[11,"bitxor","","",91,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[11,"not","","",91,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"bitor_assign","","",91,{"inputs":[{"name":"self"},{"name":"self"}],"output":null}],[11,"bitand_assign","","",91,{"inputs":[{"name":"self"},{"name":"self"}],"output":null}],[11,"fmt","","",91,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",92,{"inputs":[{"name":"self"}],"output":{"name":"order"}}],[11,"eq","","",92,{"inputs":[{"name":"self"},{"name":"order"}],"output":{"name":"bool"}}],[11,"ne","","",92,{"inputs":[{"name":"self"},{"name":"order"}],"output":{"name":"bool"}}],[11,"hash","","",92,null],[18,"BEFORE","","$lhs is executed before $rhs.",92,null],[18,"AFTER","","$lhs is executed after $rhs.",92,null],[18,"INNER","","$lhs is nested inside $rhs.",92,null],[18,"OUTER","","$rhs is nested outside $rhs.",92,null],[18,"MERGED","","$lhs and $rhs are merged.",92,null],[18,"ORDERED","","$lhs and $rhs are sequentially ordered.",92,null],[18,"NESTED","","$lhs and $rhs are nested.",92,null],[18,"ALL","","",92,null],[18,"FAILED","","Returns the empty domain.",92,null],[11,"all","","Returns the full domain.",92,{"inputs":[],"output":{"name":"self"}}],[11,"insert","","Insert values in the domain.",92,{"inputs":[{"name":"self"},{"name":"self"}],"output":null}],[11,"list","","Lists the alternatives contained in the domain.",92,null],[11,"eq","","Indicates if two choices will have the same value.",92,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"bool"}}],[11,"neq","","Indicates if two choices cannot be equal.",92,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"bool"}}],[11,"inverse","","",92,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"is_failed","","",92,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_constrained","","",92,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"contains","","",92,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"bool"}}],[11,"intersects","","",92,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"bool"}}],[11,"restrict","","",92,{"inputs":[{"name":"self"},{"name":"self"}],"output":null}],[11,"bitand","","",92,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[11,"bitor","","",92,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[11,"bitxor","","",92,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[11,"not","","",92,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"bitor_assign","","",92,{"inputs":[{"name":"self"},{"name":"self"}],"output":null}],[11,"bitand_assign","","",92,{"inputs":[{"name":"self"},{"name":"self"}],"output":null}],[11,"fmt","","",92,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",85,{"inputs":[{"name":"self"},{"name":"action"}],"output":{"name":"bool"}}],[11,"ne","","",85,{"inputs":[{"name":"self"},{"name":"action"}],"output":{"name":"bool"}}],[11,"fmt","","",85,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",85,{"inputs":[{"name":"self"}],"output":{"name":"action"}}],[11,"complement","","Returns the action performing the complementary decision.",85,{"inputs":[{"name":"self"},{"name":"function"}],"output":{"name":"option"}}],[8,"Domain","","",null,null],[10,"is_failed","","Indicates if the domain is empty.",93,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[10,"is_constrained","","Indicates if the domain contains a single alternative.",93,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[10,"contains","","Indicates if the domain contains another.",93,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"bool"}}],[10,"restrict","","Restricts the domain to the intersection with `other`.",93,{"inputs":[{"name":"self"},{"name":"self"}],"output":null}],[11,"intersects","","Indicates if the domain has an alternatve in common with `other`.",93,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"bool"}}],[11,"is","","Indicates if the domain is equal to another domain.",93,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"trivalent"}}],[11,"clone","","",94,{"inputs":[{"name":"self"}],"output":{"name":"searchspace"}}],[11,"new","","Creates a new `SearchSpace` for the given `ir_instance`.",94,{"inputs":[{"name":"function"},{"generics":["action"],"name":"vec"}],"output":{"name":"result"}}],[11,"ir_instance","","Returns the underlying ir instance.",94,{"inputs":[{"name":"self"}],"output":{"name":"function"}}],[11,"domain","","Returns the domain of choices.",94,{"inputs":[{"name":"self"}],"output":{"name":"domainstore"}}],[11,"domain_mut","","Allows rewritting the domain.",94,{"inputs":[{"name":"self"}],"output":{"name":"domainstore"}}],[11,"apply_decisions","","Applies a list of decisions to the domain and propagate constraints.",94,{"inputs":[{"name":"self"},{"generics":["action"],"name":"vec"}],"output":{"name":"result"}}],[11,"lower_layout","","Triggers a layout lowering.",94,{"inputs":[{"name":"self"},{"name":"internalid"},{"generics":["id"],"name":"vec"},{"generics":["id"],"name":"vec"}],"output":{"name":"result"}}],[11,"mul_mode","telamon::codegen","",14,{"inputs":[{"name":"type"},{"name":"type"}],"output":{"name":"mulmode"}}],[11,"lower_type","","",14,{"inputs":[{"name":"type"},{"name":"function"}],"output":{"name":"type"}}],[11,"cfg_vec","","",14,null],[11,"cfg","","Prints a cfg.",14,{"inputs":[{"name":"self"},{"name":"function"},{"name":"cfg"},{"name":"namemap"}],"output":null}],[11,"parallel_induction_level","","Prints a multiplicative induction var level.",14,{"inputs":[{"name":"self"},{"name":"inductionlevel"},{"name":"namemap"}],"output":null}],[11,"enable_threads","","Change the side-effect guards so that only the specified threads are enabled.",14,null],[11,"gen_loop","","Prints a Loop",14,null],[11,"standard_loop","","Prints a classic loop - that is, a sequential loop with an index and a jump to the beginning at the end of the block",14,null],[11,"unroll_loop","","Prints an unroll loop - loop without jumps",14,null],[11,"privatise_global_block","","",14,{"inputs":[{"name":"self"},{"name":"internalmemblock"},{"name":"namemap"},{"name":"function"}],"output":null}],[11,"inst","","Prints an instruction.",14,{"inputs":[{"name":"self"},{"name":"instruction"},{"name":"namemap"},{"name":"function"}],"output":null}],[11,"get","telamon::ir","",62,{"inputs":[{"name":"self"},{"name":"function"},{"name":"hashmap"}],"output":{"name":"operand"}}],[11,"get","","",53,{"inputs":[{"name":"self"},{"name":"function"},{"name":"hashmap"}],"output":{"name":"operand"}}],[11,"get","telamon::ir::mem","",73,{"inputs":[{"name":"self"},{"name":"function"},{"name":"hashmap"}],"output":{"name":"operand"}}],[11,"get","telamon::ir::dim","",79,{"inputs":[{"name":"self"},{"name":"function"},{"name":"hashmap"}],"output":{"name":"operand"}}],[11,"get","telamon::ir","",54,{"inputs":[{"name":"self"},{"name":"function"},{"name":"hashmap"}],"output":{"name":"operand"}}],[11,"ids","telamon::ir::dim","",79,{"inputs":[{"name":"self"}],"output":{"generics":["doubleendediterator"],"name":"box"}}],[11,"ids","telamon::ir","",59,{"inputs":[{"name":"self"}],"output":{"generics":["iterator"],"name":"box"}}],[11,"ids","","",53,{"inputs":[{"name":"self"}],"output":{"generics":["iterator"],"name":"box"}}],[11,"as_size","telamon::device","Returns the argument interpreted as an iteration dimension size, if applicable.",38,{"inputs":[{"name":"self"}],"output":{"generics":["u32"],"name":"option"}}],[11,"eval_size","","Evaluate a size.",40,{"inputs":[{"name":"self"},{"name":"size"}],"output":{"name":"u32"}}],[11,"as_inst","telamon::ir::prelude","Returns 'self' if it is an instruction.",81,{"inputs":[{"name":"self"}],"output":{"generics":["instruction"],"name":"option"}}],[11,"as_dim","","Returns 'self' if it is a dimension",81,{"inputs":[{"name":"self"}],"output":{"generics":["dimension"],"name":"option"}}],[11,"clone","telamon::ir::dim","",79,{"inputs":[{"name":"self"}],"output":{"name":"id"}}],[11,"eq","","",79,{"inputs":[{"name":"self"},{"name":"id"}],"output":{"name":"bool"}}],[11,"ne","","",79,{"inputs":[{"name":"self"},{"name":"id"}],"output":{"name":"bool"}}],[11,"hash","","",79,null],[11,"partial_cmp","","",79,{"inputs":[{"name":"self"},{"name":"id"}],"output":{"generics":["ordering"],"name":"option"}}],[11,"lt","","",79,{"inputs":[{"name":"self"},{"name":"id"}],"output":{"name":"bool"}}],[11,"le","","",79,{"inputs":[{"name":"self"},{"name":"id"}],"output":{"name":"bool"}}],[11,"gt","","",79,{"inputs":[{"name":"self"},{"name":"id"}],"output":{"name":"bool"}}],[11,"ge","","",79,{"inputs":[{"name":"self"},{"name":"id"}],"output":{"name":"bool"}}],[11,"cmp","","",79,{"inputs":[{"name":"self"},{"name":"id"}],"output":{"name":"ordering"}}],[11,"fmt","","",79,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",79,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","telamon::ir::op","",80,{"inputs":[{"name":"self"}],"output":{"name":"rounding"}}],[11,"eq","","",80,{"inputs":[{"name":"self"},{"name":"rounding"}],"output":{"name":"bool"}}],[11,"fmt","","",80,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",80,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","telamon::model","",95,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"intersects","telamon::search_space","Indicates if the domain has an alternatve in common with `other`.",93,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"bool"}}],[11,"is","","Indicates if the domain is equal to another domain.",93,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"trivalent"}}]],"paths":[[3,"InductionLevel"],[3,"InductionVar"],[4,"Cfg"],[4,"ParamVal"],[4,"ParamValKey"],[4,"AllocationScheme"],[4,"Value"],[4,"MulMode"],[3,"Dimension"],[3,"Function"],[3,"InternalMemBlock"],[3,"Instruction"],[3,"NameMap"],[8,"Namer"],[8,"Printer"],[3,"Reduce"],[3,"TmpArray"],[3,"Builder"],[3,"SignatureBuilder"],[3,"DimSize"],[3,"TensorBuilder"],[3,"Tensor"],[3,"VirtualTensor"],[8,"AutoOperand"],[8,"MetaDimension"],[8,"MetaBasicBlock"],[3,"DimGroup"],[4,"EvalMode"],[3,"Gpu"],[3,"InstDesc"],[3,"Array"],[4,"Executor"],[3,"Context"],[3,"Kernel"],[3,"CudaPrinter"],[3,"Cpu"],[3,"Context"],[3,"X86printer"],[8,"ScalarArgument"],[8,"ArrayArgument"],[8,"Context"],[8,"ArgMap"],[8,"AsyncEvaluator"],[8,"Device"],[3,"Candidate"],[3,"Config"],[3,"BanditConfig"],[4,"SearchAlgorithm"],[4,"NewNodeOrder"],[4,"OldNodeOrder"],[4,"ActionEx"],[3,"Signature"],[3,"Parameter"],[3,"InstId"],[3,"IndVarId"],[3,"NewObjs"],[3,"LoweredDimMap"],[4,"Stride"],[4,"AccessPattern"],[4,"BBId"],[4,"Error"],[4,"TypeError"],[4,"Operand"],[4,"DimMapScope"],[4,"BinOp"],[4,"Operator"],[4,"Type"],[3,"Dimension"],[3,"DimMap"],[3,"Function"],[3,"InductionVar"],[3,"Instruction"],[3,"Size"],[3,"InternalId"],[4,"Id"],[8,"Block"],[3,"InternalBlock"],[3,"ExternalBlock"],[3,"BlockMap"],[3,"Id"],[4,"Rounding"],[8,"BasicBlock"],[3,"Nesting"],[4,"BottleneckLevel"],[3,"HwPressure"],[4,"Action"],[3,"DomainStore"],[3,"Bool"],[3,"DimKind"],[3,"ThreadMapping"],[3,"InstFlag"],[3,"MemSpace"],[3,"Order"],[8,"Domain"],[3,"SearchSpace"],[6,"Bound"]]};
searchIndex["telamon_capi"] = {"doc":"C API wrappers for calling Telamon through FFI.","items":[[0,"linalg","telamon_capi","Linera algebra kernels.",null,null],[3,"Axpy","telamon_capi::linalg","Computes `z = alpha*x+y`.",null,null],[3,"MatVec","","Computes `y = A.x`.",null,null],[3,"Gesummv","","Computes `y = (alpha*A + beta*B).x`.",null,null],[3,"MatMul","","Computes `C = A.B`.",null,null],[12,"params","","",0,null],[3,"MatMulP","","",null,null],[12,"m","","",1,null],[12,"n","","",1,null],[12,"k","","",1,null],[12,"a_stride","","",1,null],[12,"transpose_a","","",1,null],[12,"transpose_b","","",1,null],[12,"generic","","",1,null],[12,"m_tiling","","",1,null],[12,"n_tiling","","",1,null],[12,"k_tiling","","",1,null],[3,"BatchMM","","Batch transposed matrix-matrix multiplication.",null,null],[3,"BatchMMP","","",null,null],[12,"m","","",2,null],[12,"n","","",2,null],[12,"k","","",2,null],[12,"batch","","",2,null],[12,"transpose_a","","",2,null],[12,"transpose_b","","",2,null],[12,"batch_b","","",2,null],[12,"generic","","",2,null],[8,"Kernel","telamon_capi","A kernel that can be compiled, benchmarked and used for correctness tests.",null,null],[16,"Parameters","","The input parameters of the kernel.",3,null],[16,"ExpectedOutput","","The values to expect as output.",3,null],[10,"name","","The name of the function computed by the kernel.",3,{"inputs":[],"output":{"name":"str"}}],[10,"build_signature","","Builds the signature of the kernel in the builder and returns an object that stores enough information to later build the kernel body and check its result. The `is_generic` flag indicates if th sizes should be instantiated.",3,null],[10,"build_body","","Builder the kernel body in the given builder. This builder should be based on the signature created by `build_signature`.",3,{"inputs":[{"name":"self"},{"name":"signature"},{"name":"context"}],"output":{"generics":["candidate"],"name":"vec"}}],[10,"get_expected_output","","Computes the expected output.",3,null],[10,"check_result","","Ensures the generated code performs the correct operation.",3,null],[11,"test_correctness","","Generates, executes and tests the output of candidates for the kernel.",3,null],[11,"test_bound","","Tests the correctness of the bound of kernels and returns the list of tested leafs along with the actual evaluation time.",3,null],[11,"benchmark","","Runs the search and benchmarks the resulting candidate.",3,null],[11,"deadend_ratio","","Computes the probability of encountering a dead-end when descending in the search tree.",3,null],[3,"Tiling","","",null,null],[4,"Device","","Supported device types for running kernels.",null,null],[13,"X86","","",4,null],[13,"Cuda","","",4,null],[4,"KernelParameters","","Supported kernels.",null,null],[13,"MatMul","","A matrix-matrix multiplication kernel.",5,null],[5,"env_logger_try_init","","Initializes the logger.",null,{"inputs":[],"output":null}],[5,"kernel_matmul_new","","Instanciate a new kernel for matrix-matrix multiplication. The caller is responsible for deallocating the returned pointer using kernel_free.",null,null],[5,"kernel_free","","Deallocates kernel parameters created through one of the `kernel_*_new` functions. The `params` pointer becomes invalid and must not be used again after calling `kernel_free`.",null,null],[5,"kernel_optimize","","Optimize a kernel on a given device. `config_data` points to a JSON-encoded string of length `config_len` containing the configuration parameters for the explorer.",null,null],[11,"clone","","",5,{"inputs":[{"name":"self"}],"output":{"name":"kernelparameters"}}],[11,"name","telamon_capi::linalg","",6,{"inputs":[],"output":{"name":"str"}}],[11,"build_signature","","",6,null],[11,"build_body","","",6,{"inputs":[{"name":"self"},{"name":"signature"},{"name":"context"}],"output":{"generics":["candidate"],"name":"vec"}}],[11,"get_expected_output","","",6,{"inputs":[{"name":"self"},{"name":"context"}],"output":{"generics":["ownedrepr","dim"],"name":"arraybase"}}],[11,"check_result","","",6,null],[11,"name","","",0,{"inputs":[],"output":{"name":"str"}}],[11,"build_signature","","",0,{"inputs":[{"name":"matmulp"},{"name":"builder"}],"output":{"name":"matmul"}}],[11,"build_body","","",0,{"inputs":[{"name":"self"},{"name":"signature"},{"name":"context"}],"output":{"generics":["candidate"],"name":"vec"}}],[11,"get_expected_output","","",0,{"inputs":[{"name":"self"},{"name":"context"}],"output":{"generics":["ownedrepr","dim"],"name":"arraybase"}}],[11,"check_result","","",0,null],[11,"name","","",7,{"inputs":[],"output":{"name":"str"}}],[11,"build_signature","","",7,null],[11,"build_body","","",7,{"inputs":[{"name":"self"},{"name":"signature"},{"name":"context"}],"output":{"generics":["candidate"],"name":"vec"}}],[11,"get_expected_output","","",7,{"inputs":[{"name":"self"},{"name":"context"}],"output":{"generics":["ownedrepr","dim"],"name":"arraybase"}}],[11,"check_result","","",7,null],[11,"name","","",8,{"inputs":[],"output":{"name":"str"}}],[11,"build_signature","","",8,{"inputs":[{"name":"batchmmp"},{"name":"builder"}],"output":{"name":"batchmm"}}],[11,"build_body","","",8,{"inputs":[{"name":"self"},{"name":"signature"},{"name":"context"}],"output":{"generics":["candidate"],"name":"vec"}}],[11,"get_expected_output","","",8,{"inputs":[{"name":"self"},{"name":"context"}],"output":{"generics":["ownedrepr","dim"],"name":"arraybase"}}],[11,"check_result","","",8,null],[11,"name","","",9,{"inputs":[],"output":{"name":"str"}}],[11,"build_signature","","",9,null],[11,"build_body","","",9,{"inputs":[{"name":"self"},{"name":"signature"},{"name":"context"}],"output":{"generics":["candidate"],"name":"vec"}}],[11,"get_expected_output","","",9,{"inputs":[{"name":"self"},{"name":"context"}],"output":{"generics":["ownedrepr","dim"],"name":"arraybase"}}],[11,"check_result","","",9,null],[11,"clone","","",1,{"inputs":[{"name":"self"}],"output":{"name":"matmulp"}}],[11,"clone","","",2,{"inputs":[{"name":"self"}],"output":{"name":"batchmmp"}}],[11,"new","","",1,{"inputs":[{"name":"i32"},{"name":"i32"},{"name":"i32"}],"output":{"name":"matmulp"}}],[11,"transpose_a","","",1,{"inputs":[{"name":"self"}],"output":{"name":"matmulp"}}],[11,"transpose_b","","",1,{"inputs":[{"name":"self"}],"output":{"name":"matmulp"}}],[11,"stride_a","","",1,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"matmulp"}}],[11,"static_sizes","","Inline the sizes in the generated code.",1,{"inputs":[{"name":"self"}],"output":{"name":"matmulp"}}],[11,"new","","",2,{"inputs":[{"name":"i32"},{"name":"i32"},{"name":"i32"},{"name":"i32"}],"output":{"name":"batchmmp"}}],[11,"transpose_a","","",2,{"inputs":[{"name":"self"}],"output":{"name":"batchmmp"}}],[11,"transpose_b","","",2,{"inputs":[{"name":"self"}],"output":{"name":"batchmmp"}}],[11,"static_sizes","","Generate code that is onyl valid for the given sizes. The batch size is still generic.",2,{"inputs":[{"name":"self"}],"output":{"name":"batchmmp"}}],[11,"reuse_b","","Reuse the `B` matrix across the batch.",2,{"inputs":[{"name":"self"}],"output":{"name":"batchmmp"}}]],"paths":[[3,"MatMul"],[3,"MatMulP"],[3,"BatchMMP"],[8,"Kernel"],[4,"Device"],[4,"KernelParameters"],[3,"Axpy"],[3,"Gesummv"],[3,"BatchMM"],[3,"MatVec"]]};
searchIndex["telamon_gen"] = {"doc":"","items":[[5,"process_file","telamon_gen","Process a file and stores the result in an other file.",null,{"inputs":[{"name":"path"},{"name":"path"},{"name":"bool"}],"output":{"generics":["processerror"],"name":"result"}}],[5,"process","","Parses a constraint description file.",null,{"inputs":[{"name":"read"},{"name":"t"},{"name":"bool"},{"name":"path"}],"output":{"generics":["processerror"],"name":"result"}}],[0,"ast","","Syntaxic tree for the constraint description.",null,null],[3,"SetDef","telamon_gen::ast","",null,null],[12,"name","","",0,null],[12,"doc","","",0,null],[12,"arg","","",0,null],[12,"superset","","",0,null],[12,"disjoint","","",0,null],[12,"keys","","",0,null],[12,"quotient","","",0,null],[3,"IntegerDef","","A toplevel integer",null,null],[12,"name","","",1,null],[12,"doc","","",1,null],[12,"variables","","",1,null],[12,"code","","",1,null],[3,"EnumDef","","A toplevel definition or constraint.",null,null],[12,"name","","",2,null],[12,"doc","","",2,null],[12,"variables","","",2,null],[12,"statements","","",2,null],[3,"Constraint","","A constraint that must be enforced by the IR.",null,null],[12,"forall_vars","","Variables for which the conditions must be respected.",3,null],[12,"disjunctions","","Conjunction of disjuction of condition that must be respected.",3,null],[12,"restrict_fragile","","Indicates if the constraint should restrict fragile values.",3,null],[3,"Position","","A sequence's row/column position",null,null],[12,"line","","",4,null],[12,"column","","",4,null],[3,"Spanned","","A F/lex's token with a span.",null,null],[12,"beg","","",5,null],[12,"end","","",5,null],[12,"data","","Spanned data",5,null],[3,"Ast","","",null,null],[12,"statements","","",6,null],[3,"Quotient","","",null,null],[12,"item","","",7,null],[12,"representant","","",7,null],[12,"conditions","","",7,null],[12,"equiv_relation","","",7,null],[3,"CounterBody","","",null,null],[12,"base","","",8,null],[12,"kind","","",8,null],[12,"iter_vars","","",8,null],[12,"value","","",8,null],[12,"conditions","","",8,null],[3,"SetRef","","References a set.",null,null],[12,"name","","",9,null],[12,"var","","",9,null],[3,"VarDef","","Defines a variable.",null,null],[12,"name","","",10,null],[12,"set","","",10,null],[3,"ChoiceInstance","","A reference to a choice instantiated with the given variables.",null,null],[12,"name","","",11,null],[12,"vars","","",11,null],[3,"CounterDef","","",null,null],[12,"name","","",12,null],[12,"doc","","",12,null],[12,"visibility","","",12,null],[12,"vars","","",12,null],[12,"body","","",12,null],[4,"ChoiceDef","","",null,null],[13,"CounterDef","","",13,null],[13,"EnumDef","","",13,null],[13,"IntegerDef","","",13,null],[4,"Hint","","Hint is a token representation.",null,null],[13,"Set","","Set interface.",14,null],[13,"SetAttribute","","Set attribute.",14,null],[13,"Enum","","Enum interface.",14,null],[13,"EnumAttribute","","Enum attribute.",14,null],[13,"Integer","","Integer interface.",14,null],[13,"IntegerAttribute","","Integer attribute.",14,null],[4,"TypeError","","TypeEror is the error representation of telamon's.",null,null],[13,"Redefinition","","Redefinition of a name and hint..",15,null],[13,"Undefined","","Undefinition of set, enum or field.",15,null],[13,"BadSymmetricArg","","Unvalid arguments of a symmetric enum.",15,null],[13,"MissingEntry","","Missing",15,null],[4,"Statement","","A toplevel definition or constraint.",null,null],[13,"ChoiceDef","","",16,null],[13,"TriggerDef","","",16,null],[12,"foralls","telamon_gen::ast::Statement","",16,null],[12,"conditions","","",16,null],[12,"code","","",16,null],[13,"SetDef","telamon_gen::ast","",16,null],[13,"Require","","",16,null],[4,"Symmetry","","Indicates if an enum exhibits symmetry.",null,null],[13,"Symmetric","","",17,null],[13,"AntiSymmetric","","",17,null],[4,"Condition","","One of the condition that has to be respected by a constraint.",null,null],[13,"Is","","",18,null],[12,"lhs","telamon_gen::ast::Condition","",18,null],[12,"rhs","","",18,null],[12,"is","","",18,null],[13,"Code","telamon_gen::ast","",18,null],[13,"Bool","","",18,null],[13,"CmpCode","","",18,null],[12,"lhs","telamon_gen::ast::Condition","",18,null],[12,"rhs","","",18,null],[12,"op","","",18,null],[13,"CmpInput","telamon_gen::ast","",18,null],[12,"lhs","telamon_gen::ast::Condition","",18,null],[12,"rhs","","",18,null],[12,"op","","",18,null],[4,"CounterVal","telamon_gen::ast","The value of a counter increment.",null,null],[13,"Code","","",19,null],[13,"Choice","","",19,null],[4,"EnumStatement","","A statement in an enum definition.",null,null],[13,"Value","","Defines a possible decision for th enum.",20,null],[13,"Alias","","Defines a set of possible decisions for the enum.",20,null],[13,"Symmetric","","Specifies that the enum is symmetric.",20,null],[13,"AntiSymmetric","","Specifies that the enum is antisymmetric and given the inverse function.",20,null],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"setdef"}}],[11,"type_check","","Type checks the condition.",0,{"inputs":[{"name":"self"}],"output":{"generics":["typeerror"],"name":"result"}}],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"bool"}}],[11,"clone","","",2,{"inputs":[{"name":"self"}],"output":{"name":"enumdef"}}],[11,"fmt","","",2,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"type_check","","Type checks the condition.",2,{"inputs":[{"name":"self"}],"output":{"generics":["typeerror"],"name":"result"}}],[11,"eq","","",2,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"bool"}}],[11,"clone","","",1,{"inputs":[{"name":"self"}],"output":{"name":"integerdef"}}],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"type_check","","",1,{"inputs":[{"name":"self"}],"output":{"generics":["typeerror"],"name":"result"}}],[11,"eq","","",1,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"bool"}}],[11,"clone","","",13,{"inputs":[{"name":"self"}],"output":{"name":"choicedef"}}],[11,"fmt","","",13,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",13,{"inputs":[{"name":"self"},{"name":"choicedef"}],"output":{"name":"bool"}}],[11,"ne","","",13,{"inputs":[{"name":"self"},{"name":"choicedef"}],"output":{"name":"bool"}}],[11,"type_check","","",13,{"inputs":[{"name":"self"}],"output":{"generics":["typeerror"],"name":"result"}}],[11,"from","","",13,{"inputs":[{"name":"statement"}],"output":{"name":"self"}}],[11,"fmt","","",3,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",3,{"inputs":[{"name":"self"}],"output":{"name":"constraint"}}],[11,"new","","Creates a new constraint.",3,{"inputs":[{"generics":["vardef"],"name":"vec"},{"generics":["vec"],"name":"vec"}],"output":{"name":"self"}}],[11,"type_check","","Type check the constraint.",3,{"inputs":[{"name":"self"},{"name":"irdesc"}],"output":{"generics":["typedconstraint"],"name":"vec"}}],[11,"fmt","","",14,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",14,{"inputs":[{"name":"self"}],"output":{"name":"hint"}}],[11,"eq","","",14,{"inputs":[{"name":"self"},{"name":"hint"}],"output":{"name":"bool"}}],[11,"fmt","","",15,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",15,{"inputs":[{"name":"self"},{"name":"typeerror"}],"output":{"name":"bool"}}],[11,"ne","","",15,{"inputs":[{"name":"self"},{"name":"typeerror"}],"output":{"name":"bool"}}],[11,"fmt","","",6,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"type_check","","Generate the defintion of choices and the list of constraints.",6,{"inputs":[{"name":"self"}],"output":{"generics":["typeerror"],"name":"result"}}],[11,"fmt","","",16,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"type_check","","",16,{"inputs":[{"name":"self"}],"output":{"generics":["typeerror"],"name":"result"}}],[11,"clone","","",7,{"inputs":[{"name":"self"}],"output":{"name":"quotient"}}],[11,"fmt","","",7,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",8,{"inputs":[{"name":"self"}],"output":{"name":"counterbody"}}],[11,"fmt","","",8,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",17,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",9,{"inputs":[{"name":"self"}],"output":{"name":"setref"}}],[11,"fmt","","",9,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",9,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"bool"}}],[11,"fmt","","",10,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",10,{"inputs":[{"name":"self"}],"output":{"name":"vardef"}}],[11,"eq","","",10,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"bool"}}],[11,"fmt","","",18,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",18,{"inputs":[{"name":"self"}],"output":{"name":"condition"}}],[11,"fmt","","",11,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",11,{"inputs":[{"name":"self"}],"output":{"name":"choiceinstance"}}],[11,"clone","","",19,{"inputs":[{"name":"self"}],"output":{"name":"counterval"}}],[11,"fmt","","",19,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",20,{"inputs":[{"name":"self"}],"output":{"name":"enumstatement"}}],[11,"fmt","","",20,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",20,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",20,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"bool"}}],[11,"clone","","",12,{"inputs":[{"name":"self"}],"output":{"name":"counterdef"}}],[11,"fmt","","",12,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",12,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"bool"}}],[0,"ir","telamon_gen","The constraint description for the ir.",null,null],[3,"Choice","telamon_gen::ir","A decision to specify.",null,null],[3,"FilterCall","","A call to a filter.",null,null],[12,"forall_vars","","",21,null],[12,"filter_ref","","",21,null],[3,"OnChangeAction","","An action to perform when the choice is restricted.",null,null],[12,"forall_vars","","",22,null],[12,"set_constraints","","",22,null],[12,"action","","",22,null],[3,"ChoiceCondition","","A condition from the point of view of a choice.",null,null],[12,"inputs","","",23,null],[12,"self_condition","","",23,null],[12,"others_conditions","","",23,null],[3,"FilterAction","","Restricts the set of valid values.",null,null],[12,"set_constraints","","",24,null],[12,"filter","","",24,null],[3,"Filter","","Filters the set valid values.",null,null],[12,"arguments","","The variables on which the filter depends.",25,null],[12,"inputs","","The choices that the filter depends on.",25,null],[12,"rules","","The filter rules.",25,null],[3,"Rule","","Specifies a conditional restriction on the set of valid values.",null,null],[12,"conditions","","The conditions that must be true for the rule to trigger.",26,null],[12,"alternatives","","The values allowed for the enum if the rule is triggered.",26,null],[12,"set_constraints","","The condition on subsets for the rule to apply.",26,null],[3,"SetConstraints","","A list of constraints on the set each variable belongs to. It must be built using `SetConstraints::new` so the constraints are in the right order.",null,null],[3,"ChoiceInstance","","An choice instantiated with the given variables.",null,null],[12,"choice","","",27,null],[12,"vars","","",27,null],[3,"Code","","A piece of rust code.",null,null],[12,"code","","",28,null],[12,"vars","","",28,null],[3,"Set","","References a set of objects.",null,null],[3,"SetRefImpl","","",null,null],[3,"SetDef","","Defines a set of objects.",null,null],[3,"Adaptator","","Represent a transformation to apply to a rule to fir it in a new context.",null,null],[3,"IrDesc","","Describes the choices that constitute the IR.",null,null],[3,"Enum","","A choice that can take a few predefined values.",null,null],[3,"Trigger","","A piece of host code called when a list of conditions are met.",null,null],[12,"foralls","","",29,null],[12,"inputs","","",29,null],[12,"conditions","","",29,null],[12,"code","","",29,null],[4,"ChoiceArguments","","Defines the parameters for which the `Choice` is defined.",null,null],[13,"Plain","","The `Choice` is defined for all comibnation of variables of the given sets Each variable can only appear once.",30,null],[12,"vars","telamon_gen::ir::ChoiceArguments","",30,null],[13,"Symmetric","telamon_gen::ir","The `Choice` is defined on a triangular space. The rests is obtained by symmetry.",30,null],[12,"names","telamon_gen::ir::ChoiceArguments","",30,null],[12,"t","","",30,null],[12,"inverse","","",30,null],[4,"ChoiceDef","telamon_gen::ir","Specifies how the `Choice` is defined.",null,null],[13,"Enum","","The `Choice` can take a small set of predefined values.",31,null],[13,"Counter","","An integer abstracted by an interval.",31,null],[12,"kind","telamon_gen::ir::ChoiceDef","",31,null],[12,"value","","",31,null],[12,"incr_iter","","",31,null],[12,"incr","","",31,null],[12,"incr_condition","","",31,null],[12,"visibility","","",31,null],[12,"base","","",31,null],[13,"Number","telamon_gen::ir","The `Choice` can take a small set of dynamically defined numeric values.",31,null],[12,"universe","telamon_gen::ir::ChoiceDef","",31,null],[4,"CounterVisibility","telamon_gen::ir","Indicates how a counter exposes how its maximum value. The variants are ordered by increasing amount of information available.",null,null],[13,"NoMax","","Only the minimal value is computed and stored.",32,null],[13,"HiddenMax","","Both the min and max are stored, but only the min is exposed.",32,null],[13,"Full","","Both the min and the max value are exposed.",32,null],[4,"CounterVal","","The value of the increments of a counter.",null,null],[13,"Code","","",33,null],[13,"Choice","","",33,null],[4,"ValueType","","Specifies the type of the values a choice can take.",null,null],[13,"Enum","","",34,null],[13,"Range","","",34,null],[13,"HalfRange","","",34,null],[13,"NumericSet","","",34,null],[4,"FilterRef","","References a filter to call.",null,null],[13,"Inline","","",35,null],[13,"Local","","",35,null],[12,"id","telamon_gen::ir::FilterRef","",35,null],[12,"args","","",35,null],[13,"Remote","telamon_gen::ir","",35,null],[12,"choice","telamon_gen::ir::FilterRef","",35,null],[12,"id","","",35,null],[12,"args","","",35,null],[4,"ChoiceAction","telamon_gen::ir","An action to perform,",null,null],[13,"FilterSelf","","The choice runs all its filters on itself.",36,null],[13,"Filter","","The choice runs a filter on another choice.",36,null],[12,"choice","telamon_gen::ir::ChoiceAction","",36,null],[12,"filter","","",36,null],[13,"IncrCounter","telamon_gen::ir","Increments a counter if the increment condition is statisfied.",36,null],[12,"counter","telamon_gen::ir::ChoiceAction","",36,null],[12,"value","","",36,null],[12,"incr_condition","","",36,null],[13,"UpdateCounter","telamon_gen::ir","Update a counter after the increment value is changed.",36,null],[12,"counter","telamon_gen::ir::ChoiceAction","",36,null],[12,"incr","","",36,null],[12,"incr_condition","","",36,null],[13,"Trigger","telamon_gen::ir","Triggers a lowering.",36,null],[12,"id","telamon_gen::ir::ChoiceAction","",36,null],[12,"condition","","",36,null],[12,"code","","",36,null],[12,"inverse_self_cond","","",36,null],[4,"SubFilter","telamon_gen::ir","Filters the set of valid values, given some inputs.",null,null],[13,"Switch","","Enumerate the possible values that a input can take, and lists the possible values for each.",37,null],[12,"switch","telamon_gen::ir::SubFilter","",37,null],[12,"cases","","",37,null],[13,"Rules","telamon_gen::ir","Applies a set of negative rules to filter the possible values.",37,null],[4,"Variable","","",null,null],[13,"Arg","","",38,null],[13,"Forall","","",38,null],[4,"Condition","","A condition producing a boolean.",null,null],[13,"Code","","Triggers if the given piece of code returns `true`, given the mapping of variables.",39,null],[12,"code","telamon_gen::ir::Condition","",39,null],[12,"negate","","",39,null],[13,"Enum","telamon_gen::ir","Triggers if the choice can only take the given values.",39,null],[12,"input","telamon_gen::ir::Condition","",39,null],[12,"values","","",39,null],[12,"negate","","",39,null],[12,"inverse","","",39,null],[13,"Bool","telamon_gen::ir","Always or never triggers.",39,null],[13,"CmpCode","","Triggers if the one inputs respects the comparison operator with some rust code.",39,null],[12,"lhs","telamon_gen::ir::Condition","",39,null],[12,"rhs","","",39,null],[12,"op","","",39,null],[13,"CmpInput","telamon_gen::ir","Triggers if the two inputs respects the comparison operator.",39,null],[12,"lhs","telamon_gen::ir::Condition","",39,null],[12,"rhs","","",39,null],[12,"op","","",39,null],[12,"inverse","","",39,null],[4,"CmpOp","telamon_gen::ir","A compariason operator.",null,null],[13,"Lt","","",40,null],[13,"Gt","","",40,null],[13,"Leq","","",40,null],[13,"Geq","","",40,null],[13,"Eq","","",40,null],[13,"Neq","","",40,null],[4,"ValueSet","","Represents a set of values a choice can take.",null,null],[13,"Enum","","",41,null],[12,"enum_name","telamon_gen::ir::ValueSet","The enum type.",41,null],[12,"values","","A fixed set of values. Does not contains aliases.",41,null],[12,"inputs","","A set of inputs whose values can be take by the choice. Two flags indicate if the value should be negated or inversed.",41,null],[13,"Integer","telamon_gen::ir","",41,null],[12,"is_full","telamon_gen::ir::ValueSet","",41,null],[12,"cmp_inputs","","",41,null],[12,"cmp_code","","",41,null],[12,"universe","","",41,null],[4,"SetDefKey","telamon_gen::ir","",null,null],[13,"ItemType","","",42,null],[13,"IdType","","",42,null],[13,"ItemGetter","","",42,null],[13,"IdGetter","","",42,null],[13,"Iter","","",42,null],[13,"FromSuperset","","",42,null],[13,"Prefix","","",42,null],[13,"NewObjs","","",42,null],[13,"Reverse","","",42,null],[13,"AddToSet","","",42,null],[4,"CounterKind","","Indicates whether a counter sums or adds.",null,null],[13,"Add","","",43,null],[13,"Mul","","",43,null],[5,"dummy_choice","","",null,{"inputs":[],"output":{"name":"choice"}}],[5,"normalized_enum_set","","Creates a `ValueSet` from the list of enum values.",null,{"inputs":[{"name":"it"},{"name":"bool"},{"name":"bool"},{"name":"enum"}],"output":{"name":"valueset"}}],[11,"default","","",44,{"inputs":[],"output":{"name":"adaptator"}}],[11,"from_arguments","","Creates an adaptator that maps the arguments to the given names.",44,null],[11,"variable","","Adapts a variable.",44,{"inputs":[{"name":"self"},{"name":"variable"}],"output":{"name":"variable"}}],[11,"input","","Returns the new ID of an input and indicates if it is inversed.",44,null],[11,"set_variable","","Sets the mapping of a variable. Returns the previous mapping.",44,{"inputs":[{"name":"self"},{"name":"variable"},{"name":"variable"}],"output":{"generics":["variable"],"name":"option"}}],[11,"set_input","","Sets the mapping of an input.",44,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"usize"}],"output":null}],[11,"set_inversed","","Sets an input as inversed.",44,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[11,"fmt","","",45,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Creates a new `Choice`.",45,{"inputs":[{"name":"rcstr"},{"generics":["rcstr"],"name":"option"},{"name":"choicearguments"},{"name":"choicedef"}],"output":{"name":"self"}}],[11,"name","","Returns the name of the choice, in snake_case.",45,{"inputs":[{"name":"self"}],"output":{"name":"rcstr"}}],[11,"doc","","Returns the documentation associated with the `Choice`.",45,{"inputs":[{"name":"self"}],"output":{"generics":["str"],"name":"option"}}],[11,"arguments","","Returns the parameters for which the `Choice` is defined.",45,{"inputs":[{"name":"self"}],"output":{"name":"choicearguments"}}],[11,"value_type","","Returns the type representing the values the `Choice` can take.",45,{"inputs":[{"name":"self"}],"output":{"name":"valuetype"}}],[11,"choice_def","","Returns the definition of the `Choice.",45,{"inputs":[{"name":"self"}],"output":{"name":"choicedef"}}],[11,"on_change","","Returns the actions to perform when the `Choice` is constrained.",45,{"inputs":[{"name":"self"}],"output":{"generics":["onchangeaction"],"name":"iter"}}],[11,"filter_actions","","Returns the actions to run to get the valid alternatives of the choice.",45,{"inputs":[{"name":"self"}],"output":{"generics":["filteraction"],"name":"iter"}}],[11,"filters","","Returns the filters operating on the `Choice`.",45,{"inputs":[{"name":"self"}],"output":{"generics":["filter"],"name":"iter"}}],[11,"add_filter_action","","Adds a filter to run on initialization.",45,{"inputs":[{"name":"self"},{"name":"filteraction"}],"output":null}],[11,"add_onchange","","Adds an action to perform when the `Choice` is constrained.",45,{"inputs":[{"name":"self"},{"name":"onchangeaction"}],"output":null}],[11,"add_filter","","Adds a filter to the `Choice`, returns an ID to indentify it.",45,{"inputs":[{"name":"self"},{"name":"filter"}],"output":{"name":"usize"}}],[11,"fragile_values","","Returns the values that should not be automatically restricted by filters.",45,{"inputs":[{"name":"self"}],"output":{"name":"valueset"}}],[11,"add_fragile_values","","Extends the list of values that should not be automatically propagated by filters.",45,{"inputs":[{"name":"self"},{"name":"valueset"}],"output":null}],[11,"fmt","","",30,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Creates a new `ChoiceArguments`.",30,{"inputs":[{"name":"vec"},{"name":"bool"},{"name":"bool"}],"output":{"name":"self"}}],[11,"names","","Returns the name of the arguments.",30,null],[11,"sets","","Returns the sets of the arguments.",30,null],[11,"get","","Returns the name and set of the argument at the given position.",30,null],[11,"iter","","Iterates over the arguments, with their sets and names.",30,null],[11,"is_symmetric","","Indicates if the arguments iteration domain is triangular.",30,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"len","","Returns the number of arguments.",30,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"clone","","",31,{"inputs":[{"name":"self"}],"output":{"name":"choicedef"}}],[11,"fmt","","",31,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",32,{"inputs":[{"name":"self"}],"output":{"name":"countervisibility"}}],[11,"fmt","","",32,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",32,{"inputs":[{"name":"self"},{"name":"countervisibility"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",32,{"inputs":[{"name":"self"},{"name":"countervisibility"}],"output":{"generics":["ordering"],"name":"option"}}],[11,"cmp","","",32,{"inputs":[{"name":"self"},{"name":"countervisibility"}],"output":{"name":"ordering"}}],[11,"value_type","","Returns the underlying value type.",31,{"inputs":[{"name":"self"}],"output":{"name":"valuetype"}}],[11,"is_counter","","Indicates if the choice is a counter.",31,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"as_enum","","Returns the name of the `Enum` the `Choice` is based on.",31,{"inputs":[{"name":"self"}],"output":{"generics":["rcstr"],"name":"option"}}],[11,"is_valid_operator","","Indicates the comparison operators that can be applied to the decision.",31,{"inputs":[{"name":"self"},{"name":"cmpop"}],"output":{"name":"bool"}}],[11,"clone","","",33,{"inputs":[{"name":"self"}],"output":{"name":"counterval"}}],[11,"fmt","","",33,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"adapt","","",33,{"inputs":[{"name":"self"},{"name":"adaptator"}],"output":{"name":"self"}}],[11,"full_type","","Returns the full type, instead of a the trimmed one.",34,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"as_enum","","Returns the enum name, if applicable.",34,{"inputs":[{"name":"self"}],"output":{"generics":["rcstr"],"name":"option"}}],[11,"clone","","",34,{"inputs":[{"name":"self"}],"output":{"name":"valuetype"}}],[11,"fmt","","",34,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",34,{"inputs":[{"name":"self"},{"name":"valuetype"}],"output":{"name":"bool"}}],[11,"ne","","",34,{"inputs":[{"name":"self"},{"name":"valuetype"}],"output":{"name":"bool"}}],[11,"adapt","","",34,{"inputs":[{"name":"self"},{"name":"adaptator"}],"output":{"name":"self"}}],[11,"clone","","",21,{"inputs":[{"name":"self"}],"output":{"name":"filtercall"}}],[11,"fmt","","",21,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"adapt","","",21,{"inputs":[{"name":"self"},{"name":"adaptator"}],"output":{"name":"self"}}],[11,"clone","","",35,{"inputs":[{"name":"self"}],"output":{"name":"filterref"}}],[11,"fmt","","",35,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"adapt","","",35,{"inputs":[{"name":"self"},{"name":"adaptator"}],"output":{"name":"self"}}],[11,"clone","","",22,{"inputs":[{"name":"self"}],"output":{"name":"onchangeaction"}}],[11,"fmt","","",22,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"applies_to_symmetric","","Indicates if the action sould also be registered for the symmetric of the choice, if applicable.",22,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"inverse","","Returns the action for the symmetric of the choice.",22,{"inputs":[{"name":"self"},{"name":"irdesc"}],"output":{"name":"self"}}],[11,"adapt","","",22,{"inputs":[{"name":"self"},{"name":"adaptator"}],"output":{"name":"self"}}],[11,"clone","","",36,{"inputs":[{"name":"self"}],"output":{"name":"choiceaction"}}],[11,"fmt","","",36,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"variables","","Returns the list of variables to allocate.",36,{"inputs":[{"name":"self"}],"output":{"generics":["iterator"],"name":"box"}}],[11,"inputs","","Returns the list of inputs used by the action.",36,null],[11,"inverse_self","","Inverse references to the value of the choice the action is registered in.",36,{"inputs":[{"name":"self"},{"name":"irdesc"}],"output":null}],[11,"adapt","","",36,{"inputs":[{"name":"self"},{"name":"adaptator"}],"output":{"name":"self"}}],[11,"clone","","",23,{"inputs":[{"name":"self"}],"output":{"name":"choicecondition"}}],[11,"fmt","","",23,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Adapt the list of conditions to be from the point of view of the given choice.",23,null],[11,"adapt","","",23,{"inputs":[{"name":"self"},{"name":"adaptator"}],"output":{"name":"self"}}],[11,"clone","","",24,{"inputs":[{"name":"self"}],"output":{"name":"filteraction"}}],[11,"fmt","","",24,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",25,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",37,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",37,{"inputs":[{"name":"self"}],"output":{"name":"subfilter"}}],[11,"fmt","","",26,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",26,{"inputs":[{"name":"self"}],"output":{"name":"rule"}}],[11,"instantiate","","Instantiates the rule for a given assignment of the inputs.",26,null],[11,"normalize","","Normalizes the `Rule`.",26,null],[11,"adapt","","",26,{"inputs":[{"name":"self"},{"name":"adaptator"}],"output":{"name":"self"}}],[11,"clone","","",46,{"inputs":[{"name":"self"}],"output":{"name":"setconstraints"}}],[11,"fmt","","",46,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"default","","",46,{"inputs":[],"output":{"name":"setconstraints"}}],[11,"eq","","",46,{"inputs":[{"name":"self"},{"name":"setconstraints"}],"output":{"name":"bool"}}],[11,"ne","","",46,{"inputs":[{"name":"self"},{"name":"setconstraints"}],"output":{"name":"bool"}}],[11,"hash","","",46,null],[11,"new","","Create a new list of set constraints. The constraints are put in a normalized and legal order.",46,{"inputs":[{"name":"vec"}],"output":{"name":"self"}}],[11,"constraints","","Returns the constraints in a legal order.",46,null],[11,"is_empty","","Indicates if the set of constraints is empty.",46,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"find_set","","Returns the set the given variable is constrained to, if any.",46,{"inputs":[{"name":"self"},{"name":"variable"}],"output":{"generics":["set"],"name":"option"}}],[11,"adapt","","",46,{"inputs":[{"name":"self"},{"name":"adaptator"}],"output":{"name":"self"}}],[11,"into_iter","","",46,null],[11,"clone","","",38,{"inputs":[{"name":"self"}],"output":{"name":"variable"}}],[11,"eq","","",38,{"inputs":[{"name":"self"},{"name":"variable"}],"output":{"name":"bool"}}],[11,"ne","","",38,{"inputs":[{"name":"self"},{"name":"variable"}],"output":{"name":"bool"}}],[11,"hash","","",38,null],[11,"partial_cmp","","",38,{"inputs":[{"name":"self"},{"name":"variable"}],"output":{"generics":["ordering"],"name":"option"}}],[11,"lt","","",38,{"inputs":[{"name":"self"},{"name":"variable"}],"output":{"name":"bool"}}],[11,"le","","",38,{"inputs":[{"name":"self"},{"name":"variable"}],"output":{"name":"bool"}}],[11,"gt","","",38,{"inputs":[{"name":"self"},{"name":"variable"}],"output":{"name":"bool"}}],[11,"ge","","",38,{"inputs":[{"name":"self"},{"name":"variable"}],"output":{"name":"bool"}}],[11,"cmp","","",38,{"inputs":[{"name":"self"},{"name":"variable"}],"output":{"name":"ordering"}}],[11,"adapt","","",38,{"inputs":[{"name":"self"},{"name":"adaptator"}],"output":{"name":"self"}}],[11,"fmt","","",38,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",38,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",27,{"inputs":[{"name":"self"}],"output":{"name":"choiceinstance"}}],[11,"fmt","","",27,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"hash","","",27,null],[11,"eq","","",27,{"inputs":[{"name":"self"},{"name":"choiceinstance"}],"output":{"name":"bool"}}],[11,"ne","","",27,{"inputs":[{"name":"self"},{"name":"choiceinstance"}],"output":{"name":"bool"}}],[11,"normalize","","Normalizes the `ChoiceInstance` and indicates if the corresponding input should be inversed.",27,{"inputs":[{"name":"self"},{"name":"irdesc"}],"output":{"name":"bool"}}],[11,"adapt","","",27,{"inputs":[{"name":"self"},{"name":"adaptator"}],"output":{"name":"self"}}],[11,"clone","","",28,{"inputs":[{"name":"self"}],"output":{"name":"code"}}],[11,"fmt","","",28,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",28,{"inputs":[{"name":"self"},{"name":"code"}],"output":{"name":"bool"}}],[11,"ne","","",28,{"inputs":[{"name":"self"},{"name":"code"}],"output":{"name":"bool"}}],[11,"hash","","",28,null],[11,"partial_cmp","","",28,{"inputs":[{"name":"self"},{"name":"code"}],"output":{"generics":["ordering"],"name":"option"}}],[11,"lt","","",28,{"inputs":[{"name":"self"},{"name":"code"}],"output":{"name":"bool"}}],[11,"le","","",28,{"inputs":[{"name":"self"},{"name":"code"}],"output":{"name":"bool"}}],[11,"gt","","",28,{"inputs":[{"name":"self"},{"name":"code"}],"output":{"name":"bool"}}],[11,"ge","","",28,{"inputs":[{"name":"self"},{"name":"code"}],"output":{"name":"bool"}}],[11,"cmp","","",28,{"inputs":[{"name":"self"},{"name":"code"}],"output":{"name":"ordering"}}],[11,"normalize","","Normalizes the `Code.",28,{"inputs":[{"name":"self"}],"output":null}],[11,"adapt","","",28,{"inputs":[{"name":"self"},{"name":"adaptator"}],"output":{"name":"self"}}],[11,"clone","","",39,{"inputs":[{"name":"self"}],"output":{"name":"condition"}}],[11,"fmt","","",39,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",39,{"inputs":[{"name":"self"},{"name":"condition"}],"output":{"name":"bool"}}],[11,"ne","","",39,{"inputs":[{"name":"self"},{"name":"condition"}],"output":{"name":"bool"}}],[11,"hash","","",39,null],[11,"partial_cmp","","",39,{"inputs":[{"name":"self"},{"name":"condition"}],"output":{"generics":["ordering"],"name":"option"}}],[11,"lt","","",39,{"inputs":[{"name":"self"},{"name":"condition"}],"output":{"name":"bool"}}],[11,"le","","",39,{"inputs":[{"name":"self"},{"name":"condition"}],"output":{"name":"bool"}}],[11,"gt","","",39,{"inputs":[{"name":"self"},{"name":"condition"}],"output":{"name":"bool"}}],[11,"ge","","",39,{"inputs":[{"name":"self"},{"name":"condition"}],"output":{"name":"bool"}}],[11,"cmp","","",39,{"inputs":[{"name":"self"},{"name":"condition"}],"output":{"name":"ordering"}}],[11,"negate","","Negates the condition.",39,{"inputs":[{"name":"self"}],"output":null}],[11,"alternatives_of","","Returns allowed alternatives for the given input. Returns None if the condition is not on the given input.",39,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"valuetype"},{"name":"irdesc"}],"output":{"generics":["valueset"],"name":"option"}}],[11,"instantiate","","Instantiate the condition in the given context.",39,null],[11,"evaluate","","Evaluates the condition. Requires the mapping to be instantiated.",39,null],[11,"normalize","","Normalizes the condition to make it easier to apply equality on it.",39,null],[11,"adapt","","",39,{"inputs":[{"name":"self"},{"name":"adaptator"}],"output":{"name":"self"}}],[11,"fmt","","",40,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",40,{"inputs":[{"name":"self"}],"output":{"name":"cmpop"}}],[11,"eq","","",40,{"inputs":[{"name":"self"},{"name":"cmpop"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",40,{"inputs":[{"name":"self"},{"name":"cmpop"}],"output":{"generics":["ordering"],"name":"option"}}],[11,"cmp","","",40,{"inputs":[{"name":"self"},{"name":"cmpop"}],"output":{"name":"ordering"}}],[11,"hash","","",40,null],[11,"negate","","Negates the operator.",40,{"inputs":[{"name":"self"}],"output":null}],[11,"inverse","","Returns the equivalent operator for when the operator are inversed.",40,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"allows_eq","","Indicates if the operator returns true when both operands are equals.",40,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"evaluate","","Evaluates the operator on the given `ValueSet`s.",40,{"inputs":[{"name":"self"},{"name":"valueset"},{"name":"valueset"}],"output":{"name":"trivalent"}}],[11,"clone","","",41,{"inputs":[{"name":"self"}],"output":{"name":"valueset"}}],[11,"fmt","","",41,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",41,{"inputs":[{"name":"self"},{"name":"valueset"}],"output":{"name":"bool"}}],[11,"ne","","",41,{"inputs":[{"name":"self"},{"name":"valueset"}],"output":{"name":"bool"}}],[11,"empty","","Creates an enmpty `ValueSet` of the given type.",41,{"inputs":[{"name":"valuetype"}],"output":{"name":"self"}}],[11,"from_properties","","Computes a `ValueSet` from the properties it must respect.",41,{"inputs":[{"name":"valuetype"},{"name":"bool"},{"name":"bool"},{"name":"irdesc"}],"output":{"name":"self"}}],[11,"enum_values","","Creates a `ValueSet` from a normalized set of values.",41,{"inputs":[{"name":"rcstr"},{"generics":["rcstr"],"name":"btreeset"}],"output":{"name":"self"}}],[11,"from_input","","Creates a `ValueSet` from the given input.",41,{"inputs":[{"name":"valuetype"},{"name":"usize"},{"name":"cmpop"},{"name":"bool"}],"output":{"name":"self"}}],[11,"is_empty","","Indicates if the set of values is empty.",41,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_full","","Indicates if the set contains all the values. This functions is pessimistic: the set may contain all the values and the function still return false.",41,{"inputs":[{"name":"self"},{"name":"irdesc"}],"output":{"name":"bool"}}],[11,"is_constrained","","Indicates if the set contains a single value.",41,{"inputs":[{"name":"self"}],"output":{"name":"trivalent"}}],[11,"extend","","Extends the `ValueSet` with the values of anther set.",41,{"inputs":[{"name":"self"},{"name":"valueset"}],"output":null}],[11,"intersect","","Intersects the `ValueSet` with the given values. Indicates if the intersection was successful or if the sets should be kept separate.",41,{"inputs":[{"name":"self"},{"name":"valueset"}],"output":{"name":"bool"}}],[11,"instantiate","","Instantiates the `ValueSet` for a given input assignment.",41,{"inputs":[{"name":"self"},{"name":"hashmap"},{"name":"irdesc"}],"output":{"name":"self"}}],[11,"inverse","","Inverse the `ValueSet`. The choice must be antisymmetric.",41,{"inputs":[{"name":"self"},{"name":"irdesc"}],"output":null}],[11,"is","","Indicates if the `ValueSet` will be contained into anoter after instantiation. Requires both `self` and `other` to be instantiated.",41,{"inputs":[{"name":"self"},{"name":"valueset"}],"output":{"name":"trivalent"}}],[11,"t","","Returns the type of the values.",41,{"inputs":[{"name":"self"}],"output":{"name":"valuetype"}}],[11,"adapt","","",41,{"inputs":[{"name":"self"},{"name":"adaptator"}],"output":{"name":"self"}}],[11,"clone","","",47,{"inputs":[{"name":"self"}],"output":{"name":"set"}}],[11,"hash","","",47,null],[11,"eq","","",47,{"inputs":[{"name":"self"},{"name":"set"}],"output":{"name":"bool"}}],[11,"ne","","",47,{"inputs":[{"name":"self"},{"name":"set"}],"output":{"name":"bool"}}],[11,"fmt","","",47,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Create a new set instance.",47,{"inputs":[{"name":"rc"},{"generics":["variable"],"name":"option"}],"output":{"name":"self"}}],[11,"is_subset_of_def","","Indicates if the first set is a sub-set of the second, without matching argument names.",47,{"inputs":[{"name":"self"},{"name":"set"}],"output":{"name":"bool"}}],[11,"get_collision_level","","Returns the common superset where the two set might have an object in common.",47,{"inputs":[{"name":"self"},{"name":"set"}],"output":{"generics":["setdef"],"name":"option"}}],[11,"reverse","","Returns a superset of this set and a set parametrized by elements of the superset that iterates on the possible parameters of this set given a variable of the superset.",47,{"inputs":[{"name":"self"},{"name":"variable"},{"name":"set"}],"output":{"name":"option"}}],[11,"adapt","","",47,{"inputs":[{"name":"self"},{"name":"adaptator"}],"output":{"name":"self"}}],[11,"clone","","",48,{"inputs":[{"name":"self"}],"output":{"name":"setrefimpl"}}],[11,"hash","","",48,null],[11,"eq","","",48,{"inputs":[{"name":"self"},{"name":"setrefimpl"}],"output":{"name":"bool"}}],[11,"ne","","",48,{"inputs":[{"name":"self"},{"name":"setrefimpl"}],"output":{"name":"bool"}}],[11,"fmt","","",48,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"def","","",48,{"inputs":[{"name":"self"}],"output":{"name":"setdef"}}],[11,"arg","","",48,{"inputs":[{"name":"self"}],"output":{"generics":["variable"],"name":"option"}}],[11,"reverse_constraint","","",48,{"inputs":[{"name":"self"}],"output":{"generics":["setrefimpl"],"name":"option"}}],[11,"clone","","",49,{"inputs":[{"name":"self"}],"output":{"name":"setdef"}}],[11,"new","","Creates a new set definition.",49,{"inputs":[{"name":"string"},{"generics":["set"],"name":"option"},{"generics":["set"],"name":"option"},{"name":"option"},{"generics":["setdefkey","string"],"name":"hashmap"},{"generics":["string"],"name":"vec"}],"output":{"name":"rc"}}],[11,"name","","The name of the set.",49,{"inputs":[{"name":"self"}],"output":{"name":"rcstr"}}],[11,"arg","","Returns the argument of the set, if any.",49,{"inputs":[{"name":"self"}],"output":{"generics":["set"],"name":"option"}}],[11,"superset","","Returns the superset of the set, if any.",49,{"inputs":[{"name":"self"}],"output":{"generics":["set"],"name":"option"}}],[11,"attributes","","The attributes of the set.",49,{"inputs":[{"name":"self"}],"output":{"name":"hashmap"}}],[11,"prefix","","Suggest a prefix for variables in the set.",49,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"def_order","","Returns an integer that indicates an order in which variables can be defined to always be defined before any argument of the set they belong into.",49,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"is_subset_of_def","","Indicates if the first set is a sub-set of the second.",49,{"inputs":[{"name":"self"},{"name":"setdef"}],"output":{"name":"bool"}}],[11,"fmt","","",49,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",49,{"inputs":[{"name":"self"},{"name":"setdef"}],"output":{"name":"bool"}}],[11,"hash","","",49,{"inputs":[{"name":"self"},{"name":"h"}],"output":null}],[11,"partial_cmp","","",49,{"inputs":[{"name":"self"},{"name":"setdef"}],"output":{"generics":["ordering"],"name":"option"}}],[11,"cmp","","",49,{"inputs":[{"name":"self"},{"name":"setdef"}],"output":{"name":"ordering"}}],[11,"fmt","","",42,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"hash","","",42,null],[11,"eq","","",42,{"inputs":[{"name":"self"},{"name":"setdefkey"}],"output":{"name":"bool"}}],[11,"clone","","",42,{"inputs":[{"name":"self"}],"output":{"name":"setdefkey"}}],[11,"env","","Returns the variables defined for the key.",42,{"inputs":[{"name":"self"}],"output":{"generics":["str"],"name":"vec"}}],[11,"is_arg_in_env","","Indicates if the environement contains the set argument.",42,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[18,"REQUIRED","","The list of required keys.",42,null],[11,"fmt","","",42,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[8,"SetRef","","Generic trait for sets.",null,null],[10,"def","","Returns the set definition.",50,{"inputs":[{"name":"self"}],"output":{"name":"setdef"}}],[10,"arg","","Returns the argument of the set, if any.",50,{"inputs":[{"name":"self"}],"output":{"generics":["variable"],"name":"option"}}],[10,"reverse_constraint","","A constraint on the variables to iterate on, issued from a set reversal.",50,{"inputs":[{"name":"self"}],"output":{"generics":["setrefimpl"],"name":"option"}}],[11,"without_reverse_constraints","","Returns the same set but without reverse constraints.",50,{"inputs":[{"name":"self"}],"output":{"name":"setrefimpl"}}],[11,"superset","","Returns the direct superset of this set, if any.",50,{"inputs":[{"name":"self"}],"output":{"generics":["setrefimpl"],"name":"option"}}],[11,"path_to_superset","","Returns the path of sets to access a super-set.",50,{"inputs":[{"name":"self"},{"name":"setref"}],"output":{"generics":["setrefimpl"],"name":"vec"}}],[11,"is_subset_of","","Indicates if the first set is a sub-set of the second.",50,{"inputs":[{"name":"self"},{"name":"set"}],"output":{"name":"bool"}}],[11,"as_ref","","Returns the `SetRefImpl` corresponding to this set.",50,{"inputs":[{"name":"self"}],"output":{"name":"setrefimpl"}}],[8,"Adaptable","","",null,null],[10,"adapt","","Adapts the object to the new environement.",51,{"inputs":[{"name":"self"},{"name":"adaptator"}],"output":{"name":"self"}}],[11,"add_choice","","Adds a `Choice` to the IR description.",52,{"inputs":[{"name":"self"},{"name":"choice"}],"output":null}],[11,"add_enum","","Adds an `Enum` to the IR desctiption.",52,{"inputs":[{"name":"self"},{"name":"enum"}],"output":null}],[11,"choices","","List the choice definitions.",52,null],[11,"enums","","List the enum definitions.",52,null],[11,"get_enum","","Returns the enum with the given name.",52,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"enum"}}],[11,"get_choice","","Returns the choice with the given name.",52,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"choice"}}],[11,"set_defs","","Iterates over all the sets.",52,null],[11,"add_set_def","","Register a set definition.",52,{"inputs":[{"name":"self"},{"generics":["setdef"],"name":"rc"}],"output":null}],[11,"get_set_def","","Returns the set definition associated with a name.",52,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"rc"}}],[11,"add_filter","","Adds a filter to a choice.",52,{"inputs":[{"name":"self"},{"name":"rcstr"},{"name":"filter"},{"generics":["set"],"name":"vec"},{"name":"setconstraints"}],"output":null}],[11,"add_onchange","","",52,{"inputs":[{"name":"self"},{"name":"str"},{"name":"onchangeaction"}],"output":null}],[11,"add_trigger","","Adds a trigger to a choice.",52,{"inputs":[{"name":"self"},{"name":"trigger"}],"output":{"name":"usize"}}],[11,"triggers","","Iterates on the triggers.",52,null],[11,"adapt_env","","Generates the list of sets to iterate and to constraints to iterate on the given context, but from the point of view of the given choice instance.",52,null],[11,"adapt_env_ext","","Generates the list of sets to iterate and to constraints to iterate on the given environement, but from the point of view of the given choice instance. The new foralls iterating on current arguments are returned in a separate list than the ones issued from foralls.",52,null],[11,"default","","",52,{"inputs":[],"output":{"name":"self"}}],[11,"clone","","",43,{"inputs":[{"name":"self"}],"output":{"name":"counterkind"}}],[11,"fmt","","",43,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",43,{"inputs":[{"name":"self"},{"name":"counterkind"}],"output":{"name":"bool"}}],[11,"zero","","Returns the neutral element of the operand.",43,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"fmt","","",53,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Creates a new enum definition.",53,{"inputs":[{"name":"rcstr"},{"generics":["rcstr"],"name":"option"},{"generics":["vec"],"name":"option"}],"output":{"name":"self"}}],[11,"name","","Returns the name of the enum.",53,{"inputs":[{"name":"self"}],"output":{"name":"rcstr"}}],[11,"add_value","","Adds a possible value to the enum.",53,{"inputs":[{"name":"self"},{"name":"rcstr"},{"generics":["string"],"name":"option"}],"output":null}],[11,"add_alias","","Adds an alias to the enum possible values.",53,{"inputs":[{"name":"self"},{"name":"rcstr"},{"generics":["rcstr"],"name":"hashset"},{"generics":["string"],"name":"option"}],"output":null}],[11,"aliases","","Lists the aliases.",53,{"inputs":[{"name":"self"}],"output":{"name":"hashmap"}}],[11,"doc","","Returns the documentation associated with the enum.",53,{"inputs":[{"name":"self"}],"output":{"generics":["str"],"name":"option"}}],[11,"values","","Returns the values the enum can take, and their associated comment.",53,{"inputs":[{"name":"self"}],"output":{"name":"hashmap"}}],[11,"expand","","Replaces aliases by the corresponding values.",53,{"inputs":[{"name":"self"},{"name":"it"}],"output":{"generics":["rcstr"],"name":"hashset"}}],[11,"inverse","","Inverse an antisymmetric value.",53,{"inputs":[{"name":"self"},{"name":"rcstr"}],"output":{"name":"rcstr"}}],[11,"inverse_mapping","","Returns the mapping to apply to obtain the symmetric of a value.",53,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[0,"lexer","telamon_gen","",null,null],[3,"Position","telamon_gen::lexer","A sequence's row/column position",null,null],[12,"line","","",4,null],[12,"column","","",4,null],[3,"Spanned","","A F/lex's token with a span.",null,null],[12,"beg","","",5,null],[12,"end","","",5,null],[12,"data","","Spanned data",5,null],[3,"Span","","A double sequence's row/column position",null,null],[12,"beg","","",54,null],[12,"end","","",54,null],[3,"Lexer","","",null,null],[4,"Token","","",null,null],[13,"InvalidToken","","",55,null],[13,"ValueIdent","","",55,null],[13,"ChoiceIdent","","",55,null],[13,"Var","","",55,null],[13,"Doc","","",55,null],[13,"CmpOp","","",55,null],[13,"Code","","",55,null],[13,"CounterKind","","",55,null],[13,"Bool","","",55,null],[13,"CounterVisibility","","",55,null],[13,"And","","",55,null],[13,"Trigger","","",55,null],[13,"When","","",55,null],[13,"Alias","","",55,null],[13,"Counter","","",55,null],[13,"Define","","",55,null],[13,"Enum","","",55,null],[13,"Equal","","",55,null],[13,"Forall","","",55,null],[13,"In","","",55,null],[13,"Is","","",55,null],[13,"Not","","",55,null],[13,"Require","","",55,null],[13,"Requires","","",55,null],[13,"Value","","",55,null],[13,"End","","",55,null],[13,"Symmetric","","",55,null],[13,"AntiSymmetric","","",55,null],[13,"Arrow","","",55,null],[13,"Colon","","",55,null],[13,"Comma","","",55,null],[13,"LParen","","",55,null],[13,"RParen","","",55,null],[13,"BitOr","","",55,null],[13,"Or","","",55,null],[13,"SetDefKey","","",55,null],[13,"Set","","",55,null],[13,"SubsetOf","","",55,null],[13,"SetIdent","","",55,null],[13,"Base","","",55,null],[13,"Disjoint","","",55,null],[13,"Quotient","","",55,null],[13,"Of","","",55,null],[13,"Divide","","",55,null],[13,"Integer","","",55,null],[4,"LexicalError","","",null,null],[13,"InvalidToken","","",56,null],[13,"UnexpectedToken","","",56,null],[11,"default","telamon_gen::ast","",4,{"inputs":[],"output":{"name":"position"}}],[11,"clone","","",4,{"inputs":[{"name":"self"}],"output":{"name":"position"}}],[11,"fmt","","",4,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",4,{"inputs":[{"name":"self"},{"name":"position"}],"output":{"name":"bool"}}],[11,"ne","","",4,{"inputs":[{"name":"self"},{"name":"position"}],"output":{"name":"bool"}}],[11,"fmt","","",4,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"default","telamon_gen::lexer","",54,{"inputs":[],"output":{"name":"span"}}],[11,"clone","","",54,{"inputs":[{"name":"self"}],"output":{"name":"span"}}],[11,"fmt","","",54,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",54,{"inputs":[{"name":"self"},{"name":"span"}],"output":{"name":"bool"}}],[11,"ne","","",54,{"inputs":[{"name":"self"},{"name":"span"}],"output":{"name":"bool"}}],[11,"fmt","","",54,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","telamon_gen::ast","",5,{"inputs":[{"name":"self"}],"output":{"name":"spanned"}}],[11,"eq","","",5,{"inputs":[{"name":"self"},{"name":"spanned"}],"output":{"name":"bool"}}],[11,"ne","","",5,{"inputs":[{"name":"self"},{"name":"spanned"}],"output":{"name":"bool"}}],[11,"fmt","","",5,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","",5,{"inputs":[{"name":"y"}],"output":{"name":"spanned"}}],[11,"fmt","telamon_gen::lexer","",55,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",55,{"inputs":[{"name":"self"}],"output":{"name":"token"}}],[11,"eq","","",55,{"inputs":[{"name":"self"},{"name":"token"}],"output":{"name":"bool"}}],[11,"ne","","",55,{"inputs":[{"name":"self"},{"name":"token"}],"output":{"name":"bool"}}],[11,"fmt","","",55,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[6,"SpannedLexer","","The alias Spanned is a definition of the stream format. The parser will accept an iterator where each item in the stream has the following structure.",null,null],[11,"fmt","","",56,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",56,{"inputs":[{"name":"self"}],"output":{"name":"lexicalerror"}}],[11,"eq","","",56,{"inputs":[{"name":"self"},{"name":"lexicalerror"}],"output":{"name":"bool"}}],[11,"ne","","",56,{"inputs":[{"name":"self"},{"name":"lexicalerror"}],"output":{"name":"bool"}}],[11,"description","","",56,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"fmt","","",56,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","",57,{"inputs":[{"name":"read"}],"output":{"name":"self"}}],[11,"from","","",57,{"inputs":[{"generics":["u8"],"name":"vec"}],"output":{"name":"self"}}],[11,"drop","","",57,{"inputs":[{"name":"self"}],"output":null}],[11,"next","","",57,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[0,"parser","telamon_gen","",null,null],[5,"parse_ast","telamon_gen::parser","",null,{"inputs":[{"name":"__tokens"}],"output":{"generics":["ast","parseerror"],"name":"result"}}],[8,"__ToTriple","","",null,null],[16,"Error","","",58,null],[10,"to_triple","","",58,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"fmt","telamon_gen::ir","",43,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",40,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",53,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[0,"error","telamon_gen","",null,null],[3,"ProcessError","telamon_gen::error","",null,null],[12,"path","","Display of filename.",59,null],[12,"span","","Position of lexeme.",59,null],[4,"Cause","","",null,null],[13,"Parse","","Lalrpop",60,null],[13,"Other","","Will be remplaced by field for Ast [...]",60,null],[11,"fmt","","",60,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",59,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from","","",59,null],[11,"fmt","","",59,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"description","","",59,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"cause","","",59,{"inputs":[{"name":"self"}],"output":{"generics":["error"],"name":"option"}}],[11,"without_reverse_constraints","telamon_gen::ir","Returns the same set but without reverse constraints.",50,{"inputs":[{"name":"self"}],"output":{"name":"setrefimpl"}}],[11,"superset","","Returns the direct superset of this set, if any.",50,{"inputs":[{"name":"self"}],"output":{"generics":["setrefimpl"],"name":"option"}}],[11,"path_to_superset","","Returns the path of sets to access a super-set.",50,{"inputs":[{"name":"self"},{"name":"setref"}],"output":{"generics":["setrefimpl"],"name":"vec"}}],[11,"is_subset_of","","Indicates if the first set is a sub-set of the second.",50,{"inputs":[{"name":"self"},{"name":"set"}],"output":{"name":"bool"}}],[11,"as_ref","","Returns the `SetRefImpl` corresponding to this set.",50,{"inputs":[{"name":"self"}],"output":{"name":"setrefimpl"}}]],"paths":[[3,"SetDef"],[3,"IntegerDef"],[3,"EnumDef"],[3,"Constraint"],[3,"Position"],[3,"Spanned"],[3,"Ast"],[3,"Quotient"],[3,"CounterBody"],[3,"SetRef"],[3,"VarDef"],[3,"ChoiceInstance"],[3,"CounterDef"],[4,"ChoiceDef"],[4,"Hint"],[4,"TypeError"],[4,"Statement"],[4,"Symmetry"],[4,"Condition"],[4,"CounterVal"],[4,"EnumStatement"],[3,"FilterCall"],[3,"OnChangeAction"],[3,"ChoiceCondition"],[3,"FilterAction"],[3,"Filter"],[3,"Rule"],[3,"ChoiceInstance"],[3,"Code"],[3,"Trigger"],[4,"ChoiceArguments"],[4,"ChoiceDef"],[4,"CounterVisibility"],[4,"CounterVal"],[4,"ValueType"],[4,"FilterRef"],[4,"ChoiceAction"],[4,"SubFilter"],[4,"Variable"],[4,"Condition"],[4,"CmpOp"],[4,"ValueSet"],[4,"SetDefKey"],[4,"CounterKind"],[3,"Adaptator"],[3,"Choice"],[3,"SetConstraints"],[3,"Set"],[3,"SetRefImpl"],[3,"SetDef"],[8,"SetRef"],[8,"Adaptable"],[3,"IrDesc"],[3,"Enum"],[3,"Span"],[4,"Token"],[4,"LexicalError"],[3,"Lexer"],[8,"__ToTriple"],[3,"ProcessError"],[4,"Cause"]]};
searchIndex["telamon_gen_test"] = {"doc":"","items":[],"paths":[]};
searchIndex["telamon_kernels"] = {"doc":"Defines common kernels used to test and benchmark Telamon.","items":[[5,"analyze_bounds","telamon_kernels","Prints an analysis of the bounds computed by the lower bound model.",null,{"inputs":[{"generics":["boundsample"],"name":"vec"}],"output":null}],[0,"linalg","","Linera algebra kernels.",null,null],[3,"Axpy","telamon_kernels::linalg","Computes `z = alpha*x+y`.",null,null],[3,"MatVec","","Computes `y = A.x`.",null,null],[3,"Gesummv","","Computes `y = (alpha*A + beta*B).x`.",null,null],[3,"MatMul","","Computes `C = A.B`.",null,null],[12,"params","","",0,null],[3,"MatMulP","","",null,null],[12,"m","","",1,null],[12,"n","","",1,null],[12,"k","","",1,null],[12,"a_stride","","",1,null],[12,"transpose_a","","",1,null],[12,"transpose_b","","",1,null],[12,"generic","","",1,null],[12,"m_tiling","","",1,null],[12,"n_tiling","","",1,null],[12,"k_tiling","","",1,null],[3,"BatchMM","","Batch transposed matrix-matrix multiplication.",null,null],[3,"BatchMMP","","",null,null],[12,"m","","",2,null],[12,"n","","",2,null],[12,"k","","",2,null],[12,"batch","","",2,null],[12,"transpose_a","","",2,null],[12,"transpose_b","","",2,null],[12,"batch_b","","",2,null],[12,"generic","","",2,null],[11,"name","","",3,{"inputs":[],"output":{"name":"str"}}],[11,"build_signature","","",3,null],[11,"build_body","","",3,{"inputs":[{"name":"self"},{"name":"signature"},{"name":"context"}],"output":{"generics":["candidate"],"name":"vec"}}],[11,"get_expected_output","","",3,{"inputs":[{"name":"self"},{"name":"context"}],"output":{"name":"arrayd"}}],[11,"check_result","","",3,null],[11,"name","","",4,{"inputs":[],"output":{"name":"str"}}],[11,"build_signature","","",4,null],[11,"build_body","","",4,{"inputs":[{"name":"self"},{"name":"signature"},{"name":"context"}],"output":{"generics":["candidate"],"name":"vec"}}],[11,"get_expected_output","","",4,{"inputs":[{"name":"self"},{"name":"context"}],"output":{"name":"array1"}}],[11,"check_result","","",4,null],[11,"name","","",5,{"inputs":[],"output":{"name":"str"}}],[11,"build_signature","","",5,null],[11,"build_body","","",5,{"inputs":[{"name":"self"},{"name":"signature"},{"name":"context"}],"output":{"generics":["candidate"],"name":"vec"}}],[11,"get_expected_output","","",5,{"inputs":[{"name":"self"},{"name":"context"}],"output":{"name":"array1"}}],[11,"check_result","","",5,null],[11,"clone","","",1,{"inputs":[{"name":"self"}],"output":{"name":"matmulp"}}],[11,"new","","",1,{"inputs":[{"name":"i32"},{"name":"i32"},{"name":"i32"}],"output":{"name":"self"}}],[11,"transpose_a","","",1,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"transpose_b","","",1,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"stride_a","","",1,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"self"}}],[11,"static_sizes","","Inline the sizes in the generated code.",1,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"name","","",0,{"inputs":[],"output":{"name":"str"}}],[11,"build_signature","","",0,{"inputs":[{"name":"matmulp"},{"name":"signaturebuilder"}],"output":{"name":"self"}}],[11,"build_body","","",0,{"inputs":[{"name":"self"},{"name":"signature"},{"name":"context"}],"output":{"generics":["candidate"],"name":"vec"}}],[11,"get_expected_output","","",0,{"inputs":[{"name":"self"},{"name":"context"}],"output":{"name":"array2"}}],[11,"check_result","","",0,null],[11,"clone","","",2,{"inputs":[{"name":"self"}],"output":{"name":"batchmmp"}}],[11,"new","","",2,{"inputs":[{"name":"i32"},{"name":"i32"},{"name":"i32"},{"name":"i32"}],"output":{"name":"self"}}],[11,"transpose_a","","",2,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"transpose_b","","",2,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"static_sizes","","Generate code that is onyl valid for the given sizes. The batch size is still generic.",2,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"reuse_b","","Reuse the `B` matrix across the batch.",2,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"name","","",6,{"inputs":[],"output":{"name":"str"}}],[11,"build_signature","","",6,{"inputs":[{"name":"batchmmp"},{"name":"signaturebuilder"}],"output":{"name":"self"}}],[11,"build_body","","",6,{"inputs":[{"name":"self"},{"name":"signature"},{"name":"context"}],"output":{"generics":["candidate"],"name":"vec"}}],[11,"get_expected_output","","",6,{"inputs":[{"name":"self"},{"name":"context"}],"output":{"name":"array3"}}],[11,"check_result","","",6,null],[0,"statistics","telamon_kernels","Statistical analysis for benchmarking.",null,null],[3,"Estimate","telamon_kernels::statistics","Estimates a mean within a confidence interval.",null,null],[12,"unit","","",7,null],[12,"value","","",7,null],[12,"interval","","",7,null],[12,"confidence","","",7,null],[5,"mean","","Computes the mean of a data set.",null,null],[5,"estimate_mean","","Computes the mean and the confidence interval of the data set. The requested degree of confidence must be between 0 and 1.",null,{"inputs":[{"generics":["f64"],"name":"vec"},{"name":"f64"},{"name":"str"}],"output":{"name":"estimate"}}],[5,"estimate_ratio","","Computes the error margin of a ratio between answer of a binary choice given the number of samples with a 95% confidence interval.",null,{"inputs":[{"name":"f64"},{"name":"usize"}],"output":{"name":"estimate"}}],[11,"fmt","","",7,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[8,"Kernel","telamon_kernels","A kernel that can be compiled, benchmarked and used for correctness tests.",null,null],[16,"Parameters","","The input parameters of the kernel.",8,null],[16,"ExpectedOutput","","The values to expect as output.",8,null],[10,"name","","The name of the function computed by the kernel.",8,{"inputs":[],"output":{"name":"str"}}],[10,"build_signature","","Builds the signature of the kernel in the builder and returns an object that stores enough information to later build the kernel body and check its result. The `is_generic` flag indicates if th sizes should be instantiated.",8,null],[10,"build_body","","Builder the kernel body in the given builder. This builder should be based on the signature created by `build_signature`.",8,{"inputs":[{"name":"self"},{"name":"signature"},{"name":"context"}],"output":{"generics":["candidate"],"name":"vec"}}],[10,"get_expected_output","","Computes the expected output.",8,null],[10,"check_result","","Ensures the generated code performs the correct operation.",8,null],[11,"test_correctness","","Generates, executes and tests the output of candidates for the kernel.",8,null],[11,"test_bound","","Tests the correctness of the bound of kernels and returns the list of tested leafs along with the actual evaluation time.",8,null],[11,"benchmark","","Runs the search and benchmarks the resulting candidate.",8,null],[11,"deadend_ratio","","Computes the probability of encountering a dead-end when descending in the search tree.",8,null],[8,"Scalar","","A scalar that can be used as the data type for tests.",null,null],[11,"epsilon","","Returns the amount of allowed error in tests.",9,{"inputs":[],"output":{"name":"self"}}],[11,"is_err_ok","","Indicates if the scalar can be considered as zero in the context of error checking.",9,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"test_correctness","","Generates, executes and tests the output of candidates for the kernel.",8,null],[11,"test_bound","","Tests the correctness of the bound of kernels and returns the list of tested leafs along with the actual evaluation time.",8,null],[11,"benchmark","","Runs the search and benchmarks the resulting candidate.",8,null],[11,"deadend_ratio","","Computes the probability of encountering a dead-end when descending in the search tree.",8,null]],"paths":[[3,"MatMul"],[3,"MatMulP"],[3,"BatchMMP"],[3,"Axpy"],[3,"MatVec"],[3,"Gesummv"],[3,"BatchMM"],[3,"Estimate"],[8,"Kernel"],[8,"Scalar"]]};
searchIndex["telamon_utils"] = {"doc":"Generic helper functions.","items":[[3,"Cache","telamon_utils","A thread-safe LRU Cache.",null,null],[3,"Dag","","A directed acyclic graph given by adjacency list.",null,null],[3,"FilterList","","Iterates over a linked list while removing some items.",null,null],[3,"ZipCopy","","Zip copies of an object with an iterator.",null,null],[3,"PartialPermutations","","",null,null],[3,"VecSet","","A set backed by an ordered vector.",null,null],[3,"RcStr","","A reference counted string, compatible with `&str`.",null,null],[4,"Trivalent","","Booleans enhanced with a third `Maybe` value.",null,null],[13,"False","","",0,null],[13,"Maybe","","",0,null],[13,"True","","",0,null],[5,"filter_list","","Iterates over a linked list while removing some items.",null,{"inputs":[{"name":"linkedlist"},{"name":"f"}],"output":{"name":"filterlist"}}],[5,"zip_copy","","Zip copies of an object with an iterator.",null,{"inputs":[{"name":"i"},{"name":"t"}],"output":{"name":"zipcopy"}}],[5,"at_most_one","","Ensures an iterator has at most one element.",null,{"inputs":[{"name":"it"}],"output":{"name":"option"}}],[5,"to_map","","Transforms an iterator into an `HashMap`. Redundant nodes are merged using `merge`.",null,{"inputs":[{"name":"it"},{"name":"m"}],"output":{"name":"hashmap"}}],[5,"div_ceil","","Performs an integer divison rounded to the upper number.",null,{"inputs":[{"name":"t"},{"name":"t"}],"output":{"name":"t"}}],[5,"log2_u32","","Returns the log2 of a power of 2.",null,{"inputs":[{"name":"u32"}],"output":{"generics":["u32"],"name":"option"}}],[5,"clone_pair","","Clones a pair of reference.",null,null],[5,"cmp_f64","","Compare two f64, panic if one of them is nan",null,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"ordering"}}],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Returns a new `Cache` that can store `capacity` elements.",1,{"inputs":[{"name":"usize"}],"output":{"name":"self"}}],[11,"get","","Returns the element associated to `key` in the cache. Generates the element with `gen` and store it in the cache if it is not already present.",1,{"inputs":[{"name":"self"},{"name":"k"},{"name":"f"}],"output":{"name":"arc"}}],[11,"clear","","Removes all elements from the `Cache`.",1,{"inputs":[{"name":"self"}],"output":null}],[11,"fmt","","",2,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from_order","","Computes a minimal DAG from a partial order.",2,{"inputs":[{"name":"vec"},{"name":"c"}],"output":{"name":"dag"}}],[11,"nodes","","Returns the list of nodes, in increasing order.",2,null],[11,"before","","Returns the predecessors of the given node.",2,null],[11,"after","","Returns the successors of the given node.",2,null],[11,"minima","","Returns the id of nodes without predecessors.",2,{"inputs":[{"name":"self"}],"output":{"generics":["usize"],"name":"vec"}}],[11,"predecessors","","Returns all the predecessors of a node.",2,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"generics":["usize"],"name":"vec"}}],[0,"ndarray","","An array with a variable number of dimensions.",null,null],[3,"NDArray","telamon_utils::ndarray","An array with a variable number of dimensions.",null,null],[12,"dims","","",3,null],[3,"NDRange","","A N-dimentional range.",null,null],[3,"ViewMut","","A mutable view on a `NDArray`, with some dimensions fixed.",null,null],[3,"ViewMutIter","","Iterator over the elements in a mutable view.",null,null],[3,"ViewIterMut","","Mutable iterator over the elements in a mutable view.",null,null],[11,"fmt","","",3,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Create a NDArray and initializes it with the generator.",3,{"inputs":[{"generics":["usize"],"name":"vec"},{"name":"vec"}],"output":{"name":"ndarray"}}],[11,"init_default","","Initializes an NDArray with default values.",3,{"inputs":[{"generics":["usize"],"name":"vec"}],"output":{"name":"self"}}],[11,"num_dims","","Returns the number of dimensions in the array.",3,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"view_mut","","Returns a mutable view on the NDArray.",3,{"inputs":[{"name":"self"}],"output":{"name":"viewmut"}}],[11,"index","","",3,null],[11,"index_mut","","",3,null],[11,"new","","Creates a ND range with the given bounds.",4,null],[11,"next","","",4,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"num_dims","","Returns the number of non-fixed dimensions in the view.",5,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"split","","Splits the view on the given dimension.",5,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"generics":["viewmut"],"name":"vec"}}],[11,"enumerate","","Enumerates the elements with their indexes.",5,null],[11,"enumerate_mut","","Produces mutable references to the elements, with their indexes.",5,null],[11,"index","","",5,null],[11,"index_mut","","",5,null],[11,"next","","",6,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next","","",7,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next","telamon_utils","",8,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next","","",9,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"new","","Returns an iterator of the partial permuations of size `k` of values. Permutations are returned in lexicographical order.",10,{"inputs":[{"name":"it"},{"name":"usize"}],"output":{"name":"self"}}],[11,"next","","",10,{"inputs":[{"name":"self"}],"output":{"generics":["vec"],"name":"option"}}],[0,"multimap","","A `HashMap` with mutiple values for each key.",null,null],[3,"MultiHashMap","telamon_utils::multimap","A `HashMap` with mutiple values for each key.",null,null],[11,"clone","","",11,{"inputs":[{"name":"self"}],"output":{"name":"multihashmap"}}],[11,"serialize","","",11,{"inputs":[{"name":"self"},{"name":"s"}],"output":{"name":"result"}}],[11,"new","","Creates an empty `MultiHashMap`.",11,{"inputs":[],"output":{"generics":["randomstate"],"name":"multihashmap"}}],[11,"with_capacity","","Creates an empty hash map with the given initial capacity.",11,{"inputs":[{"name":"usize"}],"output":{"generics":["randomstate"],"name":"multihashmap"}}],[11,"with_hasher","","Creates an empty `MultiHashMap` which will use the given hash builder to hash keys.",11,{"inputs":[{"name":"s"}],"output":{"name":"self"}}],[11,"with_capacity_and_hasher","","Creates an empty `MultiHashMap` with space for at least `capacity`  elements, using `hasher` to hash the keys.",11,{"inputs":[{"name":"usize"},{"name":"s"}],"output":{"name":"self"}}],[11,"capacity","","Returns the number of elements the map can hold without reallocating.",11,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"reserve","","Reserves capacity for at least `additional` more elements to be inserted in the `MultiHashMap`. The collection may reserve more space to avoid frequent reallocations.",11,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[11,"shrink_to_fit","","Shrinks the capacity of the map as much as possible. It will drop down as much as possible while maintaining the internal rules and possibly leaving some space in accordance with the resize policy.",11,{"inputs":[{"name":"self"}],"output":null}],[11,"keys","","An iterator visiting all keys in arbitrary order.",11,{"inputs":[{"name":"self"}],"output":{"generics":["vec"],"name":"keys"}}],[11,"values","","An iterator visiting all values in arbitrary order.",11,null],[11,"values_mut","","An iterator visitinf all values mutably in arbitrary order.",11,null],[11,"iter","","Iterates over all the keys and returns the associated values.",11,{"inputs":[{"name":"self"}],"output":{"generics":["vec"],"name":"iter"}}],[11,"num_keys","","Returns the number of keys.",11,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"is_empty","","Indicates if the map contains no elements.",11,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"drain","","Clears the map, returning all key-value pairs as an iterator. Keeps the allocated memory for reuse.",11,{"inputs":[{"name":"self"}],"output":{"generics":["vec"],"name":"drain"}}],[11,"clear","","Clears the map, removing all keys and values.",11,{"inputs":[{"name":"self"}],"output":null}],[11,"get","","Returns the values mapped to the key.",11,null],[11,"contains_key","","Indicates if the map contains a value for the specified key.",11,{"inputs":[{"name":"self"},{"name":"q"}],"output":{"name":"bool"}}],[11,"get_mut","","Returns an iterator over mutable reference to the values mapped to the key.",11,null],[11,"insert","","Inserts new value to the map.",11,{"inputs":[{"name":"self"},{"name":"k"},{"name":"v"}],"output":null}],[11,"insert_many","","Inserts new value to the map.",11,{"inputs":[{"name":"self"},{"name":"k"},{"name":"vec"}],"output":null}],[11,"remove","","Removes all the elements bound to a key.",11,{"inputs":[{"name":"self"},{"name":"q"}],"output":{"name":"vec"}}],[11,"eq","","",11,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"bool"}}],[11,"fmt","","",11,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"default","","",11,{"inputs":[],"output":{"name":"self"}}],[11,"index","","",11,null],[11,"into_iter","","",11,null],[11,"from_iter","","",11,{"inputs":[{"name":"t"}],"output":{"name":"self"}}],[11,"from_iter","","",11,{"inputs":[{"name":"t"}],"output":{"name":"self"}}],[11,"clone","telamon_utils","",12,{"inputs":[{"name":"self"}],"output":{"name":"vecset"}}],[11,"eq","","",12,{"inputs":[{"name":"self"},{"name":"vecset"}],"output":{"name":"bool"}}],[11,"ne","","",12,{"inputs":[{"name":"self"},{"name":"vecset"}],"output":{"name":"bool"}}],[11,"hash","","",12,null],[11,"new","","Creates a new `VecSet` with the given data.",12,{"inputs":[{"name":"vec"}],"output":{"name":"self"}}],[11,"is_empty","","Indicates if the `VecSet` is empty.",12,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"len","","Returns the number of elements in the set.",12,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"iter","","Iterates over the set, in order.",12,{"inputs":[{"name":"self"}],"output":{"name":"iter"}}],[11,"difference","","Returns the elements in self but not in other.",12,{"inputs":[{"name":"self"},{"name":"vecset"}],"output":{"name":"difference"}}],[11,"intersection","","Returns a set containing the elements present in both `self` and `other`.",12,{"inputs":[{"name":"self"},{"name":"vecset"}],"output":{"name":"intersection"}}],[11,"intersect","","In-place intersection with another `VecSet`.",12,{"inputs":[{"name":"self"},{"name":"vecset"}],"output":null}],[11,"union","","Returns a set containing the elements present in either self`or`other`.",12,{"inputs":[{"name":"self"},{"name":"vecset"}],"output":{"name":"vecset"}}],[11,"filter","","Returns a new `VecSet` with only the elements for which the predicate returned `true`.",12,{"inputs":[{"name":"self"},{"name":"p"}],"output":{"name":"self"}}],[11,"retain","","Filters out elements for wich the predicate returns false.",12,{"inputs":[{"name":"self"},{"name":"p"}],"output":null}],[11,"insert","","Inserts an element in the `VecSet`. This operation has a complexity in O(n). Returns `false` if the item was already present.",12,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"bool"}}],[11,"default","","",12,{"inputs":[],"output":{"name":"self"}}],[11,"fmt","","",12,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"partial_cmp","","",12,{"inputs":[{"name":"self"},{"name":"vecset"}],"output":{"generics":["ordering"],"name":"option"}}],[11,"into_iter","","",12,null],[11,"from_iter","","",12,{"inputs":[{"name":"it"}],"output":{"name":"self"}}],[11,"deref","","",12,null],[0,"unwrap","","A macro to help debug unwraps.",null,null],[8,"Unwrap","telamon_utils::unwrap","",null,null],[16,"Output","","The type retruned by unwraping.",13,null],[10,"unwrap","","Unwraps the value or panics with the given message.",13,null],[6,"DefaultHasher","telamon_utils","A fast but not secure `Hasher`.",null,null],[6,"HashSet","","An `HashSet` based on `DefaultHasher`.",null,null],[6,"HashMap","","An `HashMap` based on `DefaultHasher`.",null,null],[6,"MultiHashMap","","A `HashMap` based on `DefaultHasher`.",null,null],[8,"BuilderTrait","","A trait that implements useful methods on builders.",null,null],[11,"doif","","Runs the closure if the bool is true.",14,{"inputs":[{"name":"self"},{"name":"bool"},{"name":"f"}],"output":{"name":"self"}}],[11,"default","","",15,{"inputs":[],"output":{"name":"rcstr"}}],[11,"clone","","",15,{"inputs":[{"name":"self"}],"output":{"name":"rcstr"}}],[11,"eq","","",15,{"inputs":[{"name":"self"},{"name":"rcstr"}],"output":{"name":"bool"}}],[11,"ne","","",15,{"inputs":[{"name":"self"},{"name":"rcstr"}],"output":{"name":"bool"}}],[11,"hash","","",15,null],[11,"cmp","","",15,{"inputs":[{"name":"self"},{"name":"rcstr"}],"output":{"name":"ordering"}}],[11,"partial_cmp","","",15,{"inputs":[{"name":"self"},{"name":"rcstr"}],"output":{"generics":["ordering"],"name":"option"}}],[11,"lt","","",15,{"inputs":[{"name":"self"},{"name":"rcstr"}],"output":{"name":"bool"}}],[11,"le","","",15,{"inputs":[{"name":"self"},{"name":"rcstr"}],"output":{"name":"bool"}}],[11,"gt","","",15,{"inputs":[{"name":"self"},{"name":"rcstr"}],"output":{"name":"bool"}}],[11,"ge","","",15,{"inputs":[{"name":"self"},{"name":"rcstr"}],"output":{"name":"bool"}}],[11,"fmt","","",15,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Creates a new reference-counted string.",15,{"inputs":[{"name":"string"}],"output":{"name":"self"}}],[11,"from","","",15,{"inputs":[{"name":"str"}],"output":{"name":"self"}}],[11,"serialize","","",15,{"inputs":[{"name":"self"},{"name":"s"}],"output":{"name":"result"}}],[11,"borrow","","",15,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"borrow","","",15,{"inputs":[{"name":"self"}],"output":{"name":"string"}}],[11,"deref","","",15,{"inputs":[{"name":"self"}],"output":{"name":"string"}}],[11,"fmt","","",15,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",15,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"bool"}}],[11,"from","","",15,{"inputs":[{"name":"string"}],"output":{"name":"rcstr"}}],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"trivalent"}],"output":{"name":"bool"}}],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"trivalent"}}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"as_bool","","Returns the boolean represented.",0,{"inputs":[{"name":"self"}],"output":{"generics":["bool"],"name":"option"}}],[11,"maybe_true","","Returns `true` if the underlying boolean might be `true`.",0,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"maybe_false","","Returns `true` if the underlying boolean might be `false`.",0,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_true","","Returns `true` if the underlying boolean is `true`.",0,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_false","","Returns `true` if the underlying boolean is `false`.",0,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_maybe","","Returns `true` if the underlying boolean might be `true` and `false`.",0,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"bitand","","",0,{"inputs":[{"name":"self"},{"name":"trivalent"}],"output":{"name":"trivalent"}}],[11,"bitor","","",0,{"inputs":[{"name":"self"},{"name":"trivalent"}],"output":{"name":"trivalent"}}],[11,"not","","",0,{"inputs":[{"name":"self"}],"output":{"name":"trivalent"}}],[14,"unwrap","","Panics after if the value cannot be unwraped.",null,null],[14,"generated_file","","Includes a generates file into the current file.",null,null],[14,"eq_from_key","","Defines equality from a key.",null,null],[14,"hash_from_key","","Defines equality and hash from a key.",null,null]],"paths":[[4,"Trivalent"],[3,"Cache"],[3,"Dag"],[3,"NDArray"],[3,"NDRange"],[3,"ViewMut"],[3,"ViewMutIter"],[3,"ViewIterMut"],[3,"FilterList"],[3,"ZipCopy"],[3,"PartialPermutations"],[3,"MultiHashMap"],[3,"VecSet"],[8,"Unwrap"],[8,"BuilderTrait"],[3,"RcStr"]]};
initSearch(searchIndex);
