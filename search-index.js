var N = null;var searchIndex = {};
searchIndex["telamon"]={"doc":"","items":[[0,"codegen","telamon","Helpers to generate code from an IR instance and fully specified decisions.",N,N],[3,"Dimension","telamon::codegen","An iteration dimension composed of one or mure fused dimensions.",N,N],[3,"InductionLevel","","An induction level associated to a dimension.",N,N],[12,"ind_var","","",0,N],[12,"increment","","",0,N],[12,"base","","",0,N],[3,"InductionVar","","An induction variable, composed of multiple induction variable levels.",N,N],[12,"id","","",1,N],[12,"value","","",1,N],[3,"Function","","A function ready to execute on a device, derived from a constrained IR instance.",N,N],[3,"InternalMemoryRegion","","A memory block allocated by the kernel.",N,N],[3,"Variable","","",N,N],[3,"Instruction","","An instruction to execute.",N,N],[3,"NameMap","","Maps variables to names.",N,N],[3,"Size","","The size of an iteration dimension. The size is of the form: `(factor * dividend_0 * dividend_1 * ...)) / divisor` where the reminder of the division is null.",N,N],[4,"Cfg","","Represents a CFG of the targeted device.",N,N],[13,"Root","","Represents the root node of the CFG.",2,N],[13,"Loop","","Represents a loop in the CFG.",2,N],[13,"Instruction","","Represents an instruction in the CFG.",2,N],[13,"Threads","","Defines the set of active thread dimensions.",2,N],[4,"ParamVal","","Represents the value of a parameter passed to the kernel by the host.",N,N],[13,"External","","A parameter given by the caller.",3,N],[13,"Size","","A tiled dimension size computed on the host.",3,N],[13,"GlobalMem","","A pointer to a global memory block, allocated by the wrapper.",3,N],[4,"ParamValKey","","Uniquely identifies a `ParamVal`.",N,N],[13,"External","","",4,N],[13,"Size","","",4,N],[13,"GlobalMem","","",4,N],[4,"AllocationScheme","","Indicates how is a memory block allocated.",N,N],[13,"Global","","",5,N],[13,"PrivatisedGlobal","","",5,N],[13,"Shared","","",5,N],[4,"Operand","","A value that can be named.",N,N],[13,"InductionLevel","","",6,N],[13,"Operand","","",6,N],[4,"MulMode","","",N,N],[13,"Wide","","",7,N],[13,"Low","","",7,N],[13,"High","","",7,N],[13,"Empty","","",7,N],[11,"dimensions","","Iterates over the dimensions of the `Cfg`.",2,[[["self"]],[""]]],[11,"instructions","","Iterates over the instructions of the `Cfg`.",2,[[["self"]],[""]]],[11,"induction_levels","","Iterates over the induction levels in the `Cfg`.",2,[[["self"]],[""]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",8,[[["self"],["formatter"]],["result"]]],[11,"id","","Returns the ID of the representant.",8,[[["self"]],["dimid"]]],[11,"kind","","Returns the kind of the dimension.",8,[[["self"]],["dimkind"]]],[11,"size","","Returns the size of the dimensions.",8,[[["self"]],["size"]]],[11,"dim_ids","","Returns the ids of the `ir::Dimensions` represented by this dimension.",8,[[["self"]],[""]]],[11,"induction_levels","","Returns the induction levels handled by this loop.",8,N],[11,"drain_induction_levels","","Gives the ownership on the induction levels computed by the dimension.",8,[[["self"]],["vec",["inductionlevel"]]]],[11,"merge_from","","Merge another `Dimension` into this one.",8,[[["self"],["self"]]]],[11,"host_values","","Returns the values to pass from the host to the device to implement `self`.",8,[[["self"],["searchspace"]],[""]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"t","","Returns the type of the value created by the induction level.",0,[[["self"]],["type"]]],[11,"host_values","","Returns the values to pass from the host to the device to implement `self`.",0,[[["self"],["searchspace"]],[""]]],[11,"host_values","","Returns the values to pass from the host to the device to implement `self`.",1,[[["self"],["searchspace"]],[""]]],[11,"build","","Creates a device `Function` from an IR instance.",9,[[["searchspace"]],["function"]]],[11,"thread_dims","","Returns the ordered list of thread dimensions.",9,N],[11,"block_dims","","Returns the ordered list of block dimensions.",9,N],[11,"variables","","Iterate on the function variables.",9,[[["self"]],[""]]],[11,"dimensions","","Iterates other all `codegen::Dimension`.",9,[[["self"]],[""]]],[11,"induction_vars","","Returns the list of induction variables.",9,N],[11,"num_threads","","Returns the total number of threads to allocate.",9,[[["self"]],["u32"]]],[11,"device_code_args","","Returns the values to pass from the host to the device.",9,[[["self"]],[""]]],[11,"cfg","","Returns the control flow graph.",9,[[["self"]],["cfg"]]],[11,"induction_levels","","Returns all the induction levels in the function.",9,[[["self"]],[""]]],[11,"mem_blocks","","Returns the memory blocks allocated by the function.",9,[[["self"]],[""]]],[11,"space","","Returns the underlying implementation space.",9,[[["self"]],["searchspace"]]],[11,"init_induction_levels","","Returns the induction levels computed at the beginning of the kernel. Levels must be computed in the provided order.",9,N],[11,"deref","","",9,N],[11,"from_operand","","Builds the `ParamVal` needed to implement an operand, if any.",3,[[["operand"],["searchspace"]],["option"]]],[11,"from_size","","Builds the `ParamVal` needed to get a size value, if any.",3,[[["size"]],["option"]]],[11,"t","","Returns the type of the parameter.",3,[[["self"]],["type"]]],[11,"is_pointer","","Indicates if the parameter is a pointer.",3,[[["self"]],["bool"]]],[11,"key","","Returns a unique identifier for the `ParamVal`.",3,[[["self"]],["paramvalkey"]]],[11,"eq","","",3,[[["self"],["paramval"]],["bool"]]],[11,"hash","","",3,[[["self"],["h"]]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result"]]],[11,"eq","","",4,[[["self"],["paramvalkey"]],["bool"]]],[11,"ne","","",4,[[["self"],["paramvalkey"]],["bool"]]],[11,"hash","","",4,N],[11,"clone","","",4,[[["self"]],["paramvalkey"]]],[11,"eq","","",5,[[["self"],["allocationscheme"]],["bool"]]],[11,"new","","Creates a new InternalMemoryRegion from an `ir::mem::Internal`.",10,[[["internalblock"],["option"],["searchspace"]],["self"]]],[11,"host_values","","Returns the value to pass from the host to the device to implement `self`.",10,N],[11,"id","","Returns the memory ID.",10,[[["self"]],["internalid"]]],[11,"alloc_scheme","","Indicates how is the memory block allocated.",10,[[["self"]],["allocationscheme"]]],[11,"alloc_size","","Generates the size of the memory to allocate.",10,[[["self"]],["size"]]],[11,"local_size","","Returns the size of the part of the allocated memory accessible by each thread.",10,[[["self"]],["size"]]],[11,"mem_space","","Returns the memory space the block is allocated in.",10,[[["self"]],["memspace"]]],[11,"ptr_type","","Returns the type of the pointer to the memory block.",10,[[["self"]],["type"]]],[11,"new","","",11,[[["variable"],["searchspace"]],["self"]]],[11,"id","","Returns the ID of the variable.",11,[[["self"]],["varid"]]],[11,"t","","Returns the type of the variable.",11,[[["self"]],["type"]]],[11,"new","","Creates a new `Instruction`.",12,[[["instruction"],["searchspace"]],["self"]]],[11,"id","","Returns the ID of the instruction.",12,[[["self"]],["instid"]]],[11,"host_values","","Returns the values to pass from the host to implement this instruction.",12,[[["self"],["searchspace"]],[""]]],[11,"t","","Returns the type of the instruction.",12,[[["self"]],["option",["type"]]]],[11,"operator","","Returns the operator computed by the instruction.",12,[[["self"]],["operator"]]],[11,"instantiation_dims","","Returns the dimensions on which to instantiate the instruction.",12,N],[11,"as_reduction","","Indicates if the instruction performs a reduction, in wich case it returns the instruction that initializes the reduction, the `DimMap` to readh it and the reduction dimensions.",12,[[["self"]],["option"]]],[11,"mem_flag","","Returns the memory flag of the intruction, if any.",12,[[["self"]],["option",["instflag"]]]],[11,"has_side_effects","","Indicates if the instruction has observable side effects.",12,[[["self"]],["bool"]]],[11,"clone","","",6,[[["self"]],["operand"]]],[11,"new","","Creates a new `NameMap`.",13,[[["function"],["namer"]],["self"]]],[11,"gen_name","","Generates a variable of the given `Type`.",13,[[["self"],["type"]],["string"]]],[11,"gen_loop_id","","Generates an ID for a loop.",13,[[["self"]],["u32"]]],[11,"name","","",13,[[["self"],["operand"]],["cow",["str"]]]],[11,"name_op","","Asigns a name to an operand.",13,[[["self"],["operand"]],["cow",["str"]]]],[11,"name_inst","","Returns the name of the instruction.",13,[[["self"],["instid"]],["str"]]],[11,"indexed_inst_name","","",13,N],[11,"indexed_op_name","","",13,N],[11,"name_index","","Returns the name of an index.",13,[[["self"],["dimid"]],["str"]]],[11,"set_current_index","","Set the current index of an unrolled dimension.",13,[[["self"],["dimension"],["u32"]]]],[11,"unset_current_index","","Unset the current index of an unrolled dimension.",13,[[["self"],["dimension"]]]],[11,"name_param","","Returns the name of a variable representing a parameter.",13,[[["self"],["paramvalkey"]],["cow",["str"]]]],[11,"name_param_val","","Returns the name of a variable representing a parameter value.",13,[[["self"],["paramvalkey"]],["cow",["str"]]]],[11,"name_addr","","Returns the name of the address of a memory block.",13,[[["self"],["internalid"]],["cow",["str"]]]],[11,"name_induction_var","","Assigns a name to an induction variable.",13,[[["self"],["indvarid"],["option",["dimid"]]],["cow",["str"]]]],[11,"declare_size_cast","","Declares a size cast. Returns the name of the variable only if a new variable was allcoated.",13,[[["self"],["size"],["type"]],["option",["string"]]]],[11,"name_size","","Assigns a name to a size.",13,[[["self"],["size"],["type"]],["cow",["str"]]]],[11,"side_effect_guard","","Returns the side-effect guard, if any is set.",13,[[["self"]],["option",["rcstr"]]]],[11,"set_side_effect_guard","","Sets the predicate to use in front of side-effect instruction.",13,[[["self"],["option",["rcstr"]]]]],[11,"clone","","",7,[[["self"]],["mulmode"]]],[11,"fmt","","",7,[[["self"],["formatter"]],["result"]]],[11,"eq","","",7,[[["self"],["mulmode"]],["bool"]]],[11,"clone","","",14,[[["self"]],["size"]]],[11,"fmt","","",14,[[["self"],["formatter"]],["result"]]],[11,"hash","","",14,N],[11,"eq","","",14,[[["self"],["size"]],["bool"]]],[11,"ne","","",14,[[["self"],["size"]],["bool"]]],[11,"new","","Creates a new 'Size'.",14,[[["u32"],["vec",["parameter"]],["u32"]],["self"]]],[11,"from_ir","","Converts an `ir::Size` to `Self`.",14,[[["partialsize"],["searchspace"]],["self"]]],[11,"as_int","","Returns the size of a dimension if it is staticaly known.",14,[[["self"]],["option",["u32"]]]],[11,"dividend","","Returns the dividends.",14,N],[11,"divisor","","Returns the divisor.",14,[[["self"]],["u32"]]],[11,"factor","","Returns the factor.",14,[[["self"]],["u32"]]],[11,"mul_assign","","",14,[[["self"],["size"]]]],[8,"Namer","","Assign names to variables.",N,N],[10,"name","","Provides a name for a variable of the given type.",15,[[["self"],["type"]],["string"]]],[10,"name_param","","Generates a name for a parameter.",15,[[["self"],["paramvalkey"]],["string"]]],[10,"name_float","","Provides a name for a floating point constant.",15,[[["self"],["ratio"],["u16"]],["string"]]],[10,"name_int","","Provides a name for an integer constant.",15,[[["self"],["bigint"],["u16"]],["string"]]],[8,"Printer","","",N,N],[10,"get_int","","Get the representation of an integer in the target language.",16,[[["u32"]],["string"]]],[10,"print_binop","","Print return_id = lhs op rhs",16,N],[10,"print_unary_op","","Print return_id = op",16,N],[10,"print_mul","","Print return_id = op1 * op2",16,N],[10,"print_mad","","Print return_id = mlhs * mrhs + arhs",16,N],[10,"print_ld","","Print return_id = load [addr]",16,N],[10,"print_st","","Print store val [addr]",16,N],[10,"print_label","","print a label where to jump",16,[[["self"],["str"]]]],[10,"print_cond_jump","","Print if (cond) jump label(label_id)",16,[[["self"],["str"],["str"]]]],[10,"print_sync","","Print wait on all threads",16,[[["self"]]]],[10,"name_operand","","Name an operand, vectorized on the given dimensions.",16,N],[10,"name_inst","","Names an instruction, vectorized on the given dimensions.",16,N],[11,"print_lt_int","","Prints a scalar less-than on integers.",16,[[["self"],["type"],["str"],["str"],["str"]]]],[11,"print_equals","","Prints a scalar equals instruction.",16,[[["self"],["type"],["str"],["str"],["str"]]]],[11,"print_add_int","","Prints a scalar addition on integers.",16,[[["self"],["type"],["str"],["str"],["str"]]]],[11,"print_and","","Prints an AND operation.",16,[[["self"],["type"],["str"],["str"],["str"]]]],[11,"print_move","","Prints a move instruction.",16,[[["self"],["type"],["str"],["str"]]]],[11,"cfg_vec","","",16,N],[11,"cfg","","Prints a cfg.",16,[[["self"],["function"],["cfg"],["namemap"]]]],[11,"parallel_induction_level","","Prints a multiplicative induction var level.",16,[[["self"],["inductionlevel"],["namemap"]]]],[11,"enable_threads","","Change the side-effect guards so that only the specified threads are enabled.",16,N],[11,"gen_loop","","Prints a Loop",16,N],[11,"standard_loop","","Prints a classic loop - that is, a sequential loop with an index and a jump to the beginning at the end of the block",16,N],[11,"unroll_loop","","Prints an unroll loop - loop without jumps",16,N],[11,"privatise_global_block","","",16,[[["self"],["internalmemoryregion"],["namemap"],["function"]]]],[11,"inst","","Prints an instruction.",16,N],[11,"lower_type","","",16,[[["type"],["function"]],["type"]]],[11,"mul_mode","","",16,[[["type"],["type"]],["mulmode"]]],[0,"helper","telamon","Helper functions to build an IR instance.",N,N],[3,"Builder","telamon::helper","Helper to build a `Function`.",N,N],[3,"Reduce","","Helper to build `Reduce` operands.",N,N],[12,"0","","",17,N],[3,"TmpArray","","Helper to build dim maps that can be lowered to temporary memory.",N,N],[12,"0","","",18,N],[3,"SignatureBuilder","","Helper struct to build a `Signature`.",N,N],[3,"LogicalDim","","A groups of dimensions that act as a single logical dimension.",N,N],[3,"TilingPattern","","Indicates how a logical dimension should be tiled.",N,N],[11,"new","","Creates a new `Builder` for a `Function` with the given signature.",19,[[["signature"],["device"]],["builder"]]],[11,"get","","Returns the function created by the builder",19,[[["self"]],["searchspace"]]],[11,"get_clone","","Returns the function created by the builder",19,[[["self"]],["searchspace"]]],[11,"binop","","Creates a binary operator.",19,[[["self"],["binop"],["autooperand"],["autooperand"]],["instid"]]],[11,"add","","Adds an `Add` instruction to the fuction.",19,[[["self"],["autooperand"],["autooperand"]],["instid"]]],[11,"sub","","Adds a `Sub` instruction to the function.",19,[[["self"],["autooperand"],["autooperand"]],["instid"]]],[11,"mul","","Adds a `Mul` instruction to the function. Defaults to low mode.",19,[[["self"],["autooperand"],["autooperand"]],["instid"]]],[11,"mul_ex","","Adds a 'Mul` instruction with a wide mode to the function.",19,[[["self"],["autooperand"],["autooperand"],["type"]],["instid"]]],[11,"mad","","Adds a `Mad` or `Fma` instruction to the function. Defaults to low or wide mode depending on the operand types.",19,[[["self"],["autooperand"],["autooperand"],["autooperand"]],["instid"]]],[11,"div","","Adds a `Div` instruction to the fuction.",19,[[["self"],["autooperand"],["autooperand"]],["instid"]]],[11,"mov","","Adds a `Mov` instruction to the function.",19,[[["self"],["autooperand"]],["instid"]]],[11,"ld","","Adds a coherent load from global memory instruction to the function.",19,[[["self"],["type"],["autooperand"],["accesspattern"]],["instid"]]],[11,"ld_nc","","Adds a non-coherent load from global memory instruction to the function.",19,[[["self"],["type"],["autooperand"],["accesspattern"]],["instid"]]],[11,"ld_ex","","Adds a load instruction with the given flags and memory block.",19,[[["self"],["type"],["autooperand"],["accesspattern"],["instflag"]],["instid"]]],[11,"st","","Adds a store instruction.",19,[[["self"],["autooperand"],["autooperand"],["accesspattern"]],["instid"]]],[11,"st_ex","","Adds a store instruction with the given flags and memory block.",19,[[["self"],["autooperand"],["autooperand"],["bool"],["accesspattern"],["instflag"]],["instid"]]],[11,"cast","","Adds a cast instruction to the given type.",19,[[["self"],["autooperand"],["type"]],["instid"]]],[11,"order","","Restricts the order between two basic blocks. Does not restricts LINK and NPACK flags.",19,[[["self"],["metastatement"],["metastatement"],["order"]]]],[11,"create_inst_variable","","",19,[[["self"],["instid"]],["varid"]]],[11,"action","","Applies an action on the function.",19,[[["self"],["action"]]]],[11,"open_dim","","Opens a new dimension.",19,[[["self"],["size"]],["logicaldim"]]],[11,"open_dim_ex","","Opens a nest of new dimension with the given kinds and sizes.",19,[[["self"],["size"],["dimkind"]],["logicaldim"]]],[11,"open_tiled_dim","","Open multiple dimensions to represent a tiled dimension.",19,[[["self"],["size"],["tilingpattern"]],["logicaldim"]]],[11,"open_mapped_dim","","Opens a new dimension mapped to an existing one.",19,[[["self"],["logicaldim"]],["logicaldim"]]],[11,"reopen_dim","","Opens an existing dimension.",19,[[["self"],["logicaldim"]]]],[11,"reopen_mapped_dim","","Opens an existing dimension and maps it to another one. The dimension mapped to is closed if needed.",19,[[["self"],["logicaldim"],["logicaldim"]]]],[11,"close_dim","","Closes a dimension.",19,[[["self"],["logicaldim"]]]],[11,"cst_size","","Returns a constant size.",19,[[["self"],["u32"]],["size"]]],[11,"param_size","","Returns a parameter size.",19,[[["self"],["str"],["u32"]],["size"]]],[11,"allocate_shared","","Allocates a memory block in shared memory.",19,[[["self"],["u32"]],["internalid"]]],[11,"allocate","","Allocates a memory block.",19,[[["self"],["u32"],["bool"]],["internalid"]]],[11,"unknown_access_pattern","","Generates an access paterns with all the strides unknown on the opened dimensions.",19,[[["self"],["memid"]],["accesspattern"]]],[11,"tensor_access","","Builds both an induction variable for a tensor memory access and the corresponding access pattern.",19,N],[11,"tensor_access_pattern","","Generates the access pattern corresponding to accessing a tensor of the given type.",19,[[["self"],["memid"],["vec"]],["accesspattern"]]],[11,"induction_var","","Builds an induction variable.",19,[[["self"],["autooperand"],["vec"]],["indvarid"]]],[11,"dim_map","","Creates a dim-map operand.",19,N],[11,"find_param","","Finds a paramter given its name.",19,[[["self"],["str"]],["parameter"]]],[11,"get","","",17,[[["self"],["builder"]],["operand"]]],[11,"get","","",18,[[["self"],["builder"]],["operand"]]],[11,"get","","",20,[[["self"],["builder"]],["operand"]]],[11,"new","","Creates a new builder for a function with the given name.",21,[[["str"],["am"]],["self"]]],[11,"scalar","","Creates a new parameter and binds it to the given value.",21,[[["self"],["str"],["t"]]]],[11,"max_size","","Creates a new `i32` paramter and returns a size equals to this parameter. Sets the maximal size to the current size.",21,[[["self"],["str"],["u32"]],["dimsize"]]],[11,"array","","Creates a new parameter and binds it to a freshly allocated an array.",21,N],[11,"tensor","","Allocates an n-dimensional array.",21,[[["self"],["str"],["vec",["dimsize"]],["bool"]],["tensor"]]],[11,"get","","Returns the `Signature` created by the builder.",21,[[["self"]],["signature"]]],[11,"context","","Returns the underlying context.",21,[[["self"]],["am"]]],[0,"tensor","","Utilities to allocate and operate on tensors.",N,N],[3,"DimSize","telamon::helper::tensor","A dimension size, before tiling.",N,N],[12,"factor","","",22,N],[12,"params","","",22,N],[12,"max_size","","",22,N],[3,"TensorBuilder","","An helper to build a tensor.",N,N],[3,"Tensor","","A tensor allocated in main memory.",N,N],[3,"VirtualTensor","","A tensor loaded in registers.",N,N],[11,"clone","","",22,[[["self"]],["dimsize"]]],[11,"into_ir_size","","Convert the size into the size type used by the IR.",22,[[["self"],["builder"]],["size"]]],[11,"eval","","Converts the size into a numerical value for a given context.",22,[[["self"],["context"]],["u32"]]],[11,"new_param","","Creates a new size equals to the given parameter.",22,[[["str"],["u32"]],["self"]]],[11,"from","","",22,[[["u32"]],["self"]]],[11,"new","","Start building a `Tensor` with the given logical layout.",23,[[["str"],["vec",["dimsize"]]],["self"]]],[11,"transpose","","Swap two dimensions in the memory layout of the tensor. Keeps the logical layout untouched.",23,[[["self"],["usize"],["usize"]],["self"]]],[11,"stride_dim","","Removes a logical dimension but keeps it in the storage.",23,[[["self"],["usize"]],["self"]]],[11,"enable_writes","","Allows writing to the tensor.",23,[[["self"]],["self"]]],[11,"finish","","Builds the `Tensor`.",23,[[["self"],["signaturebuilder"]],["tensor"]]],[11,"new","","Allocates a new `Tensor` in the context.",24,[[["str"],["vec",["dimsize"]],["bool"],["memid"],["arc",["arrayargument"]]],["self"]]],[11,"load","","Creates a `VirtualTensor` that contains the values of `self`, loaded in registers.",24,[[["self"],["vec",["tilingpattern"]],["builder"]],["virtualtensor"]]],[11,"read_to_host","","Reads the tensor value in the context and copies it on the host.",24,[[["self"],["context"]],["arrayd"]]],[11,"new","","Creates a new `VirtualTensor`.",25,[[["instid"],["vec",["logicaldim"]]],["self"]]],[11,"dim_map","","Creates an operand that yeilds the values of the tensor in the given loop nest.",25,N],[11,"store","","Stores the `VirtualTensor` in memory. Stores contiguously without taking the layout of the target tensor into account.",25,[[["self"],["tensor"],["builder"]],["virtualtensor"]]],[11,"inst","","Returns the underlying instruction.",25,[[["self"]],["instid"]]],[11,"index","","",25,N],[8,"AutoOperand","telamon::helper","Represents values that can be turned into an `Operand`.",N,N],[10,"get","","Returns the corresponding `Operand`.",26,[[["self"],["builder"]],["operand"]]],[8,"MetaStatement","","A logical basic block, that can actually be implemented by multiple ones.",N,N],[10,"ids","","Returns the ids on the underlying basic blocks.",27,[[["self"]],["box",["iterator"]]]],[11,"clone","","",20,[[["self"]],["logicaldim"]]],[11,"iter","","Iterates on the reals IDs, from the outermost to the innermost.",20,[[["self"]],[""]]],[11,"id","","Returns the id of the logical dimension.",20,[[["self"]],["logicaldimid"]]],[11,"index","","",20,[[["self"],["usize"]],["dimid"]]],[11,"ids","","",20,[[["self"]],["box",["iterator"]]]],[11,"clone","","",28,[[["self"]],["tilingpattern"]]],[11,"fmt","","",28,[[["self"],["formatter"]],["result"]]],[11,"new_fixed","","Creates a new fixed tiling pattern, with dimensions of the given sizes.",28,N],[11,"infer_pattern","","Infer a tiling pattern for a dimension whose size is a multiple of `gcd_size`. `max_tile_sizes` limits the maximal tile sizes for each tiling dimension.",28,N],[11,"default","","",28,[[],["self"]]],[0,"device","telamon","Code generation and candidate evaluation for specific targets.",N,N],[4,"EvalMode","telamon::device","Indicates how evaluation should be performed.",N,N],[13,"FindBest","","Find the best candidate, skip bad candidates and allow optimizations.",29,N],[13,"TestEval","","Test the evaluation function, same as `FindBest` but do not skip candidates.",29,N],[13,"TestBound","","Test the performance model, do not skip candidates and do not optimize.",29,N],[5,"read_array","","Copies the array to the host, interpreting it as an array of `T`.",N,[[["arrayargument"]],["vec"]]],[5,"write_array","","Copies an values to the device array from the host array given as argument.",N,N],[0,"cuda","","Defines the CUDA target.",N,N],[3,"Array","telamon::device::cuda","An array on the CUDA device.",N,N],[3,"Context","","A CUDA evaluation context.",N,N],[3,"Gpu","","Represents CUDA GPUs.",N,N],[12,"name","","The name of the GPU.",30,N],[12,"sm_major","","The compute capability major number.",30,N],[12,"sm_minor","","The compute capability minor number.",30,N],[12,"addr_size","","The size of pointers.",30,N],[12,"shared_mem_per_smx","","The amount of shared memory per SMX.",30,N],[12,"shared_mem_per_block","","The amount of shared memory available per block.",30,N],[12,"allow_nc_load","","`true` when non-coherent loads are enabled on the GPU.",30,N],[12,"allow_l1_for_global_mem","","`ture` when L1 caching is enabled for global memory accesses.",30,N],[12,"wrap_size","","The size of a wrap.",30,N],[12,"thread_per_smx","","The maximal number of resident thread per SMX.",30,N],[12,"l1_cache_size","","The size in bytes of the L1 cache.",30,N],[12,"l1_cache_line","","The size in bytes of a L1 cache line.",30,N],[12,"l2_cache_size","","The size in bytes of the L2 cache.",30,N],[12,"l2_cache_line","","The size in bytes of a L2 cache line.",30,N],[12,"load_l2_latency","","Latency of an L2 access.",30,N],[12,"load_ram_latency","","Latency of a RAM access.",30,N],[12,"shared_bank_stride","","The stride at wich replays occur in shared memory.",30,N],[12,"load_shared_latency","","Latency of a shared memory access.",30,N],[12,"num_smx","","The number of SMX in the GPU.",30,N],[12,"max_block_per_smx","","Maximum number of block per SMX.",30,N],[12,"smx_clock","","The clock of an SMX, in GHz.",30,N],[12,"thread_rates","","Amount of processing power available on a single thread.",30,N],[12,"smx_rates","","Amount of processing power available on a single SMX.",30,N],[12,"gpu_rates","","Amount of processing power available on the whole GPU.",30,N],[12,"add_f32_inst","","",30,N],[12,"add_f64_inst","","",30,N],[12,"add_i32_inst","","",30,N],[12,"add_i64_inst","","",30,N],[12,"mul_f32_inst","","",30,N],[12,"mul_f64_inst","","",30,N],[12,"mul_i32_inst","","",30,N],[12,"mul_i64_inst","","",30,N],[12,"mul_wide_inst","","",30,N],[12,"mad_f32_inst","","",30,N],[12,"mad_f64_inst","","",30,N],[12,"mad_i32_inst","","",30,N],[12,"mad_i64_inst","","",30,N],[12,"mad_wide_inst","","",30,N],[12,"div_f32_inst","","",30,N],[12,"div_f64_inst","","",30,N],[12,"div_i32_inst","","",30,N],[12,"div_i64_inst","","",30,N],[12,"syncthread_inst","","",30,N],[12,"loop_init_overhead","","Overhead for entring the loop.",30,N],[12,"loop_iter_overhead","","Overhead for a single iteration of the loop.",30,N],[12,"loop_end_latency","","Latency for exiting the loop.",30,N],[3,"InstDesc","","Specifies the performance parameters of an instruction.",N,N],[12,"latency","","The latency of the instruction.",31,N],[12,"issue","","The number of instruction to issue.",31,N],[12,"alu","","The number of instruction on the ALUs.",31,N],[12,"sync","","The number of syncthread units used.",31,N],[12,"mem","","The number of instruction on Load/Store units.",31,N],[12,"l1_lines_from_l2","","The number of L1 cache lines that are fetched from the L2.",31,N],[12,"l2_lines_read","","The number of L2 cache lines read.",31,N],[12,"l2_lines_stored","","Number of l2 cache lines stored.",31,N],[12,"ram_bw","","The ram bandwidth used.",31,N],[3,"Kernel","","An IR instance compiled into a CUDA kernel.",N,N],[3,"CudaPrinter","","",N,N],[4,"Executor","","Interface with a CUDA device.",N,N],[4,"JITDaemon","","A process that compiles PTX in a separate process.",N,N],[11,"clone","","",32,[[["self"]],["array"]]],[11,"read_i8","","",32,[[["self"]],["vec",["i8"]]]],[11,"write_i8","","",32,N],[11,"try_init","","Initializes the `Executor`.",33,[[],["result",["executor","initerror"]]]],[11,"spawn_jit","","Spawns a `JITDaemon`.",33,[[["self"],["usize"]],["jitdaemon"]]],[11,"allocate_array","","Allocates an array on the CUDA device.",33,[[["self"],["usize"]],["array"]]],[11,"device_name","","Returns the name of the device.",33,[[["self"]],["string"]]],[11,"compile_ptx","","Compiles a PTX module.",33,[[["self"],["str"],["usize"]],["module"]]],[11,"compile_remote","","Compiles a PTX module using a separate process.",33,[[["self"],["jitdaemon"],["str"]],["module"]]],[11,"new","","Create a new evaluation context. The GPU model if infered.",34,[[["executor"]],["context"]]],[11,"from_gpu","","Creates a context from the given GPU.",34,[[["gpu"],["executor"]],["self"]]],[11,"gpu","","Returns the GPU description.",34,[[["self"]],["gpu"]]],[11,"executor","","Returns the execution queue.",34,[[["self"]],["executor"]]],[11,"get_param","","Returns a parameter given its name.",34,[[["self"],["str"]],["argument"]]],[11,"bind_param","","Binds a parameter to the gien name.",34,[[["self"],["string"],["arc",["argument"]]]]],[11,"bind_scalar","","",34,[[["self"],["parameter"],["s"]]]],[11,"bind_array","","",34,[[["self"],["parameter"],["usize"]],["arc"]]],[11,"device","","",34,[[["self"]],["device"]]],[11,"param_as_size","","",34,[[["self"],["str"]],["option",["u32"]]]],[11,"evaluate","","",34,[[["self"],["function"],["evalmode"]],["result",["f64"]]]],[11,"benchmark","","",34,[[["self"],["function"],["usize"]],["vec",["f64"]]]],[11,"async_eval","","",34,[[["self"],["usize"],["evalmode"],["fn"]]]],[11,"default","","",31,[[],["instdesc"]]],[11,"clone","","",31,[[["self"]],["instdesc"]]],[11,"fmt","","",31,[[["self"],["formatter"]],["result"]]],[11,"into","","",31,[[["self"]],["hwpressure"]]],[11,"clone","","",30,[[["self"]],["gpu"]]],[11,"from_executor","","Returns the GPU model corresponding to `name.",30,[[["executor"]],["gpu"]]],[11,"dummy","","Creates a dummy GPU, to use for tests and benchmarks without evaluation.",30,[[],["self"]]],[11,"print_ptx","","Returns the PTX code for a Function.",30,[[["self"],["function"]],["string"]]],[11,"blocks_per_smx","","Computes the number of blocks that can fit in an smx.",30,[[["self"],["searchspace"]],["u32"]]],[11,"print","","",30,[[["self"],["function"],["write"]]]],[11,"check_type","","",30,[[["self"],["type"]],["result",["typeerror"]]]],[11,"max_block_dims","","",30,[[["self"]],["u32"]]],[11,"max_inner_block_size","","",30,[[["self"]],["u32"]]],[11,"max_threads","","",30,[[["self"]],["u32"]]],[11,"max_unrolling","","",30,[[["self"]],["u32"]]],[11,"vectorization_factors","","",30,N],[11,"shared_mem","","",30,[[["self"]],["u32"]]],[11,"supports_nc_access","","",30,[[["self"]],["bool"]]],[11,"supports_l1_access","","",30,[[["self"]],["bool"]]],[11,"supports_l2_access","","",30,[[["self"]],["bool"]]],[11,"name","","",30,[[["self"]],["str"]]],[11,"lower_type","","",30,[[["self"],["type"],["searchspace"]],["option",["type"]]]],[11,"hw_pressure","","",30,[[["self"],["searchspace"],["hashmap"],["hashmap"],["statement"],["context"]],["hwpressure"]]],[11,"loop_iter_pressure","","",30,N],[11,"thread_rates","","",30,[[["self"]],["hwpressure"]]],[11,"block_rates","","",30,[[["self"]],["hwpressure"]]],[11,"total_rates","","",30,[[["self"]],["hwpressure"]]],[11,"bottlenecks","","",30,N],[11,"block_parallelism","","",30,[[["self"],["searchspace"]],["u32"]]],[11,"additive_indvar_pressure","","",30,[[["self"],["type"]],["hwpressure"]]],[11,"multiplicative_indvar_pressure","","",30,[[["self"],["type"]],["hwpressure"]]],[11,"add_block_overhead","","",30,[[["self"],["factorrange"],["factorrange"],["range"],["hwpressure"]]]],[11,"compile","","Compiles a device function.",35,[[["function"],["gpu"],["executor"],["usize"]],["self"]]],[11,"compile_remote","","Compiles a device function, using a separate process.",35,[[["function"],["gpu"],["executor"],["jitdaemon"]],["self"]]],[11,"evaluate","","Runs a kernel and returns the number of cycles it takes to execute in cycles.",35,[[["self"],["context"]],["result",["u64"]]]],[11,"evaluate_real","","Runs a kernel and returns the number of cycles it takes to execute in nanoseconds, measured using cuda event rather than hardware counters.",35,[[["self"],["context"],["usize"]],["vec",["f64"]]]],[11,"gen_thunk","","Generates a Thunk than can then be run on the GPU.",35,[[["self"],["context"]],["thunk"]]],[11,"default","","",36,[[],["cudaprinter"]]],[11,"function","","Prints a `Function`.",36,[[["self"],["function"],["gpu"]],["string"]]],[11,"host_function","","",36,[[["self"],["function"],["gpu"],["write"]]]],[11,"get_int","","Get a proper string representation of an integer in target language",36,[[["u32"]],["string"]]],[11,"print_binop","","Print result = op1 op op2",36,N],[11,"print_unary_op","","Prints result = operator operand.",36,N],[11,"print_mul","","Print result = op1 * op2",36,N],[11,"print_mad","","Print result = mlhs * mrhs + arhs",36,N],[11,"print_ld","","Print result = load [addr]",36,N],[11,"print_st","","Print store val [addr]",36,N],[11,"print_label","","print a label where to jump",36,[[["self"],["str"]]]],[11,"print_cond_jump","","Print if (cond) jump label(label_id)",36,[[["self"],["str"],["str"]]]],[11,"print_sync","","Print wait on all threads",36,[[["self"]]]],[11,"name_operand","","",36,N],[11,"name_inst","","",36,N],[0,"x86","telamon::device","Defines the CPU target.",N,N],[3,"Context","telamon::device::x86","A CPU evaluation context.",N,N],[3,"Cpu","","Represents CUDA GPUs.",N,N],[12,"name","","The name of the CPU.",37,N],[3,"X86printer","","",N,N],[11,"get_param","","Returns a parameter given its name.",38,[[["self"],["str"]],["argument"]]],[11,"default","","Create a new evaluation context.",38,[[],["context"]]],[11,"bind_scalar","","",38,[[["self"],["parameter"],["s"]]]],[11,"bind_array","","",38,[[["self"],["parameter"],["usize"]],["arc"]]],[11,"device","","",38,[[["self"]],["device"]]],[11,"param_as_size","","",38,[[["self"],["str"]],["option",["u32"]]]],[11,"evaluate","","Evaluation in sequential mode",38,[[["self"],["function"],["evalmode"]],["result",["f64"]]]],[11,"benchmark","","returns a vec containing num_sample runs of function_evaluate",38,[[["self"],["function"],["usize"]],["vec",["f64"]]]],[11,"async_eval","","",38,[[["self"],["usize"],["evalmode"],["fn"]]]],[11,"clone","","",37,[[["self"]],["cpu"]]],[11,"dummy_cpu","","",37,[[],["self"]]],[11,"print","","",37,[[["self"],["function"],["write"]]]],[11,"check_type","","",37,[[["self"],["type"]],["result",["typeerror"]]]],[11,"max_block_dims","","",37,[[["self"]],["u32"]]],[11,"max_inner_block_size","","",37,[[["self"]],["u32"]]],[11,"max_threads","","",37,[[["self"]],["u32"]]],[11,"max_unrolling","","",37,[[["self"]],["u32"]]],[11,"vectorization_factors","","",37,N],[11,"shared_mem","","",37,[[["self"]],["u32"]]],[11,"supports_nc_access","","",37,[[["self"]],["bool"]]],[11,"supports_l1_access","","",37,[[["self"]],["bool"]]],[11,"supports_l2_access","","",37,[[["self"]],["bool"]]],[11,"name","","",37,[[["self"]],["str"]]],[11,"add_block_overhead","","",37,[[["self"],["factorrange"],["factorrange"],["range"],["hwpressure"]]]],[11,"lower_type","","",37,[[["self"],["type"],["searchspace"]],["option",["type"]]]],[11,"hw_pressure","","",37,[[["self"],["searchspace"],["hashmap"],["hashmap"],["statement"],["context"]],["hwpressure"]]],[11,"loop_iter_pressure","","",37,N],[11,"thread_rates","","",37,[[["self"]],["hwpressure"]]],[11,"block_rates","","",37,[[["self"]],["hwpressure"]]],[11,"total_rates","","",37,[[["self"]],["hwpressure"]]],[11,"bottlenecks","","",37,N],[11,"block_parallelism","","",37,[[["self"],["searchspace"]],["u32"]]],[11,"additive_indvar_pressure","","",37,[[["self"],["type"]],["hwpressure"]]],[11,"multiplicative_indvar_pressure","","",37,[[["self"],["type"]],["hwpressure"]]],[11,"default","","",39,[[],["x86printer"]]],[11,"function","","Prints a `Function`.",39,[[["self"],["function"]],["string"]]],[11,"wrapper_function","","wrap the kernel call into a function with a fixed interface",39,[[["self"],["function"]],["string"]]],[11,"get_int","","",39,[[["u32"]],["string"]]],[11,"print_binop","","",39,N],[11,"print_unary_op","","",39,N],[11,"print_mul","","",39,N],[11,"print_mad","","",39,N],[11,"print_ld","","",39,N],[11,"print_st","","",39,N],[11,"print_label","","",39,[[["self"],["str"]]]],[11,"print_cond_jump","","",39,[[["self"],["str"],["str"]]]],[11,"print_sync","","",39,[[["self"]]]],[11,"name_operand","","",39,N],[11,"name_inst","","",39,N],[11,"clone","telamon::device","",29,[[["self"]],["evalmode"]]],[11,"fmt","","",29,[[["self"],["formatter"]],["result"]]],[11,"eq","","",29,[[["self"],["evalmode"]],["bool"]]],[11,"skip_bad_candidates","","Indicates if candidates with a bound above the cut can be skipped.",29,[[["self"]],["bool"]]],[6,"AsyncCallback","","A callback that is called after evaluating a kernel.",N,N],[8,"ArrayArgument","","Represents an array on the device.",N,N],[10,"read_i8","","Copies the array to the host as a vector of bytes.",40,[[["self"]],["vec",["i8"]]]],[10,"write_i8","","Copies an array to the device from a slice of bytes.",40,N],[8,"ScalarArgument","","Represents a value that can be used as a `Function` argument. Must ensures the type is a scalar and does not contains any reference.",N,N],[11,"as_size","","Returns the argument interpreted as an iteration dimension size, if applicable.",41,[[["self"]],["option",["u32"]]]],[10,"t","","Returns the type of the argument.",41,[[],["type"]]],[10,"raw_ptr","","Returns a raw pointer to the object.",41,N],[10,"as_operand","","Returns an operand holding the argument value as a constant.",41,[[["self"]],["operand"]]],[10,"gen_random","","Generates a random instance of the argument type.",41,[[["r"]],["self"]]],[8,"ArgMap","","Binds the argument names to their values.",N,N],[16,"Array","","",42,N],[10,"bind_scalar","","Binds a parameter to a given value.",42,[[["self"],["parameter"],["s"]]]],[10,"bind_array","","Allocates an array of the given size in bytes.",42,[[["self"],["parameter"],["usize"]],["arc"]]],[8,"AsyncEvaluator","","An evaluation context that runs kernels asynchronously on the target device.",N,N],[10,"add_kernel","","Add a kernel to evaluate.",43,[[["self"],["candidate"],["asynccallback"]]]],[8,"Context","","Describes the context for which a function must be optimized.",N,N],[10,"device","","Returns the description of the device the code runs on.",44,[[["self"]],["device"]]],[10,"evaluate","","Returns the execution time of a fully specified implementation in nanoseconds.",44,[[["self"],["function"],["evalmode"]],["result",["f64"]]]],[10,"benchmark","","Compiles and benchmarks a functions. As opposed to `Self::evaluate`, the measured time contains potential startup times.",44,[[["self"],["function"],["usize"]],["vec",["f64"]]]],[10,"async_eval","","Calls the `inner` closure in parallel, and gives it a pointer to an `AsyncEvaluator` to evaluate candidates in the context. `skip_bad_bounds` indicates than candidates whose bound is aboive the best candidate should be skiped.",44,[[["self"],["usize"],["evalmode"],["fn"]]]],[10,"param_as_size","","Returns a parameter interpreted as a size, if possible.",44,[[["self"],["str"]],["option",["u32"]]]],[11,"eval_size","","Evaluate a size.",44,[[["self"],["size"]],["u32"]]],[8,"Device","","Holds the specifications of a target.",N,N],[10,"print","","Prints the code corresponding to a device `Function`.",45,[[["self"],["function"],["write"]]]],[10,"check_type","","Indicates if a `Type` can be implemented on the device.",45,[[["self"],["type"]],["result",["typeerror"]]]],[10,"max_block_dims","","Returns the maximal number of block dimensions.",45,[[["self"]],["u32"]]],[10,"max_inner_block_size","","The maximal size inner block dimensions can have.",45,[[["self"]],["u32"]]],[10,"max_threads","","Returns the maximal number of threads.",45,[[["self"]],["u32"]]],[10,"max_unrolling","","Returns the maximal unrolling factor.",45,[[["self"]],["u32"]]],[10,"vectorization_factors","","Indicates the valid vectorization factors for the given operator, on the given dimension.",45,N],[10,"shared_mem","","Returns the amount of shared memory available for each thread block.",45,[[["self"]],["u32"]]],[10,"supports_nc_access","","Indicates if the device supports non-coherent memory accesses.",45,[[["self"]],["bool"]]],[10,"supports_l1_access","","Indicates if the device supports L1 for global memory accesses.",45,[[["self"]],["bool"]]],[10,"supports_l2_access","","Indicates if the device supports L2 for global memory accesses.",45,[[["self"]],["bool"]]],[10,"name","","Returns the name of the device.",45,[[["self"]],["str"]]],[10,"hw_pressure","","Returns the pressure cause by a `Statement`. For a dimension, returns the pressure for the full loop execution.",45,[[["self"],["searchspace"],["hashmap"],["hashmap"],["statement"],["context"]],["hwpressure"]]],[10,"loop_iter_pressure","","Returns the pressure produced by a single iteration of a loop and the latency overhead of iterations.",45,N],[10,"thread_rates","","Returns the processing rates of a single thread, in units/ns",45,[[["self"]],["hwpressure"]]],[10,"block_rates","","Returns the processing rates of a single block, in units/ns.",45,[[["self"]],["hwpressure"]]],[10,"total_rates","","Returns the processing rates of the whole accelerator un units/ns.",45,[[["self"]],["hwpressure"]]],[10,"bottlenecks","","Returns the names of potential bottlenecks.",45,N],[10,"block_parallelism","","Returns the number of blocks that can be executed in parallel on the device.",45,[[["self"],["searchspace"]],["u32"]]],[10,"additive_indvar_pressure","","Returns the pressure caused by an additive induction variable level.",45,[[["self"],["type"]],["hwpressure"]]],[10,"multiplicative_indvar_pressure","","Returns the pressure caused by a multiplicative induction variable level.",45,[[["self"],["type"]],["hwpressure"]]],[10,"add_block_overhead","","Adds the overhead (per instance) due to partial wraps and predicated dimensions to the pressure. If the instruction is not predicated, `predicated_dims_size` should be `1`.",45,[[["self"],["factorrange"],["factorrange"],["range"],["hwpressure"]]]],[10,"lower_type","","Lowers a type using the memory space information. Returns `None` if some information is not yet specified.",45,[[["self"],["type"],["searchspace"]],["option",["type"]]]],[11,"gen_code","","Builds and outputs a constrained IR instance.",45,[[["self"],["searchspace"],["write"]]]],[0,"explorer","telamon","exploration of the search space.",N,N],[3,"Candidate","telamon::explorer","A node of the search tree.",N,N],[12,"space","","Represents a part of the full search space.",46,N],[12,"bound","","Gives a lower bound in nanoseconds on the execution time of `fun`.",46,N],[12,"depth","","The depth of the candidate in the search tree.",46,N],[12,"actions","","The list of actions already taken.",46,N],[4,"TreeEvent","","",N,N],[13,"Evaluation","","",47,N],[12,"actions","telamon::explorer::TreeEvent","",47,N],[12,"score","","",47,N],[4,"LogMessage","telamon::explorer","",N,N],[13,"Event","","",48,N],[13,"NewBest","","",48,N],[12,"score","telamon::explorer::LogMessage","",48,N],[12,"cpt","","",48,N],[12,"timestamp","","",48,N],[13,"Finished","telamon::explorer","",48,N],[5,"find_best","","Entry point of the exploration. This function returns the best candidate that it has found in the given time (or at whatever point we decided to stop the search - potentially after an exhaustive search)",N,[[["config"],["context"],["vec",["searchspace"]]],["option",["searchspace"]]]],[5,"find_best_ex","","Same as `find_best`, but allows to specify pre-existing actions and also returns the actionsfor the best candidate.",N,[[["config"],["context"],["vec",["candidate"]]],["option",["candidate"]]]],[5,"gen_space","","Explores the full search space.",N,[[["context"],["searchspace"],["f"],["g"]]]],[11,"clone","","",46,[[["self"]],["candidate"]]],[11,"new","","Creates a new candidate, with depth 0.",46,[[["searchspace"],["bound"]],["self"]]],[11,"apply_choice","","",46,[[["self"],["context"],["vec",["actionex"]]],["vec",["candidate"]]]],[11,"apply_decision","","Applies a choice to a candidate.",46,[[["self"],["context"],["actionex"]],["result"]]],[11,"fmt","","",46,[[["self"],["formatter"]],["result"]]],[11,"eq","","",46,[[["self"],["candidate"]],["bool"]]],[11,"partial_cmp","","",46,[[["self"],["candidate"]],["option",["ordering"]]]],[11,"cmp","","",46,[[["self"],["candidate"]],["ordering"]]],[0,"choice","","Choices that can be applied to split the search space.",N,N],[3,"ChoiceOrdering","telamon::explorer::choice","A list of ChoiceGroup representing the order in which we want to determine choices",N,N],[4,"ActionEx","","Either a regular action or a manually applied action.",N,N],[13,"Action","","",49,N],[13,"LowerLayout","","",49,N],[12,"mem","telamon::explorer::choice::ActionEx","",49,N],[12,"st_dims","","",49,N],[12,"ld_dims","","",49,N],[4,"ChoiceGroup","telamon::explorer::choice","An enum listing the Group of choices we can make For example, we can make first all DimKind decisions, then all Order decisions, etc.",N,N],[13,"LowerLayout","","",50,N],[13,"Size","","",50,N],[13,"DimKind","","",50,N],[13,"DimMap","","",50,N],[13,"Order","","",50,N],[13,"MemSpace","","",50,N],[13,"InstFlag","","",50,N],[5,"list","","This function is to be either removed or reimplemented eventually. It is just a replacement for the previous list implementation (exposes the choices in the same order). Default should preferably be handled in config file",N,[[["searchspace"]],[""]]],[5,"fix_order","","Chooses an order between instructions and dimensions when multiple are possible. The function assumes the order between dimensions is already fixed.",N,[[["searchspace"]],["searchspace"]]],[6,"Choice","","Represents a choice that splits a search space in multiple ones.",N,N],[11,"fmt","","",49,[[["self"],["formatter"]],["result"]]],[11,"clone","","",49,[[["self"]],["actionex"]]],[11,"eq","","",49,[[["self"],["actionex"]],["bool"]]],[11,"ne","","",49,[[["self"],["actionex"]],["bool"]]],[11,"list","","list the choices that are still to be made on the search space. Do it in a lazy fashion - that is, a call to next() on the list returned by this function does not do the whole iteration",51,[[["self"],["searchspace"]],[""]]],[0,"config","telamon::explorer","Defines a structure to store the configuration of the exploration. The configuration is read from the `Setting.toml` file if it exists. Some parameters can be overridden from the command line.",N,N],[3,"Config","telamon::explorer::config","Stores the configuration of the exploration.",N,N],[12,"log_file","","Name of the file in wich to store the logs.",52,N],[12,"event_log","","Name of the file in which to store the binary event log.",52,N],[12,"num_workers","","Number of exploration threads.",52,N],[12,"stop_bound","","Indicates the search must be stopped if a candidate with an execution time better than the bound (in ns) is found.",52,N],[12,"timeout","","Indicates the search must be stopped after the given number of minutes.",52,N],[12,"max_evaluations","","Indicates the search must be stopped after the given number of candidates have been evaluated.",52,N],[12,"distance_to_best","","A percentage cut indicate that we only care to find a candidate that is in a certain range above the best Therefore, if cut_under is 20%, we can discard any candidate whose bound is above 80% of the current best.",52,N],[12,"algorithm","","Exploration algorithm to use. Needs to be last for TOML serialization, because it is a table.",52,N],[3,"BanditConfig","","Configuration parameters specific to the multi-armed bandit algorithm.",N,N],[12,"new_nodes_order","","Indicates how to select between nodes of the search tree when none of their children have been evaluated.",53,N],[12,"old_nodes_order","","Indicates how to choose between nodes with at least one children evaluated.",53,N],[12,"threshold","","The number of best execution times to remember.",53,N],[12,"delta","","The biggest delta is, the more focused on the previous best candidates the exploration is.",53,N],[12,"monte_carlo","","If true, does not expand tree until end - instead, starts a montecarlo descend after each expansion of a node",53,N],[4,"SearchAlgorithm","","Exploration algorithm to use.",N,N],[13,"BoundOrder","","Evaluate all the candidates that cannot be pruned.",54,N],[13,"MultiArmedBandit","","Use a multi-armed bandit algorithm.",54,N],[4,"NewNodeOrder","","Indicates how to choose between nodes of the search tree when no children have been evaluated.",N,N],[13,"Api","","Consider the nodes in the order given by the search space API.",55,N],[13,"Random","","Consider the nodes in a random order.",55,N],[13,"Bound","","Consider the nodes with the lowest bound first.",55,N],[13,"WeightedRandom","","Consider the nodes with a probability proportional to the distance between the cut and the bound.",55,N],[4,"OldNodeOrder","","Indicates how to choose between nodes of the search tree with at least one descendent evaluated.",N,N],[13,"Bandit","","Use the weights from the bandit algorithm.",56,N],[13,"Bound","","Take the candidate with the best bound.",56,N],[13,"WeightedRandom","","Consider the nodes with a probability proportional to the distance between the cut and the bound.",56,N],[11,"clone","","",52,[[["self"]],["config"]]],[11,"read","","Reads the configuration from the \"Settings.toml\" file and from the command line.",52,[[],["self"]]],[11,"read_from_file","","Extract the configuration from the configuration file, if any.",52,[[],["self"]]],[11,"from_json","","Parse the configuration from a JSON string. Primary user is the Python API (through the C API).",52,[[["str"]],["self"]]],[11,"fmt","","",52,[[["self"],["formatter"]],["result"]]],[11,"default","","",52,[[],["self"]]],[11,"clone","","",54,[[["self"]],["searchalgorithm"]]],[11,"default","","",54,[[],["self"]]],[11,"clone","","",53,[[["self"]],["banditconfig"]]],[11,"default","","",53,[[],["self"]]],[11,"clone","","",55,[[["self"]],["newnodeorder"]]],[11,"default","","",55,[[],["self"]]],[11,"clone","","",56,[[["self"]],["oldnodeorder"]]],[11,"default","","",56,[[],["self"]]],[0,"local_selection","telamon::explorer","Provides different methods to select a candidate in a list.",N,N],[5,"descend","telamon::explorer::local_selection","A recursive function that takes a candidate and expands it until we have a completely specified candidate that we can pass to the evaluator, or we find a dead-end",N,[[["newnodeorder"],["context"],["candidate"],["f64"]],["option",["candidate"]]]],[5,"pick_candidate","","Called in montecarlo_descend, dispatch the choice of the next candidate according to our configuration",N,[[["newnodeorder"],["vec",["candidate"]],["f64"]],["option",["candidate"]]]],[5,"pick_index","","Returns the index of the next candidate to consider.",N,[[["newnodeorder"],["it"],["f64"]],["option",["usize"]]]],[0,"ir","telamon","Representation and manipulation of a set of possible implementation.",N,N],[3,"DimMap","telamon::ir","Represents a mapping between dimenions.",N,N],[3,"DimId","","Provides a unique identifier for iteration dimensions. cbindgen:field-names=[id]",N,N],[12,"0","","",57,N],[3,"DimMapping","","Specifies that two dimensions should be mapped together.",N,N],[3,"DimMappingId","","Uniquely identifies a pair of mapped dimensions.",N,N],[12,"0","","",58,N],[3,"Dimension","","Represents an iteration dimension.",N,N],[3,"LogicalDim","","A logic dimension composed of multiple `Dimension`s.",N,N],[3,"LogicalDimId","","Provides a unique identifier for logic dimensions.",N,N],[12,"0","","",59,N],[3,"Function","","Describes a function and the set of its possible implementation.",N,N],[3,"Parameter","","Represents an argument of a function.",N,N],[12,"name","","The name of the `Parameter`",60,N],[12,"t","","The type of the `Parameter`.",60,N],[3,"Signature","","Holds the signature of a function.",N,N],[12,"name","","Mame of the function.",61,N],[12,"params","","Arguments of the function.",61,N],[12,"mem_blocks","","The number of external memory blocks.",61,N],[3,"IndVarId","","Unique identifier for `InductionVar`",N,N],[12,"0","","",62,N],[3,"InductionVar","","A multidimentional induction variable. No dimension should appear twice in dims.",N,N],[3,"InstId","","Uniquely identifies an instruction. cbindgen:field-names=[id]",N,N],[12,"0","","",63,N],[3,"Instruction","","Represents an instruction.",N,N],[3,"LoweringMap","","",N,N],[3,"PartialSize","","A size whose exact value is not yet decided. The value of `size` is `product(size.factors())/product(size.divisors())`.",N,N],[3,"Size","","A fully specified size.",N,N],[3,"VarId","","Uniquely identifies variables.",N,N],[12,"0","","",64,N],[3,"Variable","","A variable produced by the code.",N,N],[3,"NewObjs","","Stores the objects created by a lowering.",N,N],[12,"instructions","","",65,N],[12,"dimensions","","",65,N],[12,"static_dims","","",65,N],[12,"statements","","",65,N],[12,"mem_blocks","","",65,N],[12,"internal_mem_blocks","","",65,N],[12,"mem_insts","","",65,N],[12,"iteration_dims","","",65,N],[12,"thread_dims","","",65,N],[12,"logical_dims","","",65,N],[12,"tile_dimensions","","",65,N],[12,"tiled_dimensions","","",65,N],[12,"dim_mappings","","",65,N],[12,"mapped_dims","","",65,N],[12,"variables","","",65,N],[12,"use_statements","","",65,N],[12,"def_statements","","",65,N],[3,"LoweredDimMap","","A point-to-point communication lowered into a store and a load.",N,N],[12,"mem","","",66,N],[12,"store","","",66,N],[12,"load","","",66,N],[12,"st_dims_mapping","","Mapping from production dimensions to store dimensions.",66,N],[12,"ld_dims_mapping","","Mapping from consumption dimensions to load dimensions.",66,N],[3,"Counter","","A wrapper used to count extra dimensions that will be needed in the future and allocates IDs for them. This is used when freezing in order to pre-allocate IDs for the various objects (internal memory block, instructions, dimensions, etc.) required for future lowering.",N,N],[12,"next_mem","","",67,N],[12,"next_inst","","",67,N],[12,"next_dim","","",67,N],[12,"next_dim_mapping","","",67,N],[4,"AccessPattern","","",N,N],[13,"Unknown","","Unknown access pattern.",68,N],[12,"mem_id","telamon::ir::AccessPattern","",68,N],[13,"Tensor","telamon::ir","Access with a fixed stride on each dimensions. Accesses on two different dimensions should not overlap.",68,N],[12,"mem_id","telamon::ir::AccessPattern","",68,N],[12,"dims","","",68,N],[4,"Stride","telamon::ir","A stride on a given dimensions.",N,N],[13,"Int","","A fixed stride.",69,N],[13,"Unknown","","A stride that is not statically known.",69,N],[4,"Error","","An error occuring while manipulating an ir instance.",N,N],[13,"Type","","",70,N],[13,"InvalidDimSize","","",70,N],[13,"DuplicateIncrement","","",70,N],[12,"dim","telamon::ir::Error","",70,N],[13,"InvalidDimInPattern","telamon::ir","",70,N],[12,"dim","telamon::ir::Error","",70,N],[13,"MissingDimMapping","telamon::ir","",70,N],[12,"lhs","telamon::ir::Error","",70,N],[12,"rhs","","",70,N],[4,"TypeError","telamon::ir","Errors that can be raised when creating an IR instance.",N,N],[13,"InvalidType","","",71,N],[12,"t","telamon::ir::TypeError","",71,N],[13,"ExpectedReturnType","telamon::ir","",71,N],[12,"inst","telamon::ir::TypeError","",71,N],[13,"InvalidRounding","telamon::ir","",71,N],[12,"rounding","telamon::ir::TypeError","",71,N],[12,"t","","",71,N],[13,"WrongType","telamon::ir","",71,N],[12,"given","telamon::ir::TypeError","",71,N],[12,"expected","","",71,N],[13,"UnexpectedType","telamon::ir","",71,N],[12,"t","telamon::ir::TypeError","",71,N],[4,"DimMapScope","telamon::ir","Indicates how dimensions can be mapped. The `L` type indicates how to lower mapped dimensions.",N,N],[13,"Local","","The dimensions are mapped within registers, without producing syncthreads.",72,N],[13,"Thread","","The dimensions are mapped within registers.",72,N],[13,"Global","","The dimensions are mapped, possibly using temporary memory. The parameter `L` is used to indicate how the mapping should be lowered. It is `()` when building the function (lowering is not possible at that time), and a `LoweringMap` instance when exploring which indicates what IDs to use for the new objects.",72,N],[4,"Operand","","Represents an instruction operand.",N,N],[13,"Int","","An integer constant, on a given number of bits.",73,N],[13,"Float","","A float constant, on a given number of bits.",73,N],[13,"Inst","","A value produced by an instruction. The boolean indicates if the `DimMap` can be lowered.",73,N],[13,"Index","","The current index in a loop.",73,N],[13,"Param","","A parameter of the function.",73,N],[13,"Addr","","The address of a memory block.",73,N],[13,"Reduce","","The value of the current instruction at a previous iteration.",73,N],[13,"InductionVar","","A variable increased by a fixed amount at every step of some loops.",73,N],[13,"Variable","","A variable, stored in register.",73,N],[4,"BinOp","","Represents binary arithmetic operators.",N,N],[13,"Add","","Adds two operands.",74,N],[13,"Sub","","Substracts two operands.",74,N],[13,"Div","","Divides two operands,",74,N],[13,"And","","Computes the bitwise AND operation.",74,N],[13,"Or","","Computes the bitwise OR operation.",74,N],[13,"Lt","","Computes `lhs < rhs`.",74,N],[13,"Leq","","Computes `lhs <= rhs`.",74,N],[13,"Equals","","Computes `lhs == rhs`.",74,N],[4,"Operator","","The operation performed by an instruction.",N,N],[13,"BinOp","","A binary arithmetic operator.",75,N],[13,"UnaryOp","","Unary arithmetic operator.",75,N],[13,"Mul","","Performs a multiplication with the given return type.",75,N],[13,"Mad","","Performs s multiplication between the first two operands and adds the result to the third.",75,N],[13,"Ld","","Loads a value of the given type from the given address.",75,N],[13,"St","","Stores the second operand at the address given by the first. The boolean specifies if the instruction has side effects. A store has no side effects when it writes into a cell that previously had an undefined value.",75,N],[13,"TmpLd","","Represents a load from a temporary memory that is not fully defined yet.",75,N],[13,"TmpSt","","Represents a store to a temporary memory that is not fully defined yet.",75,N],[4,"UnaryOp","","Arithmetic operators with a single operand.",N,N],[13,"Mov","","Simply copy the input.",76,N],[13,"Cast","","Casts the input to another type.",76,N],[4,"StmtId","","Provides a unique identifer for a basic block.",N,N],[13,"Inst","","cbindgen:field-names=[id]",77,N],[13,"Dim","","cbindgen:field-names=[id]",77,N],[4,"Type","","Values and intructions types.",N,N],[13,"I","","Type for integer values, with a fixed number of bits.",78,N],[13,"F","","Type for floating point values, with a fixed number of bits.",78,N],[13,"PtrTo","","Pointer type of the given memory space.",78,N],[4,"VarDef","","Specifies how is a `Variable` defined.",N,N],[13,"Inst","","Takes the variable produced by an instruction.",79,N],[11,"eq","","",69,[[["self"],["stride"]],["bool"]]],[11,"ne","","",69,[[["self"],["stride"]],["bool"]]],[11,"clone","","",69,[[["self"]],["stride"]]],[11,"fmt","","",69,[[["self"],["formatter"]],["result"]]],[11,"clone","","",68,[[["self"]],["accesspattern"]]],[11,"fmt","","",68,[[["self"],["formatter"]],["result"]]],[11,"is_consecutive","","Indicates if memory accesses access to consecutive elements on the given dimension.",68,[[["self"],["dimid"],["type"]],["bool"]]],[11,"mem_block","","Returns the id of the memory block accessed.",68,[[["self"]],["memid"]]],[11,"check","","Ensure the access pattern is valid for an instruction nested in the dimensions given in `iter_dims`.",68,[[["self"],["hashset"]],["result",["error"]]]],[11,"clone","","",80,[[["self"]],["dimmap"]]],[11,"fmt","","",80,[[["self"],["formatter"]],["result"]]],[11,"new","","Create a new `DimMap`.",80,[[["it"]],["self"]]],[11,"empty","","Returns an empty `DimMap`.",80,[[],["self"]]],[11,"merge_dims","","Renames a basic block into an other. Indicates if some mapping were removed.",80,[[["self"],["dimid"],["dimid"]],["bool"]]],[11,"iter","","Iterates over the DimMap.",80,[[["self"]],["iter"]]],[11,"filter","","Filters the DimMap.",80,[[["self"],["f"]],["filterlist"]]],[11,"is_empty","","Returns true if the `DimMap` is empty.",80,[[["self"]],["bool"]]],[11,"into_iter","","",80,N],[11,"clone","","",57,[[["self"]],["dimid"]]],[11,"fmt","","",57,[[["self"],["formatter"]],["result"]]],[11,"eq","","",57,[[["self"],["dimid"]],["bool"]]],[11,"ne","","",57,[[["self"],["dimid"]],["bool"]]],[11,"hash","","",57,N],[11,"partial_cmp","","",57,[[["self"],["dimid"]],["option",["ordering"]]]],[11,"lt","","",57,[[["self"],["dimid"]],["bool"]]],[11,"le","","",57,[[["self"],["dimid"]],["bool"]]],[11,"gt","","",57,[[["self"],["dimid"]],["bool"]]],[11,"ge","","",57,[[["self"],["dimid"]],["bool"]]],[11,"cmp","","",57,[[["self"],["dimid"]],["ordering"]]],[11,"into","","",57,[[["self"]],["usize"]]],[11,"fmt","","",57,[[["self"],["formatter"]],["result"]]],[11,"clone","","",81,[[["self"]],["dimension"]]],[11,"fmt","","",81,[[["self"],["formatter"]],["result"]]],[11,"freeze","","Sets the dimension as frozen.",81,[[["self"]],["dimension"]]],[11,"new","","Creates a new dimension.",81,[[["dimid"],["partialsize"],["option",["logicaldimid"]]],["result",["error"]]]],[11,"new_static","","Creates a dimension with a statically known size, picked in a list of possibilities.",81,[[["dimid"],["vecset",["u32"]],["option",["logicaldimid"]]],["result",["error"]]]],[11,"with_same_size","","Creates a new dimension with the same size as an existing one.",81,[[["dimid"],["self"]],["self"]]],[11,"size","","Retruns the size of the dimension.",81,[[["self"]],["partialsize"]]],[11,"possible_sizes","","Returns the values the size can take, if it is statically known.",81,[[["self"]],["option"]]],[11,"id","","Returns the id of the dimension.",81,[[["self"]],["dimid"]]],[11,"iterated","","Returns the constructs iterated along this dimension.",81,[[["self"]],[""]]],[11,"add_iterated","","Adds a stmt that is iterated along self.",81,[[["self"],["instid"]]]],[11,"is_thread_dim","","Indicates if the dimension is a thread dimension.",81,[[["self"]],["bool"]]],[11,"set_thread_dim","","Sets the dimension as a thread dimension.",81,[[["self"]]]],[11,"logical_dim","","Returns the logical dimension this dimension is part of, if any.",81,[[["self"]],["option",["logicaldimid"]]]],[11,"dim_mappings","","Returns the list of dimensions mapping containing this one.",81,[[["self"]],["vecset"]]],[11,"register_dim_mapping","","Register a dimension mapping.",81,[[["self"],["dimmapping"]]]],[11,"stmt_id","","",81,[[["self"]],["stmtid"]]],[11,"as_dim","","",81,[[["self"]],["option",["dimension"]]]],[11,"def_variables","","",81,[[["self"]],["vecset"]]],[11,"used_variables","","",81,[[["self"]],["vecset"]]],[11,"clone","","",59,[[["self"]],["logicaldimid"]]],[11,"fmt","","",59,[[["self"],["formatter"]],["result"]]],[11,"eq","","",59,[[["self"],["logicaldimid"]],["bool"]]],[11,"ne","","",59,[[["self"],["logicaldimid"]],["bool"]]],[11,"hash","","",59,N],[11,"clone","","",82,[[["self"]],["logicaldim"]]],[11,"fmt","","",82,[[["self"],["formatter"]],["result"]]],[11,"new_static","","Creates a new logical dimension, composed only of static dimensions.",82,[[["logicaldimid"],["vec",["dimid"]],["u32"]],["self"]]],[11,"new_dynamic","","Creates a new logical dimension, composed of static dimensions and one dynamically-sized dimension.",82,[[["logicaldimid"],["dimid"],["vec",["dimid"]],["vecset",["u32"]],["size"]],["self"]]],[11,"id","","Returns a unique identifier for the logic dimension.",82,[[["self"]],["logicaldimid"]]],[11,"tile_dimensions","","Returns the tiling dimensions, i.e. the dimensions with a static size.",82,[[["self"]],[""]]],[11,"tiled_dimension","","Return the tiled dimensions, i.e. the dimension with a non-static size, if any.",82,[[["self"]],["option",["dimid"]]]],[11,"possible_tilings","","Returns the possible tiling factors.",82,N],[11,"dimensions","","Returns all the dimensions constituing the logical dimension, from the inner-most to the outer-most.",82,[[["self"]],[""]]],[11,"total_size","","Returns the size of the logical dimension, i.e. the product of the sizes of its dimensions.",82,[[["self"]],["size"]]],[11,"fmt","","",58,[[["self"],["formatter"]],["result"]]],[11,"clone","","",58,[[["self"]],["dimmappingid"]]],[11,"eq","","",58,[[["self"],["dimmappingid"]],["bool"]]],[11,"ne","","",58,[[["self"],["dimmappingid"]],["bool"]]],[11,"hash","","",58,N],[11,"partial_cmp","","",58,[[["self"],["dimmappingid"]],["option",["ordering"]]]],[11,"lt","","",58,[[["self"],["dimmappingid"]],["bool"]]],[11,"le","","",58,[[["self"],["dimmappingid"]],["bool"]]],[11,"gt","","",58,[[["self"],["dimmappingid"]],["bool"]]],[11,"ge","","",58,[[["self"],["dimmappingid"]],["bool"]]],[11,"cmp","","",58,[[["self"],["dimmappingid"]],["ordering"]]],[11,"clone","","",83,[[["self"]],["dimmapping"]]],[11,"fmt","","",83,[[["self"],["formatter"]],["result"]]],[11,"new","","Creates a `DimMapping`. Panics if the provided dimensions are the same.",83,N],[11,"id","","Returns the unique identifier of the `DimMapping`.",83,[[["self"]],["dimmappingid"]]],[11,"dims","","Returns the mapped dims.",83,N],[11,"fmt","","",71,[[["self"],["formatter"]],["result"]]],[11,"check_equals","","Ensures a type is equal to the expected one.",71,[[["type"],["type"]],["result"]]],[11,"check_integer","","Ensures the given type is an integer type.",71,[[["type"]],["result"]]],[11,"check_float","","Ensures the given type is a floating point type.",71,[[["type"]],["result"]]],[11,"fmt","","",70,[[["self"],["formatter"]],["result"]]],[11,"from","","",70,[[["typeerror"]],["self"]]],[11,"eq","","",60,[[["self"],["parameter"]],["bool"]]],[11,"ne","","",60,[[["self"],["parameter"]],["bool"]]],[11,"hash","","",60,N],[11,"clone","","",60,[[["self"]],["parameter"]]],[11,"fmt","","",60,[[["self"],["formatter"]],["result"]]],[11,"clone","","",61,[[["self"]],["signature"]]],[11,"eq","","",61,[[["self"],["signature"]],["bool"]]],[11,"ne","","",61,[[["self"],["signature"]],["bool"]]],[11,"hash","","",61,N],[11,"new","","Creates a new signature without any parameter.",61,[[["string"]],["self"]]],[11,"add_scalar","","Adds a scalar parameter.",61,[[["self"],["string"],["type"]]]],[11,"add_array","","Adds a parameter with the given name and type to the signature.",61,[[["self"],["string"]],["memid"]]],[11,"clone","","",84,[[["self"]],["function"]]],[11,"new","","Creates a new function.",84,[[["signature"],["device"]],["self"]]],[11,"signature","","Returns the function signature.",84,[[["self"]],["signature"]]],[11,"device","","Returns the device the function is compiled for.",84,[[["self"]],["device"]]],[11,"add_ind_var","","Adds an induction variable.",84,[[["self"],["inductionvar"]],["indvarid"]]],[11,"insts","","Returns the list of instructions of the function.",84,[[["self"]],[""]]],[11,"dims","","Returns the list of dimensions of the function.",84,[[["self"]],[""]]],[11,"logical_dims","","Returns the list of logical dimensions.",84,[[["self"]],[""]]],[11,"static_dims","","Returns the list of stastic dimensions in the function.",84,[[["self"]],[""]]],[11,"variables","","",84,[[["self"]],[""]]],[11,"thread_dims","","Returns the list of thread dimensions.",84,[[["self"]],[""]]],[11,"inst","","Returns an instruction given its id.",84,[[["self"],["instid"]],["instruction"]]],[11,"inst_mut","","Returns a mutable reference to an instruction given its id.",84,[[["self"],["instid"]],["instruction"]]],[11,"dim","","Retuns a dimension given its id.",84,[[["self"],["dimid"]],["dimension"]]],[11,"statement","","Returns a `Statement` given its id.",84,[[["self"],["stmtid"]],["statement"]]],[11,"statements","","Lists all `Statement`s.",84,[[["self"]],[""]]],[11,"logical_dim","","Retrives a logical dimension given its ID.",84,[[["self"],["logicaldimid"]],["logicaldim"]]],[11,"variable","","Returns a `Variable` given its id.",84,[[["self"],["varid"]],["variable"]]],[11,"add_variable","","Adds a variable to the function. Also register its definition into the relevant instruction",84,[[["self"],["vardef"]],["result",["varid","error"]]]],[11,"mem_blocks","","Returns the list of memory blocks. The block with id `i` is in i-th position.",84,[[["self"]],[""]]],[11,"mem_insts","","Iterates over memory instructions.",84,[[["self"]],[""]]],[11,"internal_mem_blocks","","Returns the internal memory blocks.",84,[[["self"]],[""]]],[11,"mem_block","","Returns a memory block given its id.",84,[[["self"],["memid"]],["block"]]],[11,"internal_mem_block","","Returns an internal memory block given its id.",84,[[["self"],["internalid"]],["internalblock"]]],[11,"induction_var","","Retrieves an induction variable given its Id.",84,[[["self"],["indvarid"]],["inductionvar"]]],[11,"induction_vars","","Iterates over induction variables.",84,[[["self"]],[""]]],[11,"set_iteration_dim","","Sets a dimension as an iteration dimension for an instruction. Indicates if the iteration dimension was not aleady present in the set.",84,[[["self"],["instid"],["dimid"]],["bool"]]],[11,"add_thread_dim","","Adds a thread dimension. Indicates if the the dimension was not already present in the set.",84,[[["self"],["dimid"]],["bool"]]],[11,"dim_mappings","","Returns the list of dimensions mapping.",84,[[["self"]],[""]]],[11,"dim_mapping","","Retrives a dimension mapping given its ID.",84,[[["self"],["dimmappingid"]],["dimmapping"]]],[11,"find_mapping","","Tries to find a mapping between two dimensions.",84,[[["self"],["dimid"],["dimid"]],["option",["dimmappingid"]]]],[11,"add_inst","","Adds an instruction to the function.",84,[[["self"],["operator"],["hashset",["dimid"]]],["result",["instid","error"]]]],[11,"add_mem_block","","Allocates a new memory block.",84,[[["self"],["u32"]],["internalid"]]],[11,"add_logical_dim","","Create a new logical dimension composed of multiple dimensions to implement strip-mining.",84,[[["self"],["size"],["vecset",["u32"]],["vec",["vecset"]]],["result",["error"]]]],[11,"deref","","",84,N],[11,"fmt","","",62,[[["self"],["formatter"]],["result"]]],[11,"clone","","",62,[[["self"]],["indvarid"]]],[11,"hash","","",62,N],[11,"eq","","",62,[[["self"],["indvarid"]],["bool"]]],[11,"ne","","",62,[[["self"],["indvarid"]],["bool"]]],[11,"partial_cmp","","",62,[[["self"],["indvarid"]],["option",["ordering"]]]],[11,"lt","","",62,[[["self"],["indvarid"]],["bool"]]],[11,"le","","",62,[[["self"],["indvarid"]],["bool"]]],[11,"gt","","",62,[[["self"],["indvarid"]],["bool"]]],[11,"ge","","",62,[[["self"],["indvarid"]],["bool"]]],[11,"cmp","","",62,[[["self"],["indvarid"]],["ordering"]]],[11,"clone","","",85,[[["self"]],["inductionvar"]]],[11,"fmt","","",85,[[["self"],["formatter"]],["result"]]],[11,"new","","Creates a new induction var. Size represents the increment over each diemnsion taken independenly.",85,[[["vec"],["operand"]],["result",["error"]]]],[11,"merge_dims","","Renames a dimension.",85,[[["self"],["dimid"],["dimid"]]]],[11,"base","","Returns the base operand of the induction variable.",85,[[["self"]],["operand"]]],[11,"dims","","Returns the list of induction dimensions along with the corresponding increments.",85,N],[11,"freeze","","",85,[[["self"],["counter"]],["inductionvar"]]],[11,"clone","","",63,[[["self"]],["instid"]]],[11,"fmt","","",63,[[["self"],["formatter"]],["result"]]],[11,"eq","","",63,[[["self"],["instid"]],["bool"]]],[11,"ne","","",63,[[["self"],["instid"]],["bool"]]],[11,"partial_cmp","","",63,[[["self"],["instid"]],["option",["ordering"]]]],[11,"lt","","",63,[[["self"],["instid"]],["bool"]]],[11,"le","","",63,[[["self"],["instid"]],["bool"]]],[11,"gt","","",63,[[["self"],["instid"]],["bool"]]],[11,"ge","","",63,[[["self"],["instid"]],["bool"]]],[11,"cmp","","",63,[[["self"],["instid"]],["ordering"]]],[11,"hash","","",63,N],[11,"into","","",63,[[["self"]],["usize"]]],[11,"fmt","","",63,[[["self"],["formatter"]],["result"]]],[11,"clone","","",86,[[["self"]],["instruction"]]],[11,"fmt","","",86,[[["self"],["formatter"]],["result"]]],[11,"new","","Creates a new instruction and type-check the operands.",86,[[["operator"],["instid"],["hashset",["dimid"]],["function"]],["result",["error"]]]],[11,"operands","","Returns an iterator over the operands of this instruction.",86,[[["self"]],["vec",["operand"]]]],[11,"t","","Returns the type of the variable produced by an instruction.",86,[[["self"]],["option",["type"]]]],[11,"operator","","Returns the operator of the instruction.",86,[[["self"]],["operator"]]],[11,"id","","Returns the `InstId` representing the instruction.",86,[[["self"]],["instid"]]],[11,"has_side_effects","","Returns true if the instruction has side effects.",86,[[["self"]],["bool"]]],[11,"lower_layout","","Applies the lowering of a layout to the instruction.",86,[[["self"],["operand"],["accesspattern"],["operand"],["accesspattern"]]]],[11,"dim_maps_to_lower","","Indicates the operands for wich a `DimMap` must be lowered if lhs and rhs are not mapped.",86,[[["self"],["dimid"],["dimid"]],["vec",["usize"]]]],[11,"as_mem_inst","","Returns 'self' if it is a memory instruction.",86,[[["self"]],["option",["instruction"]]]],[11,"as_reduction","","Indicates if the instruction performs a reduction.",86,[[["self"]],["option"]]],[11,"is_reduction_common_dim","","Returns 'true' if `self` is a reduction initialized by init, and if 'dim' should have the same nesting with 'init' that with 'self'.",86,[[["self"],["instid"],["dimid"]],["bool"]]],[11,"merge_dims","","Rename a dimension to another ID.",86,[[["self"],["dimid"],["dimid"]]]],[11,"iteration_dims","","The list of dimensions the instruction must be nested in.",86,[[["self"]],["hashset"]]],[11,"add_iteration_dimension","","Adds a new iteration dimension. Indicates if the dimension was not already an iteration dimension.",86,[[["self"],["dimid"]],["bool"]]],[11,"result_variable","","Returns the `Variable` holding the result of this instruction.",86,[[["self"]],["option",["varid"]]]],[11,"set_result_variable","","Sets the `Variable` holdings the result of this instruction.",86,[[["self"],["varid"]]]],[11,"freeze","","",86,[[["self"],["counter"]],["instruction"]]],[11,"lower_dim_map","","Lowers the `DimMap` of an operand into an access to a temporary memory.",86,[[["self"],["usize"],["instid"],["dimmap"]]]],[11,"stmt_id","","",86,[[["self"]],["stmtid"]]],[11,"as_inst","","",86,[[["self"]],["option",["instruction"]]]],[11,"def_variables","","",86,[[["self"]],["vecset"]]],[11,"used_variables","","",86,[[["self"]],["vecset"]]],[11,"clone","","",87,[[["self"]],["loweringmap"]]],[11,"fmt","","",87,[[["self"],["formatter"]],["result"]]],[11,"for_dim_map","","Creates a new lowering map from an existing dimension map and a counter. This allocates new IDs for the new dimensions/instructions/memory locations that will be used when lowering the DimMap.",87,[[["dimmap"],["counter"]],["loweringmap"]]],[11,"fmt","","",72,[[["self"],["formatter"]],["result"]]],[11,"clone","","",72,[[["self"]],["dimmapscope"]]],[11,"eq","","",72,[[["self"],["dimmapscope"]],["bool"]]],[11,"ne","","",72,[[["self"],["dimmapscope"]],["bool"]]],[11,"clone","","",73,[[["self"]],["operand"]]],[11,"fmt","","",73,[[["self"],["formatter"]],["result"]]],[11,"t","","Returns the type of the `Operand`.",73,[[["self"]],["type"]]],[11,"new_inst","","Create an operand from an instruction.",73,[[["instruction"],["dimmap"],["dimmapscope"]],["self"]]],[11,"new_reduce","","Creates a reduce operand from an instruction and a set of dimensions to reduce on.",73,[[["instruction"],["dimmap"],["vec",["dimid"]]],["self"]]],[11,"new_int","","Creates a new Int operand and checks its number of bits.",73,[[["bigint"],["u16"]],["self"]]],[11,"new_float","","Creates a new Float operand.",73,[[["ratio",["bigint"]],["u16"]],["self"]]],[11,"merge_dims","","Renames a basic block id.",73,[[["self"],["dimid"],["dimid"]]]],[11,"should_lower_map","","Indicates if a `DimMap` should be lowered if lhs and rhs are not mapped.",73,[[["self"],["dimid"],["dimid"]],["bool"]]],[11,"as_reduction","","If the operand is a reduction, returns the instruction initializing the reduction.",73,[[["self"]],["option"]]],[11,"is_constant","","Indicates if the operand stays constant during the execution.",73,[[["self"]],["bool"]]],[11,"mapped_dims","","Returns the list of dimensions mapped together by the operand.",73,[[["self"]],["option",["dimmap"]]]],[11,"freeze","","",73,[[["self"],["counter"]],["operand"]]],[11,"clone","","",74,[[["self"]],["binop"]]],[11,"fmt","","",74,[[["self"],["formatter"]],["result"]]],[11,"t","","Returns the type of the binay operator given the type of its operands.",74,[[["self"],["type"]],["type"]]],[11,"clone","","",76,[[["self"]],["unaryop"]]],[11,"fmt","","",76,[[["self"],["formatter"]],["result"]]],[11,"clone","","",75,[[["self"]],["operator"]]],[11,"fmt","","",75,[[["self"],["formatter"]],["result"]]],[11,"check","","Ensures the types of the operands are valid.",75,[[["self"],["hashset"],["function"]],["result",["error"]]]],[11,"t","","Returns the type of the value produced.",75,[[["self"]],["option",["type"]]]],[11,"operands","","Retruns the list of operands.",75,[[["self"]],["vec",["operand"]]]],[11,"operands_mut","","Retruns the list of mutable references to operands.",75,[[["self"]],["vec",["operand"]]]],[11,"has_side_effects","","Returns true if the operator has side effects.",75,[[["self"]],["bool"]]],[11,"merge_dims","","Renames a basic block.",75,[[["self"],["dimid"],["dimid"]]]],[11,"mem_access_pattern","","Returns the pattern of access to the memory by the instruction, if any.",75,[[["self"]],["option",["cow"]]]],[11,"mem_used","","Returns the memory blocks referenced by the instruction.",75,[[["self"]],["option",["memid"]]]],[11,"supports_nc_access","","Indicates if the operator supports non-coherent memory accesses.",75,[[["self"]],["bool"]]],[11,"map_operands","","",75,[[["self"],["f"]],["operator"]]],[11,"freeze","","",75,[[["self"],["counter"]],["operator"]]],[11,"fmt","","",75,[[["self"],["formatter"]],["result"]]],[11,"clone","","",88,[[["self"]],["size"]]],[11,"fmt","","",88,[[["self"],["formatter"]],["result"]]],[11,"eq","","",88,[[["self"],["size"]],["bool"]]],[11,"ne","","",88,[[["self"],["size"]],["bool"]]],[11,"new","","Create a new fully specified size.",88,[[["u32"],["vec",["parameter"]],["u32"]],["self"]]],[11,"new_const","","Creates a new constant size.",88,[[["u32"]],["self"]]],[11,"new_param","","Creates a new size equal to a parameter.",88,[[["parameter"],["u32"]],["size"]]],[11,"as_constant","","Returns the size if it is a constant.",88,[[["self"]],["option",["u32"]]]],[11,"max","","Returns the maximum value the size can take.",88,[[["self"]],["u32"]]],[11,"default","","",88,[[],["self"]]],[11,"mul_assign","","",88,[[["self"],["t"]]]],[11,"clone","","",89,[[["self"]],["partialsize"]]],[11,"fmt","","",89,[[["self"],["formatter"]],["result"]]],[11,"hash","","",89,N],[11,"eq","","",89,[[["self"],["partialsize"]],["bool"]]],[11,"ne","","",89,[[["self"],["partialsize"]],["bool"]]],[11,"new","","Creates a new 'PartialSize'.",89,[[["u32"],["vec",["parameter"]]],["self"]]],[11,"new_dim_size","","Creates a new `PartialSize` equals to the size of a dimension.",89,[[["dimid"]],["self"]]],[11,"add_divisors","","Add divisors to the size.",89,[[["self"],["vecset"]]]],[11,"as_int","","Returns the size of a dimension if it is staticaly known.",89,[[["self"]],["option",["u32"]]]],[11,"factors","","Returns the factors composing the size.",89,N],[11,"divisors","","Returns the divisors composing the size.",89,N],[11,"default","","",89,[[],["self"]]],[11,"mul_assign","","",89,[[["self"],["partialsize"]]]],[11,"mul","","",89,[[["self"],["partialsize"]],["self"]]],[11,"product","","",89,[[["i"]],["self"]]],[11,"from","","",89,[[["size"]],["partialsize"]]],[11,"clone","","",77,[[["self"]],["stmtid"]]],[11,"fmt","","",77,[[["self"],["formatter"]],["result"]]],[11,"eq","","",77,[[["self"],["stmtid"]],["bool"]]],[11,"ne","","",77,[[["self"],["stmtid"]],["bool"]]],[11,"partial_cmp","","",77,[[["self"],["stmtid"]],["option",["ordering"]]]],[11,"lt","","",77,[[["self"],["stmtid"]],["bool"]]],[11,"le","","",77,[[["self"],["stmtid"]],["bool"]]],[11,"gt","","",77,[[["self"],["stmtid"]],["bool"]]],[11,"ge","","",77,[[["self"],["stmtid"]],["bool"]]],[11,"cmp","","",77,[[["self"],["stmtid"]],["ordering"]]],[11,"hash","","",77,N],[11,"from","","",77,[[["instid"]],["self"]]],[11,"from","","",77,[[["dimid"]],["self"]]],[11,"clone","","",78,[[["self"]],["type"]]],[11,"eq","","",78,[[["self"],["type"]],["bool"]]],[11,"ne","","",78,[[["self"],["type"]],["bool"]]],[11,"hash","","",78,N],[11,"fmt","","",78,[[["self"],["formatter"]],["result"]]],[11,"is_integer","","Returns true if the type is an integer.",78,[[["self"]],["bool"]]],[11,"is_float","","Returns true if the type is a float.",78,[[["self"]],["bool"]]],[11,"len_byte","","Returns the number of bytes of the type.",78,[[["self"]],["option",["u32"]]]],[11,"fmt","","",78,[[["self"],["formatter"]],["result"]]],[11,"clone","","",64,[[["self"]],["varid"]]],[11,"fmt","","",64,[[["self"],["formatter"]],["result"]]],[11,"eq","","",64,[[["self"],["varid"]],["bool"]]],[11,"ne","","",64,[[["self"],["varid"]],["bool"]]],[11,"cmp","","",64,[[["self"],["varid"]],["ordering"]]],[11,"partial_cmp","","",64,[[["self"],["varid"]],["option",["ordering"]]]],[11,"lt","","",64,[[["self"],["varid"]],["bool"]]],[11,"le","","",64,[[["self"],["varid"]],["bool"]]],[11,"gt","","",64,[[["self"],["varid"]],["bool"]]],[11,"ge","","",64,[[["self"],["varid"]],["bool"]]],[11,"hash","","",64,N],[11,"clone","","",90,[[["self"]],["variable"]]],[11,"fmt","","",90,[[["self"],["formatter"]],["result"]]],[11,"new","","Creates a new variable with the given Id.",90,[[["varid"],["type"],["vardef"]],["self"]]],[11,"id","","Return the unique identifiers of the `Variable`.",90,[[["self"]],["varid"]]],[11,"def","","Specifies how the variable is defined.",90,[[["self"]],["vardef"]]],[11,"t","","Indicates the type of the variable.",90,[[["self"]],["type"]]],[11,"def_points","","Indicates the statements that define the variable.",90,[[["self"]],[""]]],[11,"use_points","","Indicates the statements that uses the variable.",90,[[["self"]],[""]]],[11,"add_use","","Registers that the variable is used by a statement.",90,[[["self"],["stmtid"]]]],[11,"clone","","",79,[[["self"]],["vardef"]]],[11,"fmt","","",79,[[["self"],["formatter"]],["result"]]],[11,"register","","Registers the variable in the structures it references in the function.",79,[[["self"],["varid"],["function"]]]],[11,"t","","Returns the type of the variable if used on the context of `function`.",79,[[["self"],["function"]],["type"]]],[11,"check","","Ensures the definition is valid.",79,[[["self"],["function"]],["result",["typeerror"]]]],[11,"def_statements","","Indicates in which statment the variable is defined.",79,[[["self"]],[""]]],[0,"mem","","A module for handling accesses to the device memory.",N,N],[3,"InternalId","telamon::ir::mem","cbindgen:field-names=[id]",N,N],[12,"0","","",91,N],[3,"InternalBlock","","A block of memory allocated on the device by the kernel.",N,N],[3,"ExternalBlock","","A memory block allocated by the user.",N,N],[3,"BlockMap","","Holds the blocks of memory to allocate on the device.",N,N],[4,"MemId","","Uniquely identifies a block.",N,N],[13,"Internal","","cbindgen:field-names=[id]",92,N],[13,"External","","cbindgen:field-names=[id]",92,N],[8,"Block","","Represents a memory block.",N,N],[10,"mem_id","","The ID of the block.",93,[[["self"]],["memid"]]],[11,"as_internal","","Returns self if it is an internal memory block.",93,[[["self"]],["option",["internalblock"]]]],[10,"uses","","The list of instructions referencing the memory block.",93,N],[10,"add_use","","Add a use to the block.",93,[[["self"],["instid"]]]],[11,"clone","","",92,[[["self"]],["memid"]]],[11,"eq","","",92,[[["self"],["memid"]],["bool"]]],[11,"ne","","",92,[[["self"],["memid"]],["bool"]]],[11,"hash","","",92,N],[11,"fmt","","",92,[[["self"],["formatter"]],["result"]]],[11,"clone","","",91,[[["self"]],["internalid"]]],[11,"eq","","",91,[[["self"],["internalid"]],["bool"]]],[11,"ne","","",91,[[["self"],["internalid"]],["bool"]]],[11,"hash","","",91,N],[11,"fmt","","",91,[[["self"],["formatter"]],["result"]]],[11,"into","","",91,[[["self"]],["usize"]]],[11,"from","","",92,[[["internalid"]],["self"]]],[11,"clone","","",94,[[["self"]],["internalblock"]]],[11,"clone","","",95,[[["self"]],["externalblock"]]],[11,"id","","Returns the unique identifer of the memory block.",94,[[["self"]],["internalid"]]],[11,"maps_dims","","Indicates if two dimensions are mapped by a temporary memory block.",94,[[["self"],["dimid"],["dimid"]],["bool"]]],[11,"mapped_dims","","Returns the list of mapped dimensions.",94,N],[11,"is_private","","Indicates if the block is privatised per block of thread.",94,[[["self"]],["bool"]]],[11,"base_size","","Return the base size of the block, if it is statically known.",94,[[["self"]],["u32"]]],[11,"mem_id","","",94,[[["self"]],["memid"]]],[11,"as_internal","","",94,[[["self"]],["option",["internalblock"]]]],[11,"uses","","",94,N],[11,"add_use","","",94,[[["self"],["instid"]]]],[11,"mem_id","","",95,[[["self"]],["memid"]]],[11,"uses","","",95,N],[11,"add_use","","",95,[[["self"],["instid"]]]],[11,"clone","","",96,[[["self"]],["blockmap"]]],[11,"new","","Creates a new `BlocksMap`.",96,[[["u32"]],["self"]]],[11,"num_internal_blocks","","",96,[[["self"]],["usize"]]],[11,"alloc_block","","Allocates a new `Block` with the given type and sizes. Must call not merged on the dimensions that cannot be merged upon creation.",96,[[["self"],["u32"],["option",["dimmap"]]],["internalid"]]],[11,"expand_internal_blocks_to","","",96,[[["self"],["usize"]]]],[11,"set_lazy_tmp","","Inserts a new temporary memory. Must be inserted before not_merged is called on dimensions.",96,[[["self"],["internalid"],["type"],["it"]]]],[11,"register_use","","Registers a use of a memory block by an instruction.",96,[[["self"],["memid"],["instid"]]]],[11,"block","","Returns a block given its Id.",96,[[["self"],["memid"]],["block"]]],[11,"block_mut","","Returns a block given its Id.",96,[[["self"],["memid"]],["block"]]],[11,"internal_block","","Returns the internal block given its ID.",96,[[["self"],["internalid"]],["internalblock"]]],[11,"internal_blocks","","Retuns the list of internal blocks.",96,[[["self"]],[""]]],[11,"blocks","","Returns the list of memory blocks.",96,[[["self"]],[""]]],[11,"merge_dims","","Rename a basic block. Returns the lyaouts to lower.",96,[[["self"],["dimid"],["dimid"]],["vec",["internalid"]]]],[11,"not_merged","","Registers that two dimensions may not be merged. Returns a list of dimensions removed from the memory blocks and a list of layouts to lower.",96,[[["self"],["dimension"],["dimid"]],["vec",["internalid"]]]],[11,"lower_layout","","Lowers a fully defined layout. Returns the mapping of dimensions.",96,[[["self"],["internalid"]],["vec"]]],[0,"dim","telamon::ir","Defines iteration dimensions properties.",N,N],[3,"Map","telamon::ir::dim","Represents a mapping between dimenions.",N,N],[0,"op","telamon::ir","Defines operators.",N,N],[4,"BinOp","telamon::ir::op","Represents binary arithmetic operators.",N,N],[13,"Add","","Adds two operands.",74,N],[13,"Sub","","Substracts two operands.",74,N],[13,"Div","","Divides two operands,",74,N],[13,"And","","Computes the bitwise AND operation.",74,N],[13,"Or","","Computes the bitwise OR operation.",74,N],[13,"Lt","","Computes `lhs < rhs`.",74,N],[13,"Leq","","Computes `lhs <= rhs`.",74,N],[13,"Equals","","Computes `lhs == rhs`.",74,N],[4,"Rounding","","The rounding mode of an arithmetic operation.",N,N],[13,"Exact","","No rounding occurs.",97,N],[13,"Nearest","","Rounds toward the nearest number.",97,N],[13,"Zero","","Rounds toward zero.",97,N],[13,"Positive","","Rounds toward positive infinite.",97,N],[13,"Negative","","Rounds toward negative infinite.",97,N],[0,"prelude","telamon::ir","Defines traits to import in the environment to use the IR.",N,N],[8,"Statement","telamon::ir::prelude","Represents a basic block in an Exhaust function.",N,N],[10,"stmt_id","","Returns the unique identifier of the `Statement`.",98,[[["self"]],["stmtid"]]],[11,"as_inst","","Returns 'self' if it is an instruction.",98,[[["self"]],["option",["instruction"]]]],[11,"as_dim","","Returns 'self' if it is a dimension",98,[[["self"]],["option",["dimension"]]]],[10,"def_variables","","Lists the variables defined at this statement.",98,[[["self"]],["vecset"]]],[10,"used_variables","","Lists the variables defined used at this statement.",98,[[["self"]],["vecset"]]],[8,"Statement","telamon::ir","Represents a basic block in an Exhaust function.",N,N],[10,"stmt_id","","Returns the unique identifier of the `Statement`.",98,[[["self"]],["stmtid"]]],[11,"as_inst","telamon::ir::prelude","Returns 'self' if it is an instruction.",98,[[["self"]],["option",["instruction"]]]],[11,"as_dim","","Returns 'self' if it is a dimension",98,[[["self"]],["option",["dimension"]]]],[10,"def_variables","telamon::ir","Lists the variables defined at this statement.",98,[[["self"]],["vecset"]]],[10,"used_variables","","Lists the variables defined used at this statement.",98,[[["self"]],["vecset"]]],[11,"default","","",65,[[],["newobjs"]]],[11,"fmt","","",65,[[["self"],["formatter"]],["result"]]],[11,"add_instruction","","Registers a new instruction.",65,[[["self"],["instruction"]]]],[11,"add_dimension","","Registers a new dimension.",65,[[["self"],["dimension"]]]],[11,"add_stmt","","Registers a new statement",65,[[["self"],["statement"]]]],[11,"add_iteration_dim","","Sets a dimension as a new iteration dimension.",65,[[["self"],["instid"],["dimid"]]]],[11,"add_thread_dim","","Sets a dimension as a new thread dimension.",65,[[["self"],["dimid"]]]],[11,"add_mem_block","","Registers a new memory block.",65,[[["self"],["internalid"]]]],[11,"add_dim_mapping","","Adds a mapping between dimensions.",65,[[["self"],["dimmapping"]]]],[11,"add_variable","","",65,[[["self"],["variable"]]]],[11,"register_new_objs","","Adds the objects created by the lowering to the list of new objects.",66,[[["self"],["function"],["newobjs"]]]],[11,"mem_dimensions","","Returns the dimensions of the memory layout to create. For each dimension, gives a pair `(store dim, load dim)`.",66,[[["self"]],[""]]],[11,"store_dims","","Returns the dimensions that store the variable.",66,[[["self"]],[""]]],[11,"load_dims","","Returns the dimensions that load the variable.",66,[[["self"]],[""]]],[11,"next_mem","","",67,[[["self"]],["internalid"]]],[11,"next_inst","","",67,[[["self"]],["instid"]]],[11,"next_dim","","",67,[[["self"]],["dimid"]]],[11,"next_dim_mapping","","",67,[[["self"]],["dimmappingid"]]],[0,"model","telamon","Building Blocks for lower bound performance models.",N,N],[3,"HwPressure","telamon::model","The pressure on the hardware induced by a computation.",N,N],[3,"Nesting","","Nesting of an object.",N,N],[12,"inner_dims","","Dimensions nested inside the current Stmt.",99,N],[12,"inner_stmts","","Basic blocks nested inside the current Stmt.",99,N],[12,"outer_dims","","Dimensions nested outsidethe current Stmt.",99,N],[12,"before_self","","Dimensions to be processed before the current Stmt.",99,N],[12,"after_self","","Dimensions that should not take the current Stmt into account when processed.",99,N],[12,"bigger_merged_dims","","The dimensions that can be merged to this one and have a bigger ID.",99,N],[12,"num_unmapped_threads","","Number of threads that are not represented in the active dimensions of the block.",99,N],[12,"max_threads_per_block","","Maximal number of threads this block can be in, considering only outer dimensions (an not mapped out dimensions).",99,N],[4,"BottleneckLevel","","The level at which a bottleneck is computed.",N,N],[13,"Global","","",100,N],[13,"Block","","",100,N],[13,"Thread","","",100,N],[5,"bound","","Returns a lower bound on the execution time of all the implementation candidates in `space`, when executed in `context`.",N,[[["searchspace"],["context"]],["bound"]]],[11,"fmt","","",100,[[["self"],["formatter"]],["result"]]],[11,"clone","","",100,[[["self"]],["bottlenecklevel"]]],[11,"eq","","",100,[[["self"],["bottlenecklevel"]],["bool"]]],[11,"partial_cmp","","",100,[[["self"],["bottlenecklevel"]],["option",["ordering"]]]],[11,"cmp","","",100,[[["self"],["bottlenecklevel"]],["ordering"]]],[11,"accounts_for_dim","","Indicates if a dimension should be taken into account for the bottleneck level.",100,[[["self"],["dimkind"]],["bool"]]],[11,"fmt","","",100,[[["self"],["formatter"]],["result"]]],[11,"clone","","",101,[[["self"]],["hwpressure"]]],[11,"fmt","","",101,[[["self"],["formatter"]],["result"]]],[11,"new","","Creates a new `Pressure`",101,[[["f64"],["vec",["f64"]]],["self"]]],[11,"zero","","Creates a null `Pressure` for the given device.",101,[[["device"]],["self"]]],[11,"bound","","Derive a bound on the execution time from the pressure on the hardware.",101,[[["self"],["bottlenecklevel"],["hwpressure"]],["explainedbound",["rc"]]]],[11,"add_parallel","","Adds the pressure of another computation, performed in parallel.",101,[[["self"],["hwpressure"]]]],[11,"add_sequential","","Adds the pressure of another computation, performed sequentially.",101,[[["self"],["hwpressure"]]]],[11,"repeat_parallel","","Computes the pressure obtained by duplicating this one in parallel.",101,[[["self"],["f64"]]]],[11,"repeat_and_add_bottlenecks","","Adds the pressure of another computation, repeated in parallel. Ignores the latency.",101,[[["self"],["f64"],["hwpressure"]]]],[11,"repeat_sequential","","Computes the pressure obtained by repeating this one sequentially.",101,[[["self"],["f64"]]]],[11,"minimize","","Take the minimum of `self` and `other` for each bottleneck.",101,[[["self"],["hwpressure"]]]],[11,"min","","Returns the pointwise minimum of a serie of `HwPressure`",101,[[["it"]],["option"]]],[11,"multiply","","Pointwise multiplication of the pressure on each resource.",101,[[["self"],["hwpressure"]]]],[11,"fmt","","",99,[[["self"],["formatter"]],["result"]]],[0,"size","","Size evaluation and manipulation primitives.",N,N],[3,"Range","telamon::model::size","A span of values.",N,N],[12,"min","","",102,N],[12,"max","","",102,N],[3,"FactorRange","","A span of values, in term of factors. The actual value is a mulitpe of `gcd` and a divisor of `lcm`.",N,N],[12,"gcd","","",103,N],[12,"lcm","","",103,N],[5,"bounds","","Bounds the values a size can take, in the given context.",N,[[["partialsize"],["searchspace"],["context"]],["range"]]],[5,"dim_bounds","","Returns the `Range` a static dimension size can take.",N,[[["dimid"],["searchspace"]],["range"]]],[5,"factors","","Returns a factor and a multiple of `size`.",N,[[["partialsize"],["searchspace"],["context"]],["factorrange"]]],[5,"dim_factors","","Returns the `FactorRane` a static dimension size can take.",N,[[["dimid"],["searchspace"]],["factorrange"]]],[11,"fmt","","",102,[[["self"],["formatter"]],["result"]]],[11,"clone","","",102,[[["self"]],["range"]]],[18,"ZERO","","",102,N],[18,"ONE","","",102,N],[11,"new_fixed","","Creates a `Range` containing a single value.",102,[[["u64"]],["self"]]],[11,"is_constrained","","Indicates if the `Range` contains a single value.",102,[[["self"]],["bool"]]],[11,"fmt","","",103,[[["self"],["formatter"]],["result"]]],[11,"clone","","",103,[[["self"]],["factorrange"]]],[18,"ZERO","","",103,N],[11,"new_fixed","","Create a `FactorRange` containing a single point.",103,[[["u64"]],["self"]]],[6,"Bound","telamon::model","A lower bound on the execution time, with a detailed explanation of the origin of the bound.",N,N],[0,"search_space","telamon","Search space datastructures and constraint propagation.",N,N],[3,"Bool","telamon::search_space","",N,N],[3,"DimKind","","Specifies how iteration dimensions are implemented.",N,N],[3,"DomainStore","","Stores the domains of each variable.",N,N],[3,"InstFlag","","Specifies the version of an instruction to use.",N,N],[3,"MemSpace","","Indicates where a memory block is located.",N,N],[3,"Order","","Defines how two statements are ordered.",N,N],[3,"ThreadMapping","","Indicates how are thread dimensions mapped on the GPU.",N,N],[3,"SearchSpace","","A partially specified implementation.",N,N],[4,"Action","","A decision to apply to the domain.",N,N],[13,"InstFlag","","cbindgen:field-names=[inst, domain]",104,N],[13,"Size","","cbindgen:field-names=[dim, domain]",104,N],[13,"IsThreadDim","","cbindgen:field-names=[dim, domain]",104,N],[13,"ThreadMapping","","cbindgen:field-names=[lhs, rhs, domain]",104,N],[13,"IsIterationDim","","cbindgen:field-names=[inst, dim, domain]",104,N],[13,"MemSpace","","cbindgen:field-names=[mem, domain]",104,N],[13,"DimKind","","cbindgen:field-names=[dim, domain]",104,N],[13,"Order","","cbindgen:field-names=[lhs, rhs, domain]",104,N],[13,"DimMapping","","cbindgen:field-names=[lhs, rhs, domain]",104,N],[13,"IncrementTilingFactor","","cbindgen:field-names=[logical, dim, domain]",104,N],[13,"TilingFactor","","cbindgen:field-names=[logical, domain]",104,N],[13,"IsThreadDimClassCounter","","cbindgen:field-names=[dim, domain]",104,N],[13,"NumThreads","","cbindgen:field-names=[domain]",104,N],[13,"NumThreadDims","","cbindgen:field-names=[domain]",104,N],[13,"IsIterationDimClassCounter","","cbindgen:field-names=[inst, dim, domain]",104,N],[13,"IncrementMemSize","","cbindgen:field-names=[mem, lhs, rhs, domain]",104,N],[13,"MemSize","","cbindgen:field-names=[mem, domain]",104,N],[13,"SharedMemUsed","","cbindgen:field-names=[domain]",104,N],[13,"IncrementUnrollFactor","","cbindgen:field-names=[inst, dim, domain]",104,N],[13,"UnrollFactor","","cbindgen:field-names=[inst, domain]",104,N],[13,"IncrementNumBlockDims","","cbindgen:field-names=[inst, dim, domain]",104,N],[13,"NumBlockDims","","cbindgen:field-names=[inst, domain]",104,N],[13,"NumNestedInst","","cbindgen:field-names=[dim, domain]",104,N],[4,"Choice","","",N,N],[13,"InstFlag","","cbindgen:field-names=[inst, domain]",105,N],[13,"Size","","cbindgen:field-names=[dim, domain]",105,N],[13,"IsThreadDim","","cbindgen:field-names=[dim, domain]",105,N],[13,"ThreadMapping","","cbindgen:field-names=[lhs, rhs, domain]",105,N],[13,"IsIterationDim","","cbindgen:field-names=[inst, dim, domain]",105,N],[13,"MemSpace","","cbindgen:field-names=[mem, domain]",105,N],[13,"DimKind","","cbindgen:field-names=[dim, domain]",105,N],[13,"Order","","cbindgen:field-names=[lhs, rhs, domain]",105,N],[13,"DimMapping","","cbindgen:field-names=[lhs, rhs, domain]",105,N],[13,"IncrementTilingFactor","","cbindgen:field-names=[logical, dim, domain]",105,N],[13,"TilingFactor","","cbindgen:field-names=[logical, domain]",105,N],[13,"IsThreadDimClassCounter","","cbindgen:field-names=[dim, domain]",105,N],[13,"NumThreads","","cbindgen:field-names=[domain]",105,N],[13,"NumThreadDims","","cbindgen:field-names=[domain]",105,N],[13,"IsIterationDimClassCounter","","cbindgen:field-names=[inst, dim, domain]",105,N],[13,"IncrementMemSize","","cbindgen:field-names=[mem, lhs, rhs, domain]",105,N],[13,"MemSize","","cbindgen:field-names=[mem, domain]",105,N],[13,"SharedMemUsed","","cbindgen:field-names=[domain]",105,N],[13,"IncrementUnrollFactor","","cbindgen:field-names=[inst, dim, domain]",105,N],[13,"UnrollFactor","","cbindgen:field-names=[inst, domain]",105,N],[13,"IncrementNumBlockDims","","cbindgen:field-names=[inst, dim, domain]",105,N],[13,"NumBlockDims","","cbindgen:field-names=[inst, domain]",105,N],[13,"NumNestedInst","","cbindgen:field-names=[dim, domain]",105,N],[11,"clone","","",106,[[["self"]],["domainstore"]]],[11,"fmt","","",106,[[["self"],["formatter"]],["result"]]],[11,"default","","",106,[[],["domainstore"]]],[11,"new","","Creates a new domain store and allocates the variables for the given BBMap.",106,[[["function"]],["self"]]],[11,"alloc","","Allocates the choices when new objects are created.",106,[[["self"],["function"],["newobjs"]]]],[11,"get_inst_flag","","Returns the domain of {name} for the given arguments.",106,[[["self"],["instid"]],["instflag"]]],[11,"get_old_inst_flag","","Returns the domain of {name} for the given arguments. If the domain has been restricted but the change not yet applied, returns the old value.",106,[[["self"],["instid"],["domaindiff"]],["instflag"]]],[11,"set_inst_flag","","Sets the domain of {name} for the given arguments.",106,[[["self"],["instid"],["instflag"]]]],[11,"restrict_inst_flag","","Restricts the domain of {name} for the given arguments. Put the old value in `diff` and indicates if the new domain is failed.",106,[[["self"],["instid"],["instflag"],["domaindiff"]],["result"]]],[11,"get_size","","Returns the domain of {name} for the given arguments.",106,[[["self"],["dimid"]],["numericset"]]],[11,"get_old_size","","Returns the domain of {name} for the given arguments. If the domain has been restricted but the change not yet applied, returns the old value.",106,[[["self"],["dimid"],["domaindiff"]],["numericset"]]],[11,"set_size","","Sets the domain of {name} for the given arguments.",106,[[["self"],["dimid"],["numericset"]]]],[11,"restrict_size","","Restricts the domain of {name} for the given arguments. Put the old value in `diff` and indicates if the new domain is failed.",106,[[["self"],["dimid"],["numericset"],["domaindiff"]],["result"]]],[11,"get_is_thread_dim","","Returns the domain of {name} for the given arguments.",106,[[["self"],["dimid"]],["bool"]]],[11,"get_old_is_thread_dim","","Returns the domain of {name} for the given arguments. If the domain has been restricted but the change not yet applied, returns the old value.",106,[[["self"],["dimid"],["domaindiff"]],["bool"]]],[11,"set_is_thread_dim","","Sets the domain of {name} for the given arguments.",106,[[["self"],["dimid"],["bool"]]]],[11,"restrict_is_thread_dim","","Restricts the domain of {name} for the given arguments. Put the old value in `diff` and indicates if the new domain is failed.",106,[[["self"],["dimid"],["bool"],["domaindiff"]],["result"]]],[11,"get_thread_mapping","","Returns the domain of {name} for the given arguments.",106,[[["self"],["dimid"],["dimid"]],["threadmapping"]]],[11,"get_old_thread_mapping","","Returns the domain of {name} for the given arguments. If the domain has been restricted but the change not yet applied, returns the old value.",106,[[["self"],["dimid"],["dimid"],["domaindiff"]],["threadmapping"]]],[11,"set_thread_mapping","","Sets the domain of {name} for the given arguments.",106,[[["self"],["dimid"],["dimid"],["threadmapping"]]]],[11,"restrict_thread_mapping","","Restricts the domain of {name} for the given arguments. Put the old value in `diff` and indicates if the new domain is failed.",106,[[["self"],["dimid"],["dimid"],["threadmapping"],["domaindiff"]],["result"]]],[11,"get_is_iteration_dim","","Returns the domain of {name} for the given arguments.",106,[[["self"],["instid"],["dimid"]],["bool"]]],[11,"get_old_is_iteration_dim","","Returns the domain of {name} for the given arguments. If the domain has been restricted but the change not yet applied, returns the old value.",106,[[["self"],["instid"],["dimid"],["domaindiff"]],["bool"]]],[11,"set_is_iteration_dim","","Sets the domain of {name} for the given arguments.",106,[[["self"],["instid"],["dimid"],["bool"]]]],[11,"restrict_is_iteration_dim","","Restricts the domain of {name} for the given arguments. Put the old value in `diff` and indicates if the new domain is failed.",106,[[["self"],["instid"],["dimid"],["bool"],["domaindiff"]],["result"]]],[11,"get_mem_space","","Returns the domain of {name} for the given arguments.",106,[[["self"],["memid"]],["memspace"]]],[11,"get_old_mem_space","","Returns the domain of {name} for the given arguments. If the domain has been restricted but the change not yet applied, returns the old value.",106,[[["self"],["memid"],["domaindiff"]],["memspace"]]],[11,"set_mem_space","","Sets the domain of {name} for the given arguments.",106,[[["self"],["memid"],["memspace"]]]],[11,"restrict_mem_space","","Restricts the domain of {name} for the given arguments. Put the old value in `diff` and indicates if the new domain is failed.",106,[[["self"],["memid"],["memspace"],["domaindiff"]],["result"]]],[11,"get_dim_kind","","Returns the domain of {name} for the given arguments.",106,[[["self"],["dimid"]],["dimkind"]]],[11,"get_old_dim_kind","","Returns the domain of {name} for the given arguments. If the domain has been restricted but the change not yet applied, returns the old value.",106,[[["self"],["dimid"],["domaindiff"]],["dimkind"]]],[11,"set_dim_kind","","Sets the domain of {name} for the given arguments.",106,[[["self"],["dimid"],["dimkind"]]]],[11,"restrict_dim_kind","","Restricts the domain of {name} for the given arguments. Put the old value in `diff` and indicates if the new domain is failed.",106,[[["self"],["dimid"],["dimkind"],["domaindiff"]],["result"]]],[11,"get_order","","Returns the domain of {name} for the given arguments.",106,[[["self"],["stmtid"],["stmtid"]],["order"]]],[11,"get_old_order","","Returns the domain of {name} for the given arguments. If the domain has been restricted but the change not yet applied, returns the old value.",106,[[["self"],["stmtid"],["stmtid"],["domaindiff"]],["order"]]],[11,"set_order","","Sets the domain of {name} for the given arguments.",106,[[["self"],["stmtid"],["stmtid"],["order"]]]],[11,"restrict_order","","Restricts the domain of {name} for the given arguments. Put the old value in `diff` and indicates if the new domain is failed.",106,[[["self"],["stmtid"],["stmtid"],["order"],["domaindiff"]],["result"]]],[11,"get_dim_mapping","","Returns the domain of {name} for the given arguments.",106,[[["self"],["dimid"],["dimid"]],["dimmapping"]]],[11,"get_old_dim_mapping","","Returns the domain of {name} for the given arguments. If the domain has been restricted but the change not yet applied, returns the old value.",106,[[["self"],["dimid"],["dimid"],["domaindiff"]],["dimmapping"]]],[11,"set_dim_mapping","","Sets the domain of {name} for the given arguments.",106,[[["self"],["dimid"],["dimid"],["dimmapping"]]]],[11,"restrict_dim_mapping","","Restricts the domain of {name} for the given arguments. Put the old value in `diff` and indicates if the new domain is failed.",106,[[["self"],["dimid"],["dimid"],["dimmapping"],["domaindiff"]],["result"]]],[11,"get_increment_tiling_factor","","Returns the domain of {name} for the given arguments.",106,[[["self"],["logicaldimid"],["dimid"]],["bool"]]],[11,"get_old_increment_tiling_factor","","Returns the domain of {name} for the given arguments. If the domain has been restricted but the change not yet applied, returns the old value.",106,[[["self"],["logicaldimid"],["dimid"],["domaindiff"]],["bool"]]],[11,"set_increment_tiling_factor","","Sets the domain of {name} for the given arguments.",106,[[["self"],["logicaldimid"],["dimid"],["bool"]]]],[11,"restrict_increment_tiling_factor","","Restricts the domain of {name} for the given arguments. Put the old value in `diff` and indicates if the new domain is failed.",106,[[["self"],["logicaldimid"],["dimid"],["bool"],["domaindiff"]],["result"]]],[11,"get_tiling_factor","","Returns the domain of {name} for the given arguments.",106,[[["self"],["logicaldimid"]],["range"]]],[11,"get_old_tiling_factor","","Returns the domain of {name} for the given arguments. If the domain has been restricted but the change not yet applied, returns the old value.",106,[[["self"],["logicaldimid"],["domaindiff"]],["range"]]],[11,"set_tiling_factor","","Sets the domain of {name} for the given arguments.",106,[[["self"],["logicaldimid"],["range"]]]],[11,"restrict_tiling_factor","","Restricts the domain of {name} for the given arguments. Put the old value in `diff` and indicates if the new domain is failed.",106,[[["self"],["logicaldimid"],["range"],["domaindiff"]],["result"]]],[11,"get_is_thread_dim_class_counter","","Returns the domain of {name} for the given arguments.",106,[[["self"],["dimid"]],["range"]]],[11,"get_old_is_thread_dim_class_counter","","Returns the domain of {name} for the given arguments. If the domain has been restricted but the change not yet applied, returns the old value.",106,[[["self"],["dimid"],["domaindiff"]],["range"]]],[11,"set_is_thread_dim_class_counter","","Sets the domain of {name} for the given arguments.",106,[[["self"],["dimid"],["range"]]]],[11,"restrict_is_thread_dim_class_counter","","Restricts the domain of {name} for the given arguments. Put the old value in `diff` and indicates if the new domain is failed.",106,[[["self"],["dimid"],["range"],["domaindiff"]],["result"]]],[11,"get_num_threads","","Returns the domain of {name} for the given arguments.",106,[[["self"]],["halfrange"]]],[11,"get_old_num_threads","","Returns the domain of {name} for the given arguments. If the domain has been restricted but the change not yet applied, returns the old value.",106,[[["self"],["domaindiff"]],["halfrange"]]],[11,"set_num_threads","","Sets the domain of {name} for the given arguments.",106,[[["self"],["halfrange"]]]],[11,"restrict_num_threads","","Restricts the domain of {name} for the given arguments. Put the old value in `diff` and indicates if the new domain is failed.",106,[[["self"],["halfrange"],["domaindiff"]],["result"]]],[11,"get_num_thread_dims","","Returns the domain of {name} for the given arguments.",106,[[["self"]],["halfrange"]]],[11,"get_old_num_thread_dims","","Returns the domain of {name} for the given arguments. If the domain has been restricted but the change not yet applied, returns the old value.",106,[[["self"],["domaindiff"]],["halfrange"]]],[11,"set_num_thread_dims","","Sets the domain of {name} for the given arguments.",106,[[["self"],["halfrange"]]]],[11,"restrict_num_thread_dims","","Restricts the domain of {name} for the given arguments. Put the old value in `diff` and indicates if the new domain is failed.",106,[[["self"],["halfrange"],["domaindiff"]],["result"]]],[11,"get_is_iteration_dim_class_counter","","Returns the domain of {name} for the given arguments.",106,[[["self"],["instid"],["dimid"]],["range"]]],[11,"get_old_is_iteration_dim_class_counter","","Returns the domain of {name} for the given arguments. If the domain has been restricted but the change not yet applied, returns the old value.",106,[[["self"],["instid"],["dimid"],["domaindiff"]],["range"]]],[11,"set_is_iteration_dim_class_counter","","Sets the domain of {name} for the given arguments.",106,[[["self"],["instid"],["dimid"],["range"]]]],[11,"restrict_is_iteration_dim_class_counter","","Restricts the domain of {name} for the given arguments. Put the old value in `diff` and indicates if the new domain is failed.",106,[[["self"],["instid"],["dimid"],["range"],["domaindiff"]],["result"]]],[11,"get_increment_mem_size","","Returns the domain of {name} for the given arguments.",106,[[["self"],["internalid"],["dimid"],["dimid"]],["bool"]]],[11,"get_old_increment_mem_size","","Returns the domain of {name} for the given arguments. If the domain has been restricted but the change not yet applied, returns the old value.",106,[[["self"],["internalid"],["dimid"],["dimid"],["domaindiff"]],["bool"]]],[11,"set_increment_mem_size","","Sets the domain of {name} for the given arguments.",106,[[["self"],["internalid"],["dimid"],["dimid"],["bool"]]]],[11,"restrict_increment_mem_size","","Restricts the domain of {name} for the given arguments. Put the old value in `diff` and indicates if the new domain is failed.",106,[[["self"],["internalid"],["dimid"],["dimid"],["bool"],["domaindiff"]],["result"]]],[11,"get_mem_size","","Returns the domain of {name} for the given arguments.",106,[[["self"],["internalid"]],["halfrange"]]],[11,"get_old_mem_size","","Returns the domain of {name} for the given arguments. If the domain has been restricted but the change not yet applied, returns the old value.",106,[[["self"],["internalid"],["domaindiff"]],["halfrange"]]],[11,"set_mem_size","","Sets the domain of {name} for the given arguments.",106,[[["self"],["internalid"],["halfrange"]]]],[11,"restrict_mem_size","","Restricts the domain of {name} for the given arguments. Put the old value in `diff` and indicates if the new domain is failed.",106,[[["self"],["internalid"],["halfrange"],["domaindiff"]],["result"]]],[11,"get_shared_mem_used","","Returns the domain of {name} for the given arguments.",106,[[["self"]],["halfrange"]]],[11,"get_old_shared_mem_used","","Returns the domain of {name} for the given arguments. If the domain has been restricted but the change not yet applied, returns the old value.",106,[[["self"],["domaindiff"]],["halfrange"]]],[11,"set_shared_mem_used","","Sets the domain of {name} for the given arguments.",106,[[["self"],["halfrange"]]]],[11,"restrict_shared_mem_used","","Restricts the domain of {name} for the given arguments. Put the old value in `diff` and indicates if the new domain is failed.",106,[[["self"],["halfrange"],["domaindiff"]],["result"]]],[11,"get_increment_unroll_factor","","Returns the domain of {name} for the given arguments.",106,[[["self"],["instid"],["dimid"]],["bool"]]],[11,"get_old_increment_unroll_factor","","Returns the domain of {name} for the given arguments. If the domain has been restricted but the change not yet applied, returns the old value.",106,[[["self"],["instid"],["dimid"],["domaindiff"]],["bool"]]],[11,"set_increment_unroll_factor","","Sets the domain of {name} for the given arguments.",106,[[["self"],["instid"],["dimid"],["bool"]]]],[11,"restrict_increment_unroll_factor","","Restricts the domain of {name} for the given arguments. Put the old value in `diff` and indicates if the new domain is failed.",106,[[["self"],["instid"],["dimid"],["bool"],["domaindiff"]],["result"]]],[11,"get_unroll_factor","","Returns the domain of {name} for the given arguments.",106,[[["self"],["instid"]],["halfrange"]]],[11,"get_old_unroll_factor","","Returns the domain of {name} for the given arguments. If the domain has been restricted but the change not yet applied, returns the old value.",106,[[["self"],["instid"],["domaindiff"]],["halfrange"]]],[11,"set_unroll_factor","","Sets the domain of {name} for the given arguments.",106,[[["self"],["instid"],["halfrange"]]]],[11,"restrict_unroll_factor","","Restricts the domain of {name} for the given arguments. Put the old value in `diff` and indicates if the new domain is failed.",106,[[["self"],["instid"],["halfrange"],["domaindiff"]],["result"]]],[11,"get_increment_num_block_dims","","Returns the domain of {name} for the given arguments.",106,[[["self"],["instid"],["dimid"]],["bool"]]],[11,"get_old_increment_num_block_dims","","Returns the domain of {name} for the given arguments. If the domain has been restricted but the change not yet applied, returns the old value.",106,[[["self"],["instid"],["dimid"],["domaindiff"]],["bool"]]],[11,"set_increment_num_block_dims","","Sets the domain of {name} for the given arguments.",106,[[["self"],["instid"],["dimid"],["bool"]]]],[11,"restrict_increment_num_block_dims","","Restricts the domain of {name} for the given arguments. Put the old value in `diff` and indicates if the new domain is failed.",106,[[["self"],["instid"],["dimid"],["bool"],["domaindiff"]],["result"]]],[11,"get_num_block_dims","","Returns the domain of {name} for the given arguments.",106,[[["self"],["instid"]],["halfrange"]]],[11,"get_old_num_block_dims","","Returns the domain of {name} for the given arguments. If the domain has been restricted but the change not yet applied, returns the old value.",106,[[["self"],["instid"],["domaindiff"]],["halfrange"]]],[11,"set_num_block_dims","","Sets the domain of {name} for the given arguments.",106,[[["self"],["instid"],["halfrange"]]]],[11,"restrict_num_block_dims","","Restricts the domain of {name} for the given arguments. Put the old value in `diff` and indicates if the new domain is failed.",106,[[["self"],["instid"],["halfrange"],["domaindiff"]],["result"]]],[11,"get_num_nested_inst","","Returns the domain of {name} for the given arguments.",106,[[["self"],["dimid"]],["halfrange"]]],[11,"get_old_num_nested_inst","","Returns the domain of {name} for the given arguments. If the domain has been restricted but the change not yet applied, returns the old value.",106,[[["self"],["dimid"],["domaindiff"]],["halfrange"]]],[11,"set_num_nested_inst","","Sets the domain of {name} for the given arguments.",106,[[["self"],["dimid"],["halfrange"]]]],[11,"restrict_num_nested_inst","","Restricts the domain of {name} for the given arguments. Put the old value in `diff` and indicates if the new domain is failed.",106,[[["self"],["dimid"],["halfrange"],["domaindiff"]],["result"]]],[11,"clone","","",107,[[["self"]],["bool"]]],[11,"eq","","",107,[[["self"],["bool"]],["bool"]]],[11,"ne","","",107,[[["self"],["bool"]],["bool"]]],[11,"hash","","",107,N],[18,"TRUE","","",107,N],[18,"FALSE","","",107,N],[18,"ALL","","",107,N],[18,"FAILED","","Returns the empty domain.",107,N],[11,"all","","Returns the full domain.",107,[[],["self"]]],[11,"insert","","Insert values in the domain.",107,[[["self"],["self"]]]],[11,"list","","Lists the alternatives contained in the domain.",107,[[["self"]],[""]]],[11,"eq","","Indicates if two choices will have the same value.",107,[[["self"],["self"]],["bool"]]],[11,"neq","","Indicates if two choices cannot be equal.",107,[[["self"],["self"]],["bool"]]],[11,"is_failed","","",107,[[["self"]],["bool"]]],[11,"is_constrained","","",107,[[["self"]],["bool"]]],[11,"contains","","",107,[[["self"],["self"]],["bool"]]],[11,"intersects","","",107,[[["self"],["self"]],["bool"]]],[11,"restrict","","",107,[[["self"],["self"]]]],[11,"bitand","","",107,[[["self"],["self"]],["self"]]],[11,"bitor","","",107,[[["self"],["self"]],["self"]]],[11,"bitxor","","",107,[[["self"],["self"]],["self"]]],[11,"not","","",107,[[["self"]],["self"]]],[11,"bitor_assign","","",107,[[["self"],["self"]]]],[11,"bitand_assign","","",107,[[["self"],["self"]]]],[11,"fmt","","",107,[[["self"],["formatter"]],["result"]]],[11,"clone","","",108,[[["self"]],["instflag"]]],[11,"eq","","",108,[[["self"],["instflag"]],["bool"]]],[11,"ne","","",108,[[["self"],["instflag"]],["bool"]]],[11,"hash","","",108,N],[18,"MEM_CA","","Access the global memory using both L1 and L2 cache. Coherence is not guaranteed between blocks.",108,N],[18,"MEM_CG","","Access the global memory using the L2 cache.",108,N],[18,"MEM_CS","","Access the global memory without using caches.",108,N],[18,"MEM_NC","","Access the global memory using the read-only cache. Coherence is not guaranteed.",108,N],[18,"MEM_SHARED","","Access the shared memory.",108,N],[18,"MEM_GLOBAL","","Access the global memory.",108,N],[18,"MEM_COHERENT","","Ensure coherency between memory accesses.",108,N],[18,"MEM_BLOCK_COHERENT","","Ensure coherency within a block between memory accesses.",108,N],[18,"ALL","","",108,N],[18,"FAILED","","Returns the empty domain.",108,N],[11,"all","","Returns the full domain.",108,[[],["self"]]],[11,"insert","","Insert values in the domain.",108,[[["self"],["self"]]]],[11,"list","","Lists the alternatives contained in the domain.",108,[[["self"]],[""]]],[11,"eq","","Indicates if two choices will have the same value.",108,[[["self"],["self"]],["bool"]]],[11,"neq","","Indicates if two choices cannot be equal.",108,[[["self"],["self"]],["bool"]]],[11,"is_failed","","",108,[[["self"]],["bool"]]],[11,"is_constrained","","",108,[[["self"]],["bool"]]],[11,"contains","","",108,[[["self"],["self"]],["bool"]]],[11,"intersects","","",108,[[["self"],["self"]],["bool"]]],[11,"restrict","","",108,[[["self"],["self"]]]],[11,"bitand","","",108,[[["self"],["self"]],["self"]]],[11,"bitor","","",108,[[["self"],["self"]],["self"]]],[11,"bitxor","","",108,[[["self"],["self"]],["self"]]],[11,"not","","",108,[[["self"]],["self"]]],[11,"bitor_assign","","",108,[[["self"],["self"]]]],[11,"bitand_assign","","",108,[[["self"],["self"]]]],[11,"fmt","","",108,[[["self"],["formatter"]],["result"]]],[11,"clone","","",109,[[["self"]],["threadmapping"]]],[11,"eq","","",109,[[["self"],["threadmapping"]],["bool"]]],[11,"ne","","",109,[[["self"],["threadmapping"]],["bool"]]],[11,"hash","","",109,N],[18,"MAPPED_OUT","","The two dimensions are threads, but `lhs` is mapped to a dimension outside of `rhs`.",109,N],[18,"MAPPED_IN","","The two dimensions are threads, but `lhs` is mapped to a dimension inside of `rhs`.",109,N],[18,"NOT_THREADS","","One of the dimensions is a not thread.",109,N],[18,"MAPPED","","The two dimensions are threads mapped to the same dimension on the GPU.",109,N],[18,"ALL","","",109,N],[18,"FAILED","","Returns the empty domain.",109,N],[11,"all","","Returns the full domain.",109,[[],["self"]]],[11,"insert","","Insert values in the domain.",109,[[["self"],["self"]]]],[11,"list","","Lists the alternatives contained in the domain.",109,[[["self"]],[""]]],[11,"eq","","Indicates if two choices will have the same value.",109,[[["self"],["self"]],["bool"]]],[11,"neq","","Indicates if two choices cannot be equal.",109,[[["self"],["self"]],["bool"]]],[11,"inverse","","",109,[[["self"]],["self"]]],[11,"is_failed","","",109,[[["self"]],["bool"]]],[11,"is_constrained","","",109,[[["self"]],["bool"]]],[11,"contains","","",109,[[["self"],["self"]],["bool"]]],[11,"intersects","","",109,[[["self"],["self"]],["bool"]]],[11,"restrict","","",109,[[["self"],["self"]]]],[11,"bitand","","",109,[[["self"],["self"]],["self"]]],[11,"bitor","","",109,[[["self"],["self"]],["self"]]],[11,"bitxor","","",109,[[["self"],["self"]],["self"]]],[11,"not","","",109,[[["self"]],["self"]]],[11,"bitor_assign","","",109,[[["self"],["self"]]]],[11,"bitand_assign","","",109,[[["self"],["self"]]]],[11,"fmt","","",109,[[["self"],["formatter"]],["result"]]],[11,"clone","","",110,[[["self"]],["memspace"]]],[11,"eq","","",110,[[["self"],["memspace"]],["bool"]]],[11,"ne","","",110,[[["self"],["memspace"]],["bool"]]],[11,"hash","","",110,N],[18,"GLOBAL","","The block is in the device RAM.",110,N],[18,"SHARED","","The block is in the memory shared between the threads of a block.",110,N],[18,"ALL","","",110,N],[18,"FAILED","","Returns the empty domain.",110,N],[11,"all","","Returns the full domain.",110,[[],["self"]]],[11,"insert","","Insert values in the domain.",110,[[["self"],["self"]]]],[11,"list","","Lists the alternatives contained in the domain.",110,[[["self"]],[""]]],[11,"eq","","Indicates if two choices will have the same value.",110,[[["self"],["self"]],["bool"]]],[11,"neq","","Indicates if two choices cannot be equal.",110,[[["self"],["self"]],["bool"]]],[11,"is_failed","","",110,[[["self"]],["bool"]]],[11,"is_constrained","","",110,[[["self"]],["bool"]]],[11,"contains","","",110,[[["self"],["self"]],["bool"]]],[11,"intersects","","",110,[[["self"],["self"]],["bool"]]],[11,"restrict","","",110,[[["self"],["self"]]]],[11,"bitand","","",110,[[["self"],["self"]],["self"]]],[11,"bitor","","",110,[[["self"],["self"]],["self"]]],[11,"bitxor","","",110,[[["self"],["self"]],["self"]]],[11,"not","","",110,[[["self"]],["self"]]],[11,"bitor_assign","","",110,[[["self"],["self"]]]],[11,"bitand_assign","","",110,[[["self"],["self"]]]],[11,"fmt","","",110,[[["self"],["formatter"]],["result"]]],[11,"clone","","",111,[[["self"]],["dimkind"]]],[11,"eq","","",111,[[["self"],["dimkind"]],["bool"]]],[11,"ne","","",111,[[["self"],["dimkind"]],["bool"]]],[11,"hash","","",111,N],[18,"LOOP","","The dimension is implemented as a regular loop.",111,N],[18,"UNROLL","","The dimension is fully unrolled.",111,N],[18,"VECTOR","","The dimension is implemented by using a vector instruction.",111,N],[18,"BLOCK","","The dimension is mapped to a block dimension on the device.",111,N],[18,"THREAD","","The dimension is mapped to a thread dimension on the device.",111,N],[18,"PARALLEL","","The dimension is parallel.",111,N],[18,"SEQUENTIAL","","The dimension is sequential.",111,N],[18,"ALL","","",111,N],[18,"FAILED","","Returns the empty domain.",111,N],[11,"all","","Returns the full domain.",111,[[],["self"]]],[11,"insert","","Insert values in the domain.",111,[[["self"],["self"]]]],[11,"list","","Lists the alternatives contained in the domain.",111,[[["self"]],[""]]],[11,"eq","","Indicates if two choices will have the same value.",111,[[["self"],["self"]],["bool"]]],[11,"neq","","Indicates if two choices cannot be equal.",111,[[["self"],["self"]],["bool"]]],[11,"is_failed","","",111,[[["self"]],["bool"]]],[11,"is_constrained","","",111,[[["self"]],["bool"]]],[11,"contains","","",111,[[["self"],["self"]],["bool"]]],[11,"intersects","","",111,[[["self"],["self"]],["bool"]]],[11,"restrict","","",111,[[["self"],["self"]]]],[11,"bitand","","",111,[[["self"],["self"]],["self"]]],[11,"bitor","","",111,[[["self"],["self"]],["self"]]],[11,"bitxor","","",111,[[["self"],["self"]],["self"]]],[11,"not","","",111,[[["self"]],["self"]]],[11,"bitor_assign","","",111,[[["self"],["self"]]]],[11,"bitand_assign","","",111,[[["self"],["self"]]]],[11,"fmt","","",111,[[["self"],["formatter"]],["result"]]],[11,"clone","","",112,[[["self"]],["order"]]],[11,"eq","","",112,[[["self"],["order"]],["bool"]]],[11,"ne","","",112,[[["self"],["order"]],["bool"]]],[11,"hash","","",112,N],[18,"BEFORE","","$lhs is executed before $rhs.",112,N],[18,"AFTER","","$lhs is executed after $rhs.",112,N],[18,"INNER","","$lhs is nested inside $rhs.",112,N],[18,"OUTER","","$rhs is nested outside $rhs.",112,N],[18,"MERGED","","$lhs and $rhs are merged.",112,N],[18,"NESTED","","$lhs and $rhs are nested.",112,N],[18,"ORDERED","","$lhs and $rhs are sequentially ordered.",112,N],[18,"ALL","","",112,N],[18,"FAILED","","Returns the empty domain.",112,N],[11,"all","","Returns the full domain.",112,[[],["self"]]],[11,"insert","","Insert values in the domain.",112,[[["self"],["self"]]]],[11,"list","","Lists the alternatives contained in the domain.",112,[[["self"]],[""]]],[11,"eq","","Indicates if two choices will have the same value.",112,[[["self"],["self"]],["bool"]]],[11,"neq","","Indicates if two choices cannot be equal.",112,[[["self"],["self"]],["bool"]]],[11,"inverse","","",112,[[["self"]],["self"]]],[11,"is_failed","","",112,[[["self"]],["bool"]]],[11,"is_constrained","","",112,[[["self"]],["bool"]]],[11,"contains","","",112,[[["self"],["self"]],["bool"]]],[11,"intersects","","",112,[[["self"],["self"]],["bool"]]],[11,"restrict","","",112,[[["self"],["self"]]]],[11,"bitand","","",112,[[["self"],["self"]],["self"]]],[11,"bitor","","",112,[[["self"],["self"]],["self"]]],[11,"bitxor","","",112,[[["self"],["self"]],["self"]]],[11,"not","","",112,[[["self"]],["self"]]],[11,"bitor_assign","","",112,[[["self"],["self"]]]],[11,"bitand_assign","","",112,[[["self"],["self"]]]],[11,"fmt","","",112,[[["self"],["formatter"]],["result"]]],[11,"eq","","",105,[[["self"],["choice"]],["bool"]]],[11,"ne","","",105,[[["self"],["choice"]],["bool"]]],[11,"fmt","","",105,[[["self"],["formatter"]],["result"]]],[11,"clone","","",105,[[["self"]],["choice"]]],[11,"from","","",105,[[["action"]],["choice"]]],[11,"eq","","",104,[[["self"],["action"]],["bool"]]],[11,"ne","","",104,[[["self"],["action"]],["bool"]]],[11,"fmt","","",104,[[["self"],["formatter"]],["result"]]],[11,"clone","","",104,[[["self"]],["action"]]],[11,"complement","","Returns the action performing the complementary decision.",104,[[["self"],["function"]],["option"]]],[8,"Domain","","",N,N],[10,"is_failed","","Indicates if the domain is empty.",113,[[["self"]],["bool"]]],[10,"is_constrained","","Indicates if the domain contains a single alternative.",113,[[["self"]],["bool"]]],[10,"contains","","Indicates if the domain contains another.",113,[[["self"],["self"]],["bool"]]],[10,"restrict","","Restricts the domain to the intersection with `other`.",113,[[["self"],["self"]]]],[11,"intersects","","Indicates if the domain has an alternatve in common with `other`.",113,[[["self"],["self"]],["bool"]]],[11,"is","","Indicates if the domain is equal to another domain.",113,[[["self"],["self"]],["trivalent"]]],[8,"NumSet","","A domain containing integers.",N,N],[16,"Universe","","",114,N],[10,"min","","Returns the maximum value in the domain.",114,N],[10,"max","","Returns the minimum value in the domain.",114,N],[11,"into_num_set","","Converts the domain into a numeric set with the given domain. Values that are not in `new_universe` are skipped.",114,N],[11,"as_constrained","","Returns the value of the domain, if it is constrained.",114,N],[11,"lt","","",114,N],[11,"gt","","",114,N],[11,"leq","","",114,N],[11,"geq","","",114,N],[11,"eq","","",114,N],[11,"neq","","",114,N],[11,"clone","","",115,[[["self"]],["searchspace"]]],[11,"new","","Creates a new `SearchSpace` for the given `ir_instance`.",115,[[["function"],["vec",["action"]]],["result"]]],[11,"ir_instance","","Returns the underlying ir instance.",115,[[["self"]],["function"]]],[11,"domain","","Returns the domain of choices.",115,[[["self"]],["domainstore"]]],[11,"domain_mut","","Allows rewritting the domain.",115,[[["self"]],["domainstore"]]],[11,"apply_decisions","","Applies a list of decisions to the domain and propagate constraints.",115,[[["self"],["vec",["action"]]],["result"]]],[11,"lower_layout","","Triggers a layout lowering.",115,[[["self"],["internalid"],["vec",["dimid"]],["vec",["dimid"]]],["result"]]],[11,"print_lt_int","telamon::codegen","Prints a scalar less-than on integers.",16,[[["self"],["type"],["str"],["str"],["str"]]]],[11,"print_equals","","Prints a scalar equals instruction.",16,[[["self"],["type"],["str"],["str"],["str"]]]],[11,"print_add_int","","Prints a scalar addition on integers.",16,[[["self"],["type"],["str"],["str"],["str"]]]],[11,"print_and","","Prints an AND operation.",16,[[["self"],["type"],["str"],["str"],["str"]]]],[11,"print_move","","Prints a move instruction.",16,[[["self"],["type"],["str"],["str"]]]],[11,"cfg_vec","","",16,N],[11,"cfg","","Prints a cfg.",16,[[["self"],["function"],["cfg"],["namemap"]]]],[11,"parallel_induction_level","","Prints a multiplicative induction var level.",16,[[["self"],["inductionlevel"],["namemap"]]]],[11,"enable_threads","","Change the side-effect guards so that only the specified threads are enabled.",16,N],[11,"gen_loop","","Prints a Loop",16,N],[11,"standard_loop","","Prints a classic loop - that is, a sequential loop with an index and a jump to the beginning at the end of the block",16,N],[11,"unroll_loop","","Prints an unroll loop - loop without jumps",16,N],[11,"privatise_global_block","","",16,[[["self"],["internalmemoryregion"],["namemap"],["function"]]]],[11,"inst","","Prints an instruction.",16,N],[11,"lower_type","","",16,[[["type"],["function"]],["type"]]],[11,"mul_mode","","",16,[[["type"],["type"]],["mulmode"]]],[11,"get","telamon::ir","",73,[[["self"],["builder"]],["operand"]]],[11,"get","","",63,[[["self"],["builder"]],["operand"]]],[11,"get","","",64,[[["self"],["builder"]],["operand"]]],[11,"get","telamon::ir::mem","",91,[[["self"],["builder"]],["operand"]]],[11,"get","telamon::ir","",62,[[["self"],["builder"]],["operand"]]],[11,"as_size","telamon::device","Returns the argument interpreted as an iteration dimension size, if applicable.",41,[[["self"]],["option",["u32"]]]],[11,"eval_size","","Evaluate a size.",44,[[["self"],["size"]],["u32"]]],[11,"clone","telamon::ir::op","",97,[[["self"]],["rounding"]]],[11,"eq","","",97,[[["self"],["rounding"]],["bool"]]],[11,"fmt","","",97,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",97,[[["self"],["formatter"]],["result"]]],[11,"as_inst","telamon::ir::prelude","Returns 'self' if it is an instruction.",98,[[["self"]],["option",["instruction"]]]],[11,"as_dim","","Returns 'self' if it is a dimension",98,[[["self"]],["option",["dimension"]]]],[11,"fmt","telamon::model","",116,[[["self"],["formatter"]],["result"]]],[11,"intersects","telamon::search_space","Indicates if the domain has an alternatve in common with `other`.",113,[[["self"],["self"]],["bool"]]],[11,"is","","Indicates if the domain is equal to another domain.",113,[[["self"],["self"]],["trivalent"]]],[11,"into_num_set","","Converts the domain into a numeric set with the given domain. Values that are not in `new_universe` are skipped.",114,N],[11,"as_constrained","","Returns the value of the domain, if it is constrained.",114,N],[11,"lt","","",114,N],[11,"gt","","",114,N],[11,"leq","","",114,N],[11,"geq","","",114,N],[11,"eq","","",114,N],[11,"neq","","",114,N]],"paths":[[3,"InductionLevel"],[3,"InductionVar"],[4,"Cfg"],[4,"ParamVal"],[4,"ParamValKey"],[4,"AllocationScheme"],[4,"Operand"],[4,"MulMode"],[3,"Dimension"],[3,"Function"],[3,"InternalMemoryRegion"],[3,"Variable"],[3,"Instruction"],[3,"NameMap"],[3,"Size"],[8,"Namer"],[8,"Printer"],[3,"Reduce"],[3,"TmpArray"],[3,"Builder"],[3,"LogicalDim"],[3,"SignatureBuilder"],[3,"DimSize"],[3,"TensorBuilder"],[3,"Tensor"],[3,"VirtualTensor"],[8,"AutoOperand"],[8,"MetaStatement"],[3,"TilingPattern"],[4,"EvalMode"],[3,"Gpu"],[3,"InstDesc"],[3,"Array"],[4,"Executor"],[3,"Context"],[3,"Kernel"],[3,"CudaPrinter"],[3,"Cpu"],[3,"Context"],[3,"X86printer"],[8,"ArrayArgument"],[8,"ScalarArgument"],[8,"ArgMap"],[8,"AsyncEvaluator"],[8,"Context"],[8,"Device"],[3,"Candidate"],[4,"TreeEvent"],[4,"LogMessage"],[4,"ActionEx"],[4,"ChoiceGroup"],[3,"ChoiceOrdering"],[3,"Config"],[3,"BanditConfig"],[4,"SearchAlgorithm"],[4,"NewNodeOrder"],[4,"OldNodeOrder"],[3,"DimId"],[3,"DimMappingId"],[3,"LogicalDimId"],[3,"Parameter"],[3,"Signature"],[3,"IndVarId"],[3,"InstId"],[3,"VarId"],[3,"NewObjs"],[3,"LoweredDimMap"],[3,"Counter"],[4,"AccessPattern"],[4,"Stride"],[4,"Error"],[4,"TypeError"],[4,"DimMapScope"],[4,"Operand"],[4,"BinOp"],[4,"Operator"],[4,"UnaryOp"],[4,"StmtId"],[4,"Type"],[4,"VarDef"],[3,"DimMap"],[3,"Dimension"],[3,"LogicalDim"],[3,"DimMapping"],[3,"Function"],[3,"InductionVar"],[3,"Instruction"],[3,"LoweringMap"],[3,"Size"],[3,"PartialSize"],[3,"Variable"],[3,"InternalId"],[4,"MemId"],[8,"Block"],[3,"InternalBlock"],[3,"ExternalBlock"],[3,"BlockMap"],[4,"Rounding"],[8,"Statement"],[3,"Nesting"],[4,"BottleneckLevel"],[3,"HwPressure"],[3,"Range"],[3,"FactorRange"],[4,"Action"],[4,"Choice"],[3,"DomainStore"],[3,"Bool"],[3,"InstFlag"],[3,"ThreadMapping"],[3,"MemSpace"],[3,"DimKind"],[3,"Order"],[8,"Domain"],[8,"NumSet"],[3,"SearchSpace"],[6,"Bound"]]};
searchIndex["telamon_capi"]={"doc":"C API wrappers for calling Telamon through FFI.","items":[[0,"linalg","telamon_capi","Linera algebra kernels.",N,N],[3,"Axpy","telamon_capi::linalg","Computes `z = alpha*x+y`.",N,N],[3,"MatVec","","Computes `y = A.x`.",N,N],[3,"Gesummv","","Computes `y = (alpha*A + beta*B).x`.",N,N],[3,"MatMul","","Computes `C = A.B`.",N,N],[12,"params","","",0,N],[3,"MatMulP","","",N,N],[12,"m","","",1,N],[12,"n","","",1,N],[12,"k","","",1,N],[12,"a_stride","","",1,N],[12,"transpose_a","","",1,N],[12,"transpose_b","","",1,N],[12,"generic","","",1,N],[12,"m_tiling","","",1,N],[12,"n_tiling","","",1,N],[12,"k_tiling","","",1,N],[3,"BatchMM","","Batch transposed matrix-matrix multiplication.",N,N],[3,"BatchMMP","","",N,N],[12,"m","","",2,N],[12,"n","","",2,N],[12,"k","","",2,N],[12,"batch","","",2,N],[12,"transpose_a","","",2,N],[12,"transpose_b","","",2,N],[12,"batch_b","","",2,N],[12,"generic","","",2,N],[8,"Kernel","telamon_capi","A kernel that can be compiled, benchmarked and used for correctness tests.",N,N],[16,"Parameters","","The input parameters of the kernel.",3,N],[16,"ExpectedOutput","","The values to expect as output.",3,N],[10,"name","","The name of the function computed by the kernel.",3,[[],["str"]]],[10,"build_signature","","Builds the signature of the kernel in the builder and returns an object that stores enough information to later build the kernel body and check its result. The `is_generic` flag indicates if th sizes should be instantiated.",3,N],[10,"build_body","","Builder the kernel body in the given builder. This builder should be based on the signature created by `build_signature`.",3,[[["self"],["signature"],["context"]],["vec",["candidate"]]]],[10,"get_expected_output","","Computes the expected output.",3,N],[10,"check_result","","Ensures the generated code performs the correct operation.",3,N],[11,"test_correctness","","Generates, executes and tests the output of candidates for the kernel.",3,N],[11,"test_bound","","Tests the correctness of the bound of kernels and returns the list of tested leafs along with the actual evaluation time.",3,N],[11,"benchmark","","Runs the search and benchmarks the resulting candidate.",3,N],[11,"deadend_ratio","","Computes the probability of encountering a dead-end when descending in the search tree.",3,N],[3,"Context","","Description of the evaluation context. In particular, in contains the mapping between argument names and argument values.",N,N],[3,"Device","","Description of the targeted device.",N,N],[4,"DeviceId","","Supported device types for running kernels.",N,N],[13,"X86","","",4,N],[13,"Cuda","","",4,N],[4,"KernelParameters","","Supported kernels.",N,N],[13,"MatMul","","A matrix-matrix multiplication kernel.",5,N],[5,"env_logger_try_init","","Initializes the logger.",N,[[]]],[5,"kernel_matmul_new","","Instanciate a new kernel for matrix-matrix multiplication. The caller is responsible for deallocating the returned pointer using kernel_free. The tile_m, tile_n and tile_k parameters are read from during the call, but no pointer to the corresponding data is kept afterwards.",N,N],[5,"kernel_free","","Deallocates kernel parameters created through one of the `kernel_*_new` functions. The `params` pointer becomes invalid and must not be used again after calling `kernel_free`.",N,N],[5,"kernel_optimize","","Optimize a kernel on a given device. `config_data` points to a JSON-encoded string of length `config_len` containing the configuration parameters for the explorer.",N,N],[0,"error","","",N,N],[4,"TelamonStatus","telamon_capi::error","Indicates if a telamon function exited correctly.",N,N],[13,"Ok","","",6,N],[13,"Fail","","",6,N],[4,"Error","","",N,N],[13,"IRError","","",7,N],[13,"InvalidArgument","","",7,N],[13,"NullPointer","","",7,N],[13,"UnknownError","","",7,N],[13,"StrUtf8Error","","",7,N],[5,"telamon_strerror","","Prints the error message in a string. Returns `null` if no error was present. The caller is responsible for freeing the string with `free`.",N,N],[17,"ERROR","","",N,N],[11,"fmt","","",7,[[["self"],["formatter"]],["result"]]],[11,"from","","",7,[[["error"]],["error"]]],[11,"from","","",7,[[["typeerror"]],["error"]]],[11,"from","","",7,[[["utf8error"]],["error"]]],[11,"from","","",7,N],[0,"explorer","telamon_capi","",N,N],[5,"telamon_config_new","telamon_capi::explorer","Allocate a new explorer configuration object with suitable defaults.",N,N],[5,"telamon_config_free","","Frees an explorer configuration.",N,N],[5,"telamon_string_copy","","Copy a C string pointer into a Rust String object. Use this to set string-valued configuration options.",N,N],[5,"telamon_explore","","Run the exploration according to the configuration.",N,N],[0,"ir","telamon_capi","C API wrappers to create Telamon Kernels.",N,N],[4,"Rounding","telamon_capi::ir","The rounding mode of an arithmetic operation.",N,N],[13,"Exact","","No rounding occurs.",8,N],[13,"Nearest","","Rounds toward the nearest number.",8,N],[13,"Zero","","Rounds toward zero.",8,N],[13,"Positive","","Rounds toward positive infinite.",8,N],[13,"Negative","","Rounds toward negative infinite.",8,N],[3,"Function","","Opaque type that abstracts away the lifetime parameter of `ir::Function` so that cbindgen generates the bindings.",N,N],[3,"Size","","Opaque type that abstracts away the lifetime parameter of `ir::Size` so cbindgen can generate bindings.",N,N],[3,"PartialSize","","Opaque type that abstracts away the lifetime parameter of `ir::SizeiPartial` so cbindgen can generate bindings.",N,N],[3,"Operand","","Opaque type that abstracts away the lifetime parameter of `ir::Operand` so that cbindgen can generate bindings.",N,N],[3,"Operator","","Opaque type that abstracts away the lifetime parameter of `ir::Operator` so that cbindgen can generate bindings.",N,N],[5,"telamon_ir_signature_new","","Creates a function signature that must be deallocated with `telamon_ir_signature_free`.",N,N],[5,"telamon_ir_signature_free","","Deallocates a signature created with `telamon_ir_signature_new`.",N,N],[5,"telamon_ir_signature_param","","Returns the parameter at the given position.",N,N],[5,"telamon_ir_signature_add_scalar","","Adds a scalar parameter to the function signature.",N,N],[5,"telamon_ir_signature_add_array","","Adds an array parameter to the function signature.",N,N],[5,"telamon_ir_type_new_int","","Creates an integer type that must be freed with `telamon_ir_type_free`.",N,N],[5,"telamon_ir_type_new_float","","Creates a floating point type that must be freed with `telamon_ir_type_free`.",N,N],[5,"telamon_ir_type_free","","Frees a type allocated with `telamon_ir_type_new_int` or `telamon_ir_type_new_float`.",N,N],[5,"telamon_ir_function_new","","Creates a function to optimize. The function must be freed with `telamon_ir_function_free`. `signature` and `device` must outlive the function.",N,N],[5,"telamon_ir_function_free","","Frees a function allocated with `telamon_ir_function_new`.",N,N],[5,"telamon_ir_function_add_instruction","","Adds an instruction performing the given operator in the given dimensions to the function. Writes the unique identifier of the instruction in `inst_id`. Returns `Ok` except if an error occurs. Takes ownership of the operator but does not keeps any reference to `dimensions`.",N,N],[5,"telamon_ir_function_add_dimensions","","Adds a logical dimension of the given size to the function. In practice, this creates a dimension for each tiling level plus one. Takes ownership of `size` and writes the unique identifier of the logical dimension in `logical_id`. Writes the ids of the dimensions, from the outermost to the innermost, in `dim_ids`. `dim_ids` must be at least of size `num_tiles + 1`. Returns `Ok` except if an error occurs.",N,N],[5,"telamon_ir_size_new","","Create a size equal to: `const_factor * param_factors[0] * .. * param_factors[num_params-1]` The size must be freed calling `telamon_ir_size_free` or passed to a function that takes its ownership.",N,N],[5,"telamon_ir_size_free","","Frees a size allocated with `telamon_ir_size_new`.",N,N],[5,"telamon_ir_size_into_partial","","Converts an `ir::Size` into an `ir::PartialSize`.",N,N],[5,"telamon_ir_dimension_size","","Returns the size of a dimension.",N,N],[5,"telamon_ir_size_mul","","Multiplies `lhs` by `rhs`.",N,N],[5,"telamon_ir_operand_new_int","","Create a constant integer operand. The provided type must be an integer type. Returns `null` if an error is encountered.",N,N],[5,"telamon_ir_operand_new_float","","Creates a constant floating point operand. The provided type must be a float type. Returns `null` if an error is encountered.",N,N],[5,"telamon_ir_operand_new_parameter","","Creates an operand that fetches the value of a parameter. The created operand holds a reference to `parameter`.",N,N],[5,"telamon_ir_operand_new_index","","Creates an operand that returns the current index on a dimension.",N,N],[5,"telamon_ir_operand_new_inst","","Creates an operand that references the value of an instruction. The value of the instruction is transmitted point-to-point between the source dimensions (`src_dims`, in which the instruction is produced) and destination dimensions (`dst_dims`, in which the operand is used). `num_mapped_dims` indicates the number of dimensions in `src_dims` and in `dst_dims`. If `allow_tmp_mem` is non-zero, Telamon can allocate memory to transfer data between the two loop nests. Otherwise, it makes sure the data can be stored in registers (for example by fusing or unrolling loops).",N,N],[5,"telamon_ir_operand_new_reduction","","Creates an operand that take the value of `init_inst` the first time is is encountered and then reuse the value produced by the instruction using the operand, effectivelly creating a reduction. The value is is transmitted point-to-point between the source dimensions (`src_dims`, in which `init_inst` is produced) and destination dimensions (`dst_dims`, in which the operand is used). `num_mapped_dims` indicates the number of dimensions in `src_dims` and in `dst_dims`. `reduction_dims` indicates on which dimensions the reduction occurs: values are not reused accross other dimensions.",N,N],[5,"telamon_ir_operator_new_mov","","Creates a `mov` operator. Takes ownership of `operand`.",N,N],[5,"telamon_ir_operator_new_binop","","Creates a binary operator. Takes ownership of the operands.",N,N],[5,"telamon_ir_operator_new_mul","","Creates a `mul` operator. The return type can either be the operands type or, if the multplication operates on integers, a type twice the size of the input. Takes ownership of both `lhs` and `rhs`. No references to `return_type` is hold after the function returns.",N,N],[5,"telamon_ir_operator_new_mad","","Creates a `mad` operator, that computes `mul_lhs * mul_rhs + add_rhs`. If the operator operates on integer, the type of `add_rhs` can either be the type of both `mul_lhs` and `mul_rhs` or an integer type having twice the size of the multiplied types. Takes ownership of `mul_lhs`, `mul_rhs` and `add_rhs`.",N,N],[5,"telamon_ir_operator_new_cast","","Creates a `cast` operator. Takes ownership of `operand`. No reference to `return_type` is hold after the function returns.",N,N],[5,"telamon_ir_operator_new_tensor_load","","Creates an operator that loads a tensor stored in memory. Takes the ownership of `base_address` and creates copies of `strided_dims`, `strides` and `loaded_type`. This function also adds the necessary address computation code to `function`.",N,N],[5,"telamon_ir_operator_new_tensor_store","","Creates an operator that stores a tensor in memory. Takes the ownership of `base_address` and `value` and creates copies of `strided_dims`, `strides` and `loaded_type`. This function also adds the necessary address computation code to `function`.",N,N],[11,"clone","","",9,[[["self"]],["function"]]],[11,"into","","",9,[[["self"]],["function"]]],[0,"search_space","telamon_capi","C API wrappers to work with a Telamon search space.",N,N],[3,"SearchSpace","telamon_capi::search_space","Opaque type that abstracts away the lifetime parameter of `search_space::SearchSpace`.",N,N],[5,"telamon_search_space_new","","Creates a new search space from an IR function. The caller stays is responsible for freeing the instance and action pointers; the created search space does not keep references to them.",N,N],[5,"telamon_search_space_apply","","Apply a sequence of actions to a search space.",N,N],[5,"telamon_search_space_free","","Frees a search space instance allocated through `telamon_search_space_new`.",N,N],[11,"clone","","",10,[[["self"]],["searchspace"]]],[11,"clone","telamon_capi","",5,[[["self"]],["kernelparameters"]]],[14,"unwrap_or_exit","","Helper macro that unwraps a result. Exits with `$error` and sets the global `ERROR` variable when an error is encountered.",N,N],[14,"exit","","",N,N],[14,"exit_if_null","","",N,N],[11,"clone","telamon_capi::ir","",8,[[["self"]],["rounding"]]],[11,"fmt","","",8,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",8,[[["self"],["formatter"]],["result",["error"]]]],[11,"eq","","",8,[[["self"],["rounding"]],["bool"]]],[11,"clone","telamon_capi::linalg","",1,[[["self"]],["matmulp"]]],[11,"clone","","",2,[[["self"]],["batchmmp"]]],[11,"name","","",11,[[],["str"]]],[11,"build_signature","","",11,N],[11,"build_body","","",11,[[["self"],["signature"],["context"]],["vec",["candidate"]]]],[11,"get_expected_output","","",11,[[["self"],["context"]],["arraybase",["ownedrepr","dim"]]]],[11,"check_result","","",11,N],[11,"name","","",12,[[],["str"]]],[11,"build_signature","","",12,N],[11,"build_body","","",12,[[["self"],["signature"],["context"]],["vec",["candidate"]]]],[11,"get_expected_output","","",12,[[["self"],["context"]],["arraybase",["ownedrepr","dim"]]]],[11,"check_result","","",12,N],[11,"name","","",13,[[],["str"]]],[11,"build_signature","","",13,[[["batchmmp"],["builder"]],["batchmm"]]],[11,"build_body","","",13,[[["self"],["signature"],["context"]],["vec",["candidate"]]]],[11,"get_expected_output","","",13,[[["self"],["context"]],["arraybase",["ownedrepr","dim"]]]],[11,"check_result","","",13,N],[11,"name","","",0,[[],["str"]]],[11,"build_signature","","",0,[[["matmulp"],["builder"]],["matmul"]]],[11,"build_body","","",0,[[["self"],["signature"],["context"]],["vec",["candidate"]]]],[11,"get_expected_output","","",0,[[["self"],["context"]],["arraybase",["ownedrepr","dim"]]]],[11,"check_result","","",0,N],[11,"name","","",14,[[],["str"]]],[11,"build_signature","","",14,N],[11,"build_body","","",14,[[["self"],["signature"],["context"]],["vec",["candidate"]]]],[11,"get_expected_output","","",14,[[["self"],["context"]],["arraybase",["ownedrepr","dim"]]]],[11,"check_result","","",14,N],[11,"new","","",1,[[["i32"],["i32"],["i32"]],["matmulp"]]],[11,"transpose_a","","",1,[[["self"]],["matmulp"]]],[11,"transpose_b","","",1,[[["self"]],["matmulp"]]],[11,"stride_a","","",1,[[["self"],["u32"]],["matmulp"]]],[11,"static_sizes","","Inline the sizes in the generated code.",1,[[["self"]],["matmulp"]]],[11,"new","","",2,[[["i32"],["i32"],["i32"],["i32"]],["batchmmp"]]],[11,"transpose_a","","",2,[[["self"]],["batchmmp"]]],[11,"transpose_b","","",2,[[["self"]],["batchmmp"]]],[11,"static_sizes","","Generate code that is onyl valid for the given sizes. The batch size is still generic.",2,[[["self"]],["batchmmp"]]],[11,"reuse_b","","Reuse the `B` matrix across the batch.",2,[[["self"]],["batchmmp"]]]],"paths":[[3,"MatMul"],[3,"MatMulP"],[3,"BatchMMP"],[8,"Kernel"],[4,"DeviceId"],[4,"KernelParameters"],[4,"TelamonStatus"],[4,"Error"],[4,"Rounding"],[3,"Function"],[3,"SearchSpace"],[3,"Gesummv"],[3,"MatVec"],[3,"BatchMM"],[3,"Axpy"]]};
searchIndex["telamon_gen"]={"doc":"","items":[[5,"process_file","telamon_gen","Process a file and stores the result in an other file.",N,[[["path"],["path"],["bool"]],["result",["error"]]]],[5,"process","","Parses a constraint description file.",N,[[["option",["read"]],["t"],["bool"],["path"]],["result",["error"]]]],[0,"ast","","Syntaxic tree for the constraint description.",N,N],[3,"TypedConstraint","telamon_gen::ast","A constraints on IR choices.",N,N],[12,"vars","","",0,N],[12,"inputs","","",0,N],[12,"conditions","","",0,N],[12,"restrict_fragile","","Indicates if the constraint should restricct fragile values.",0,N],[3,"Position","","",N,N],[12,"position","","",1,N],[12,"filename","","",1,N],[3,"Spanned","","",N,N],[12,"beg","","",2,N],[12,"end","","",2,N],[12,"data","","Spanned data",2,N],[3,"CounterDef","","",N,N],[12,"name","","",3,N],[12,"doc","","",3,N],[12,"visibility","","",3,N],[12,"vars","","",3,N],[12,"body","","",3,N],[3,"EnumDef","","A toplevel definition or constraint.",N,N],[12,"name","","",4,N],[12,"doc","","",4,N],[12,"variables","","",4,N],[12,"statements","","",4,N],[3,"IntegerDef","","A toplevel integer",N,N],[12,"name","","",5,N],[12,"doc","","",5,N],[12,"variables","","",5,N],[12,"code","","",5,N],[3,"Constraint","","A constraint that must be enforced by the IR.",N,N],[12,"forall_vars","","Variables for which the conditions must be respected.",6,N],[12,"disjunctions","","Conjunction of disjuction of condition that must be respected.",6,N],[12,"restrict_fragile","","Indicates if the constraint should restrict fragile values.",6,N],[3,"CheckerContext","","CheckContext is a type system.",N,N],[3,"SetDef","","",N,N],[12,"name","","",7,N],[12,"doc","","",7,N],[12,"arg","","",7,N],[12,"superset","","",7,N],[12,"disjoint","","",7,N],[12,"keys","","",7,N],[12,"quotient","","",7,N],[3,"TriggerDef","","",N,N],[12,"foralls","","",8,N],[12,"conditions","","",8,N],[12,"code","","",8,N],[3,"Ast","","",N,N],[12,"statements","","",9,N],[12,"ir_desc","","",9,N],[12,"set_defs","","",9,N],[12,"choice_defs","","",9,N],[12,"triggers","","",9,N],[12,"constraints","","",9,N],[12,"checks","","",9,N],[3,"Quotient","","",N,N],[12,"item","","",10,N],[12,"representant","","",10,N],[12,"conditions","","",10,N],[12,"equiv_relation","","",10,N],[3,"CounterBody","","",N,N],[12,"base","","",11,N],[12,"kind","","",11,N],[12,"iter_vars","","",11,N],[12,"value","","",11,N],[12,"conditions","","",11,N],[3,"SetRef","","References a set.",N,N],[12,"name","","",12,N],[12,"var","","",12,N],[3,"VarDef","","Defines a variable.",N,N],[12,"name","","",13,N],[12,"set","","",13,N],[3,"VarMap","","Maps variables to their set and position.",N,N],[3,"ChoiceInstance","","A reference to a choice instantiated with the given variables.",N,N],[12,"name","","",14,N],[12,"vars","","",14,N],[4,"ChoiceDef","","",N,N],[13,"CounterDef","","",15,N],[13,"EnumDef","","",15,N],[13,"IntegerDef","","",15,N],[4,"Hint","","Hint is a token representation.",N,N],[13,"Set","","Set interface.",16,N],[13,"SetAttribute","","Set attribute.",16,N],[13,"Enum","","Enum interface.",16,N],[13,"EnumAttribute","","Enum attribute.",16,N],[13,"Integer","","Integer interface.",16,N],[13,"IntegerAttribute","","Integer attribute.",16,N],[13,"Counter","","Counter.",16,N],[4,"TypeError","","TypeEror is the error representation of telamon's.",N,N],[13,"Redefinition","","Redefinition of a name and hint.",17,N],[12,"object_kind","telamon_gen::ast::TypeError","",17,N],[12,"object_name","","",17,N],[13,"Undefined","telamon_gen::ast","Undefinition of set, enum or field.",17,N],[12,"object_name","telamon_gen::ast::TypeError","",17,N],[13,"BadSymmetricArg","telamon_gen::ast","Unvalid arguments of a symmetric enum.",17,N],[12,"object_name","telamon_gen::ast::TypeError","",17,N],[12,"object_variables","","",17,N],[13,"MissingEntry","telamon_gen::ast","Missing Happens when the Set's object has a missing field.",17,N],[12,"object_name","telamon_gen::ast::TypeError","",17,N],[12,"object_field","","",17,N],[13,"Conflict","telamon_gen::ast","Conflict between incompatible keywords. Happens when the object has symmetric and antisimmetric fields.",17,N],[12,"object_fields","telamon_gen::ast::TypeError","",17,N],[4,"Statement","telamon_gen::ast","A toplevel definition or constraint.",N,N],[13,"ChoiceDef","","",18,N],[13,"TriggerDef","","",18,N],[13,"SetDef","","",18,N],[13,"Require","","",18,N],[4,"Check","","Checks to perform once the statements have been declared.",N,N],[13,"IsSymmetric","","Ensures the inverse of the value set is itself.",19,N],[12,"choice","telamon_gen::ast::Check","",19,N],[12,"values","","",19,N],[4,"Symmetry","telamon_gen::ast","Indicates if an enum exhibits symmetry.",N,N],[13,"Symmetric","","",20,N],[13,"AntiSymmetric","","",20,N],[4,"Condition","","One of the condition that has to be respected by a constraint.",N,N],[13,"Is","","",21,N],[12,"lhs","telamon_gen::ast::Condition","",21,N],[12,"rhs","","",21,N],[12,"is","","",21,N],[13,"Code","telamon_gen::ast","",21,N],[13,"Bool","","",21,N],[13,"CmpCode","","",21,N],[12,"lhs","telamon_gen::ast::Condition","",21,N],[12,"rhs","","",21,N],[12,"op","","",21,N],[13,"CmpInput","telamon_gen::ast","",21,N],[12,"lhs","telamon_gen::ast::Condition","",21,N],[12,"rhs","","",21,N],[12,"op","","",21,N],[4,"CounterVal","telamon_gen::ast","The value of a counter increment.",N,N],[13,"Code","","",22,N],[13,"Choice","","",22,N],[4,"EnumStatement","","A statement in an enum definition.",N,N],[13,"Value","","Defines a possible decision for th enum.",23,N],[13,"Alias","","Defines a set of possible decisions for the enum.",23,N],[13,"Symmetric","","Specifies that the enum is symmetric.",23,N],[13,"AntiSymmetric","","Specifies that the enum is antisymmetric and given the inverse function.",23,N],[5,"dedup_inputs","","Normalizes a list of inputs.",N,N],[11,"clone","","",3,[[["self"]],["counterdef"]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"register_counter","","Registers a counter in the ir description.",3,[[["self"],["irdesc"],["vec"]]]],[11,"define","","",3,[[["self"],["checkercontext"],["vec"]],["result",["typeerror"]]]],[11,"eq","","",3,[[["self"],["self"]],["bool"]]],[11,"clone","","",4,[[["self"]],["enumdef"]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result"]]],[11,"declare","","Type checks the declare's condition.",4,[[["self"],["checkercontext"]],["result",["typeerror"]]]],[11,"define","","Type checks the define's condition.",4,[[["self"],["checkercontext"],["irdesc"],["vec"]],["result",["typeerror"]]]],[11,"eq","","",4,[[["self"],["self"]],["bool"]]],[11,"clone","","",5,[[["self"]],["integerdef"]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"declare","","Type checks the declare's condition.",5,[[["self"],["checkercontext"]],["result",["typeerror"]]]],[11,"define","","Type checks the define's condition.",5,[[["self"],["checkercontext"],["irdesc"]],["result",["typeerror"]]]],[11,"eq","","",5,[[["self"],["self"]],["bool"]]],[11,"fmt","","",15,[[["self"],["formatter"]],["result"]]],[11,"eq","","",15,[[["self"],["choicedef"]],["bool"]]],[11,"ne","","",15,[[["self"],["choicedef"]],["bool"]]],[11,"clone","","",15,[[["self"]],["choicedef"]]],[11,"declare","","",15,[[["self"],["checkercontext"]],["result",["typeerror"]]]],[11,"define","","",15,[[["self"],["checkercontext"],["irdesc"],["vec"],["vec"]],["result",["typeerror"]]]],[11,"from","","",15,[[["statement"]],["self"]]],[11,"fmt","","",6,[[["self"],["formatter"]],["result"]]],[11,"clone","","",6,[[["self"]],["constraint"]]],[11,"new","","Creates a new constraint.",6,[[["vec",["vardef"]],["vec",["vec"]]],["self"]]],[11,"type_check","","Type check the constraint.",6,[[["self"],["irdesc"]],["vec",["typedconstraint"]]]],[11,"define","","Type checks the define's condition.",6,[[["self"],["checkercontext"],["vec"]],["result",["typeerror"]]]],[11,"fmt","","",24,[[["self"],["formatter"]],["result"]]],[11,"default","","",24,[[],["checkercontext"]]],[11,"declare_set","","Declares a set and ensures it is not defined twice.",24,[[["self"],["spanned",["string"]]],["result",["typeerror"]]]],[11,"declare_choice","","Declares a choice and ensures it is not defined twice.",24,[[["self"],["spanned",["string"]],["hint"]],["result",["typeerror"]]]],[11,"check_set_define","","Check if the referenced set is defined.",24,[[["self"],["setref"]],["bool"]]],[11,"fmt","","",16,[[["self"],["formatter"]],["result"]]],[11,"clone","","",16,[[["self"]],["hint"]]],[11,"eq","","",16,[[["self"],["hint"]],["bool"]]],[11,"from","","",16,[[["statement"]],["self"]]],[11,"from_choice","","",16,[[["choicedef"]],["self"]]],[11,"fmt","","",17,[[["self"],["formatter"]],["result"]]],[11,"eq","","",17,[[["self"],["typeerror"]],["bool"]]],[11,"ne","","",17,[[["self"],["typeerror"]],["bool"]]],[11,"fmt","","",7,[[["self"],["formatter"]],["result"]]],[11,"clone","","",7,[[["self"]],["setdef"]]],[11,"declare","","Type checks the declare's condition.",7,[[["self"],["checkercontext"]],["result",["typeerror"]]]],[11,"define","","Type checks the define's condition.",7,[[["self"],["checkercontext"],["vec"],["irdesc"],["vec"],["vec"],["vec"],["vec"]],["result",["typeerror"]]]],[11,"eq","","",7,[[["self"],["self"]],["bool"]]],[11,"clone","","",8,[[["self"]],["triggerdef"]]],[11,"fmt","","",8,[[["self"],["formatter"]],["result"]]],[11,"register_trigger","","Typecheck and registers a trigger.",8,[[["self"],["irdesc"]]]],[11,"define","","Type checks the define's condition.",8,[[["self"],["checkercontext"],["vec"]],["result",["typeerror"]]]],[11,"default","","",9,[[],["ast"]]],[11,"clone","","",9,[[["self"]],["ast"]]],[11,"fmt","","",9,[[["self"],["formatter"]],["result"]]],[11,"type_check","","Generate the defintion of choices and the list of constraints.",9,[[["self"]],["result",["typeerror"]]]],[11,"finalize","","Type-checks the statements in the correct order.",9,N],[11,"fmt","","",18,[[["self"],["formatter"]],["result"]]],[11,"clone","","",18,[[["self"]],["statement"]]],[11,"declare","","",18,[[["self"],["checkercontext"]],["result",["typeerror"]]]],[11,"define","","",18,[[["self"],["checkercontext"],["vec"],["irdesc"],["vec"],["vec"],["vec"],["vec"]],["result",["typeerror"]]]],[11,"clone","","",10,[[["self"]],["quotient"]]],[11,"fmt","","",10,[[["self"],["formatter"]],["result"]]],[11,"clone","","",19,[[["self"]],["check"]]],[11,"fmt","","",19,[[["self"],["formatter"]],["result"]]],[11,"clone","","",11,[[["self"]],["counterbody"]]],[11,"fmt","","",11,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",20,[[["self"],["formatter"]],["result"]]],[11,"clone","","",12,[[["self"]],["setref"]]],[11,"fmt","","",12,[[["self"],["formatter"]],["result"]]],[11,"eq","","",12,[[["self"],["self"]],["bool"]]],[11,"fmt","","",13,[[["self"],["formatter"]],["result"]]],[11,"clone","","",13,[[["self"]],["vardef"]]],[11,"eq","","",13,[[["self"],["self"]],["bool"]]],[11,"default","","",25,[[],["varmap"]]],[11,"fmt","","",21,[[["self"],["formatter"]],["result"]]],[11,"clone","","",21,[[["self"]],["condition"]]],[11,"fmt","","",14,[[["self"],["formatter"]],["result"]]],[11,"clone","","",14,[[["self"]],["choiceinstance"]]],[11,"clone","","",22,[[["self"]],["counterval"]]],[11,"fmt","","",22,[[["self"],["formatter"]],["result"]]],[11,"clone","","",23,[[["self"]],["enumstatement"]]],[11,"fmt","","",23,[[["self"],["formatter"]],["result"]]],[11,"is_symmetric","","",23,[[["self"]],["bool"]]],[11,"is_antisymmetric","","",23,[[["self"]],["bool"]]],[11,"fmt","","",23,[[["self"],["formatter"]],["result"]]],[11,"eq","","",23,[[["self"],["self"]],["bool"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"dedup_inputs","","Remove duplicates among inputs.",0,[[["self"],["irdesc"]]]],[11,"gen_filters","","Generate filters to enforce the constraint.",0,[[["self"],["irdesc"]],["vec"]]],[0,"ir","telamon_gen","The constraint description for the ir.",N,N],[3,"Adaptator","telamon_gen::ir","Represent a transformation to apply to a rule to fir it in a new context.",N,N],[3,"Choice","","A decision to specify.",N,N],[3,"FilterCall","","A call to a filter.",N,N],[12,"forall_vars","","",26,N],[12,"filter_ref","","",26,N],[3,"OnChangeAction","","An action to perform when the choice is restricted.",N,N],[12,"forall_vars","","",27,N],[12,"set_constraints","","",27,N],[12,"action","","",27,N],[3,"ChoiceCondition","","A condition from the point of view of a choice.",N,N],[12,"inputs","","",28,N],[12,"self_condition","","",28,N],[12,"others_conditions","","",28,N],[3,"FilterAction","","Restricts the set of valid values.",N,N],[12,"set_constraints","","",29,N],[12,"filter","","",29,N],[3,"Filter","","Filters the set valid values.",N,N],[12,"arguments","","The variables on which the filter depends.",30,N],[12,"inputs","","The choices that the filter depends on.",30,N],[12,"rules","","The filter rules.",30,N],[3,"Rule","","Specifies a conditional restriction on the set of valid values.",N,N],[12,"conditions","","The conditions that must be true for the rule to trigger.",31,N],[12,"alternatives","","The values allowed for the enum if the rule is triggered.",31,N],[12,"set_constraints","","The condition on subsets for the rule to apply.",31,N],[3,"SetConstraints","","A list of constraints on the set each variable belongs to. It must be built using `SetConstraints::new` so the constraints are in the right order.",N,N],[3,"ChoiceInstance","","An choice instantiated with the given variables.",N,N],[12,"choice","","",32,N],[12,"vars","","",32,N],[3,"Code","","A piece of rust code.",N,N],[12,"code","","",33,N],[12,"vars","","",33,N],[3,"Set","","References a set of objects.",N,N],[3,"SetRefImpl","","",N,N],[3,"SetDef","","Defines a set of objects.",N,N],[3,"IrDesc","","Describes the choices that constitute the IR.",N,N],[3,"Enum","","A choice that can take a few predefined values.",N,N],[3,"Trigger","","A piece of host code called when a list of conditions are met.",N,N],[12,"foralls","","",34,N],[12,"inputs","","",34,N],[12,"conditions","","",34,N],[12,"code","","",34,N],[4,"ChoiceArguments","","Defines the parameters for which the `Choice` is defined.",N,N],[13,"Plain","","The `Choice` is defined for all comibnation of variables of the given sets Each variable can only appear once.",35,N],[12,"vars","telamon_gen::ir::ChoiceArguments","",35,N],[13,"Symmetric","telamon_gen::ir","The `Choice` is defined on a triangular space. The rests is obtained by symmetry.",35,N],[12,"names","telamon_gen::ir::ChoiceArguments","",35,N],[12,"t","","",35,N],[12,"inverse","","",35,N],[4,"ChoiceDef","telamon_gen::ir","Specifies how the `Choice` is defined.",N,N],[13,"Enum","","The `Choice` can take a small set of predefined values.",36,N],[13,"Counter","","An integer abstracted by an interval.",36,N],[12,"kind","telamon_gen::ir::ChoiceDef","",36,N],[12,"value","","",36,N],[12,"incr_iter","","",36,N],[12,"incr","","",36,N],[12,"incr_condition","","",36,N],[12,"visibility","","",36,N],[12,"base","","",36,N],[13,"Number","telamon_gen::ir","The `Choice` can take a small set of dynamically defined numeric values.",36,N],[12,"universe","telamon_gen::ir::ChoiceDef","",36,N],[4,"CounterVisibility","telamon_gen::ir","Indicates how a counter exposes how its maximum value. The variants are ordered by increasing amount of information available.",N,N],[13,"NoMax","","Only the minimal value is computed and stored.",37,N],[13,"HiddenMax","","Both the min and max are stored, but only the min is exposed.",37,N],[13,"Full","","Both the min and the max value are exposed.",37,N],[4,"CounterVal","","The value of the increments of a counter.",N,N],[13,"Code","","",38,N],[13,"Choice","","",38,N],[4,"ValueType","","Specifies the type of the values a choice can take.",N,N],[13,"Enum","","Generated type that represents the values of an enum choice.",39,N],[13,"Range","","Represents a contiguous range of values.",39,N],[12,"is_half","telamon_gen::ir::ValueType","",39,N],[13,"NumericSet","telamon_gen::ir","Represents a small set of integers.",39,N],[13,"Constant","","Represents an external constant, provided by the user. Its exact type is unspecified.",39,N],[4,"FilterRef","","References a filter to call.",N,N],[13,"Inline","","",40,N],[13,"Local","","",40,N],[12,"id","telamon_gen::ir::FilterRef","",40,N],[12,"args","","",40,N],[13,"Remote","telamon_gen::ir","",40,N],[12,"choice","telamon_gen::ir::FilterRef","",40,N],[12,"id","","",40,N],[12,"args","","",40,N],[4,"ChoiceAction","telamon_gen::ir","An action to perform,",N,N],[13,"FilterSelf","","The choice runs all its filters on itself.",41,N],[13,"Filter","","The choice runs a filter on another choice.",41,N],[12,"choice","telamon_gen::ir::ChoiceAction","",41,N],[12,"filter","","",41,N],[13,"IncrCounter","telamon_gen::ir","Increments a counter if the increment condition is statisfied.",41,N],[12,"counter","telamon_gen::ir::ChoiceAction","",41,N],[12,"value","","",41,N],[12,"incr_condition","","",41,N],[13,"UpdateCounter","telamon_gen::ir","Update a counter after the increment value is changed.",41,N],[12,"counter","telamon_gen::ir::ChoiceAction","",41,N],[12,"incr","","",41,N],[12,"incr_condition","","",41,N],[13,"Trigger","telamon_gen::ir","Triggers a lowering.",41,N],[12,"id","telamon_gen::ir::ChoiceAction","",41,N],[12,"condition","","",41,N],[12,"code","","",41,N],[12,"inverse_self_cond","","",41,N],[4,"SubFilter","telamon_gen::ir","Filters the set of valid values, given some inputs.",N,N],[13,"Switch","","Enumerate the possible values that a input can take, and lists the possible values for each.",42,N],[12,"switch","telamon_gen::ir::SubFilter","",42,N],[12,"cases","","",42,N],[13,"Rules","telamon_gen::ir","Applies a set of negative rules to filter the possible values.",42,N],[4,"Variable","","",N,N],[13,"Arg","","",43,N],[13,"Forall","","",43,N],[4,"Condition","","A condition producing a boolean.",N,N],[13,"Code","","Triggers if the given piece of code returns `true`, given the mapping of variables.",44,N],[12,"code","telamon_gen::ir::Condition","",44,N],[12,"negate","","",44,N],[13,"Enum","telamon_gen::ir","Triggers if the choice can only take the given values.",44,N],[12,"input","telamon_gen::ir::Condition","",44,N],[12,"values","","",44,N],[12,"negate","","",44,N],[12,"inverse","","",44,N],[13,"Bool","telamon_gen::ir","Always or never triggers.",44,N],[13,"CmpCode","","Triggers if the one inputs respects the comparison operator with some rust code.",44,N],[12,"lhs","telamon_gen::ir::Condition","",44,N],[12,"rhs","","",44,N],[12,"op","","",44,N],[13,"CmpInput","telamon_gen::ir","Triggers if the two inputs respects the comparison operator.",44,N],[12,"lhs","telamon_gen::ir::Condition","",44,N],[12,"rhs","","",44,N],[12,"op","","",44,N],[12,"inverse","","",44,N],[4,"CmpOp","telamon_gen::ir","A compariason operator.",N,N],[13,"Lt","","",45,N],[13,"Gt","","",45,N],[13,"Leq","","",45,N],[13,"Geq","","",45,N],[13,"Eq","","",45,N],[13,"Neq","","",45,N],[4,"ValueSet","","Represents a set of values a choice can take.",N,N],[13,"Enum","","",46,N],[12,"enum_name","telamon_gen::ir::ValueSet","The enum type.",46,N],[12,"values","","A fixed set of values. Does not contains aliases.",46,N],[12,"inputs","","A set of inputs whose values can be take by the choice. Two flags indicate if the value should be negated or inversed.",46,N],[13,"Integer","telamon_gen::ir","",46,N],[12,"is_full","telamon_gen::ir::ValueSet","",46,N],[12,"cmp_inputs","","",46,N],[12,"cmp_code","","",46,N],[12,"universe","","",46,N],[4,"SetDefKey","telamon_gen::ir","",N,N],[13,"ItemType","","",47,N],[13,"IdType","","",47,N],[13,"ItemGetter","","",47,N],[13,"IdGetter","","",47,N],[13,"Iter","","",47,N],[13,"FromSuperset","","",47,N],[13,"Prefix","","",47,N],[13,"NewObjs","","",47,N],[13,"Reverse","","",47,N],[13,"AddToSet","","",47,N],[4,"CounterKind","","Indicates whether a counter sums or adds.",N,N],[13,"Add","","",48,N],[13,"Mul","","",48,N],[5,"dummy_choice","","",N,[[],["choice"]]],[5,"normalized_enum_set","","Creates a `ValueSet` from the list of enum values.",N,[[["it"],["bool"],["bool"],["enum"]],["valueset"]]],[11,"default","","",49,[[],["adaptator"]]],[11,"from_arguments","","Creates an adaptator that maps the arguments to the given names.",49,N],[11,"variable","","Adapts a variable.",49,[[["self"],["variable"]],["variable"]]],[11,"input","","Returns the new ID of an input and indicates if it is inversed.",49,N],[11,"set_variable","","Sets the mapping of a variable. Returns the previous mapping.",49,[[["self"],["variable"],["variable"]],["option",["variable"]]]],[11,"set_input","","Sets the mapping of an input.",49,[[["self"],["usize"],["usize"]]]],[11,"set_inversed","","Sets an input as inversed.",49,[[["self"],["usize"]]]],[11,"clone","","",50,[[["self"]],["choice"]]],[11,"fmt","","",50,[[["self"],["formatter"]],["result"]]],[11,"new","","Creates a new `Choice`.",50,[[["rcstr"],["option",["rcstr"]],["choicearguments"],["choicedef"]],["self"]]],[11,"name","","Returns the name of the choice, in snake_case.",50,[[["self"]],["rcstr"]]],[11,"doc","","Returns the documentation associated with the `Choice`.",50,[[["self"]],["option",["str"]]]],[11,"arguments","","Returns the parameters for which the `Choice` is defined.",50,[[["self"]],["choicearguments"]]],[11,"value_type","","Returns the type representing the values the `Choice` can take.",50,[[["self"]],["valuetype"]]],[11,"choice_def","","Returns the definition of the `Choice.",50,[[["self"]],["choicedef"]]],[11,"on_change","","Returns the actions to perform when the `Choice` is constrained.",50,[[["self"]],["iter",["onchangeaction"]]]],[11,"filter_actions","","Returns the actions to run to get the valid alternatives of the choice.",50,[[["self"]],["iter",["filteraction"]]]],[11,"filters","","Returns the filters operating on the `Choice`.",50,[[["self"]],["iter",["filter"]]]],[11,"add_filter_action","","Adds a filter to run on initialization.",50,[[["self"],["filteraction"]]]],[11,"add_onchange","","Adds an action to perform when the `Choice` is constrained.",50,[[["self"],["onchangeaction"]]]],[11,"add_filter","","Adds a filter to the `Choice`, returns an ID to indentify it.",50,[[["self"],["filter"]],["usize"]]],[11,"fragile_values","","Returns the values that should not be automatically restricted by filters.",50,[[["self"]],["valueset"]]],[11,"add_fragile_values","","Extends the list of values that should not be automatically propagated by filters.",50,[[["self"],["valueset"]]]],[11,"fmt","","",35,[[["self"],["formatter"]],["result"]]],[11,"clone","","",35,[[["self"]],["choicearguments"]]],[11,"new","","Creates a new `ChoiceArguments`.",35,[[["vec"],["bool"],["bool"]],["self"]]],[11,"names","","Returns the name of the arguments.",35,[[["self"]],[""]]],[11,"sets","","Returns the sets of the arguments.",35,[[["self"]],[""]]],[11,"get","","Returns the name and set of the argument at the given position.",35,N],[11,"iter","","Iterates over the arguments, with their sets and names.",35,[[["self"]],[""]]],[11,"is_symmetric","","Indicates if the arguments iteration domain is triangular.",35,[[["self"]],["bool"]]],[11,"len","","Returns the number of arguments.",35,[[["self"]],["usize"]]],[11,"clone","","",36,[[["self"]],["choicedef"]]],[11,"fmt","","",36,[[["self"],["formatter"]],["result"]]],[11,"clone","","",37,[[["self"]],["countervisibility"]]],[11,"fmt","","",37,[[["self"],["formatter"]],["result"]]],[11,"eq","","",37,[[["self"],["countervisibility"]],["bool"]]],[11,"partial_cmp","","",37,[[["self"],["countervisibility"]],["option",["ordering"]]]],[11,"cmp","","",37,[[["self"],["countervisibility"]],["ordering"]]],[11,"value_type","","Returns the underlying value type.",36,[[["self"]],["valuetype"]]],[11,"is_counter","","Indicates if the choice is a counter.",36,[[["self"]],["bool"]]],[11,"as_enum","","Returns the name of the `Enum` the `Choice` is based on.",36,[[["self"]],["option",["rcstr"]]]],[11,"is_valid_operator","","Indicates the comparison operators that can be applied to the decision.",36,[[["self"],["cmpop"]],["bool"]]],[11,"clone","","",38,[[["self"]],["counterval"]]],[11,"fmt","","",38,[[["self"],["formatter"]],["result"]]],[11,"adapt","","",38,[[["self"],["adaptator"]],["self"]]],[11,"full_type","","Returns the full type, instead of a the trimmed one.",39,[[["self"]],["self"]]],[11,"as_enum","","Returns the enum name, if applicable.",39,[[["self"]],["option",["rcstr"]]]],[11,"clone","","",39,[[["self"]],["valuetype"]]],[11,"fmt","","",39,[[["self"],["formatter"]],["result"]]],[11,"eq","","",39,[[["self"],["valuetype"]],["bool"]]],[11,"ne","","",39,[[["self"],["valuetype"]],["bool"]]],[11,"adapt","","",39,[[["self"],["adaptator"]],["self"]]],[11,"clone","","",26,[[["self"]],["filtercall"]]],[11,"fmt","","",26,[[["self"],["formatter"]],["result"]]],[11,"adapt","","",26,[[["self"],["adaptator"]],["self"]]],[11,"clone","","",40,[[["self"]],["filterref"]]],[11,"fmt","","",40,[[["self"],["formatter"]],["result"]]],[11,"adapt","","",40,[[["self"],["adaptator"]],["self"]]],[11,"clone","","",27,[[["self"]],["onchangeaction"]]],[11,"fmt","","",27,[[["self"],["formatter"]],["result"]]],[11,"applies_to_symmetric","","Indicates if the action sould also be registered for the symmetric of the choice, if applicable.",27,[[["self"]],["bool"]]],[11,"inverse","","Returns the action for the symmetric of the choice.",27,[[["self"],["irdesc"]],["self"]]],[11,"adapt","","",27,[[["self"],["adaptator"]],["self"]]],[11,"clone","","",41,[[["self"]],["choiceaction"]]],[11,"fmt","","",41,[[["self"],["formatter"]],["result"]]],[11,"variables","","Returns the list of variables to allocate.",41,[[["self"]],["box",["iterator"]]]],[11,"inputs","","Returns the list of inputs used by the action.",41,N],[11,"inverse_self","","Inverse references to the value of the choice the action is registered in.",41,[[["self"],["irdesc"]]]],[11,"adapt","","",41,[[["self"],["adaptator"]],["self"]]],[11,"clone","","",28,[[["self"]],["choicecondition"]]],[11,"fmt","","",28,[[["self"],["formatter"]],["result"]]],[11,"new","","Adapt the list of conditions to be from the point of view of the given choice.",28,N],[11,"adapt","","",28,[[["self"],["adaptator"]],["self"]]],[11,"clone","","",29,[[["self"]],["filteraction"]]],[11,"fmt","","",29,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",30,[[["self"],["formatter"]],["result"]]],[11,"clone","","",30,[[["self"]],["filter"]]],[11,"fmt","","",42,[[["self"],["formatter"]],["result"]]],[11,"clone","","",42,[[["self"]],["subfilter"]]],[11,"fmt","","",31,[[["self"],["formatter"]],["result"]]],[11,"clone","","",31,[[["self"]],["rule"]]],[11,"instantiate","","Instantiates the rule for a given assignment of the inputs.",31,N],[11,"normalize","","Normalizes the `Rule`.",31,N],[11,"adapt","","",31,[[["self"],["adaptator"]],["self"]]],[11,"clone","","",51,[[["self"]],["setconstraints"]]],[11,"fmt","","",51,[[["self"],["formatter"]],["result"]]],[11,"default","","",51,[[],["setconstraints"]]],[11,"eq","","",51,[[["self"],["setconstraints"]],["bool"]]],[11,"ne","","",51,[[["self"],["setconstraints"]],["bool"]]],[11,"hash","","",51,N],[11,"new","","Create a new list of set constraints. The constraints are put in a normalized and legal order.",51,[[["vec"]],["self"]]],[11,"constraints","","Returns the constraints in a legal order.",51,N],[11,"is_empty","","Indicates if the set of constraints is empty.",51,[[["self"]],["bool"]]],[11,"find_set","","Returns the set the given variable is constrained to, if any.",51,[[["self"],["variable"]],["option",["set"]]]],[11,"adapt","","",51,[[["self"],["adaptator"]],["self"]]],[11,"into_iter","","",51,N],[11,"clone","","",43,[[["self"]],["variable"]]],[11,"eq","","",43,[[["self"],["variable"]],["bool"]]],[11,"ne","","",43,[[["self"],["variable"]],["bool"]]],[11,"hash","","",43,N],[11,"partial_cmp","","",43,[[["self"],["variable"]],["option",["ordering"]]]],[11,"lt","","",43,[[["self"],["variable"]],["bool"]]],[11,"le","","",43,[[["self"],["variable"]],["bool"]]],[11,"gt","","",43,[[["self"],["variable"]],["bool"]]],[11,"ge","","",43,[[["self"],["variable"]],["bool"]]],[11,"cmp","","",43,[[["self"],["variable"]],["ordering"]]],[11,"adapt","","",43,[[["self"],["adaptator"]],["self"]]],[11,"fmt","","",43,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",43,[[["self"],["formatter"]],["result"]]],[11,"clone","","",32,[[["self"]],["choiceinstance"]]],[11,"fmt","","",32,[[["self"],["formatter"]],["result"]]],[11,"hash","","",32,N],[11,"eq","","",32,[[["self"],["choiceinstance"]],["bool"]]],[11,"ne","","",32,[[["self"],["choiceinstance"]],["bool"]]],[11,"normalize","","Normalizes the `ChoiceInstance` and indicates if the corresponding input should be inversed.",32,[[["self"],["irdesc"]],["bool"]]],[11,"value_type","","Returns the type of the values the chocie takes.",32,[[["self"],["irdesc"]],["valuetype"]]],[11,"adapt","","",32,[[["self"],["adaptator"]],["self"]]],[11,"clone","","",33,[[["self"]],["code"]]],[11,"fmt","","",33,[[["self"],["formatter"]],["result"]]],[11,"eq","","",33,[[["self"],["code"]],["bool"]]],[11,"ne","","",33,[[["self"],["code"]],["bool"]]],[11,"hash","","",33,N],[11,"partial_cmp","","",33,[[["self"],["code"]],["option",["ordering"]]]],[11,"lt","","",33,[[["self"],["code"]],["bool"]]],[11,"le","","",33,[[["self"],["code"]],["bool"]]],[11,"gt","","",33,[[["self"],["code"]],["bool"]]],[11,"ge","","",33,[[["self"],["code"]],["bool"]]],[11,"cmp","","",33,[[["self"],["code"]],["ordering"]]],[11,"normalize","","Normalizes the `Code.",33,[[["self"]]]],[11,"adapt","","",33,[[["self"],["adaptator"]],["self"]]],[11,"clone","","",44,[[["self"]],["condition"]]],[11,"fmt","","",44,[[["self"],["formatter"]],["result"]]],[11,"eq","","",44,[[["self"],["condition"]],["bool"]]],[11,"ne","","",44,[[["self"],["condition"]],["bool"]]],[11,"hash","","",44,N],[11,"partial_cmp","","",44,[[["self"],["condition"]],["option",["ordering"]]]],[11,"lt","","",44,[[["self"],["condition"]],["bool"]]],[11,"le","","",44,[[["self"],["condition"]],["bool"]]],[11,"gt","","",44,[[["self"],["condition"]],["bool"]]],[11,"ge","","",44,[[["self"],["condition"]],["bool"]]],[11,"cmp","","",44,[[["self"],["condition"]],["ordering"]]],[11,"negate","","Negates the condition.",44,[[["self"]]]],[11,"alternatives_of","","Returns allowed alternatives for the given input. Returns None if the condition is not on the given input.",44,[[["self"],["usize"],["valuetype"],["irdesc"]],["option",["valueset"]]]],[11,"instantiate","","Instantiate the condition in the given context.",44,N],[11,"evaluate","","Evaluates the condition. Requires the mapping to be instantiated.",44,N],[11,"normalize","","Normalizes the condition to make it easier to apply equality on it.",44,N],[11,"adapt","","",44,[[["self"],["adaptator"]],["self"]]],[11,"fmt","","",45,[[["self"],["formatter"]],["result"]]],[11,"clone","","",45,[[["self"]],["cmpop"]]],[11,"eq","","",45,[[["self"],["cmpop"]],["bool"]]],[11,"partial_cmp","","",45,[[["self"],["cmpop"]],["option",["ordering"]]]],[11,"cmp","","",45,[[["self"],["cmpop"]],["ordering"]]],[11,"hash","","",45,N],[11,"negate","","Negates the operator.",45,[[["self"]]]],[11,"inverse","","Returns the equivalent operator for when the operator are inversed.",45,[[["self"]],["self"]]],[11,"allows_eq","","Indicates if the operator returns true when both operands are equals.",45,[[["self"]],["bool"]]],[11,"evaluate","","Evaluates the operator on the given `ValueSet`s.",45,[[["self"],["valueset"],["valueset"]],["trivalent"]]],[11,"clone","","",46,[[["self"]],["valueset"]]],[11,"fmt","","",46,[[["self"],["formatter"]],["result"]]],[11,"eq","","",46,[[["self"],["valueset"]],["bool"]]],[11,"ne","","",46,[[["self"],["valueset"]],["bool"]]],[11,"empty","","Creates an enmpty `ValueSet` of the given type.",46,[[["valuetype"]],["self"]]],[11,"from_properties","","Computes a `ValueSet` from the properties it must respect.",46,[[["valuetype"],["bool"],["bool"],["irdesc"]],["self"]]],[11,"enum_values","","Creates a `ValueSet` from a normalized set of values.",46,[[["rcstr"],["btreeset",["rcstr"]]],["self"]]],[11,"from_input","","Creates a `ValueSet` from the given input.",46,[[["valuetype"],["usize"],["cmpop"],["bool"]],["self"]]],[11,"is_empty","","Indicates if the set of values is empty.",46,[[["self"]],["bool"]]],[11,"is_full","","Indicates if the set contains all the values. This functions is pessimistic: the set may contain all the values and the function still return false.",46,[[["self"],["irdesc"]],["bool"]]],[11,"is_constrained","","Indicates if the set contains a single value.",46,[[["self"]],["trivalent"]]],[11,"extend","","Extends the `ValueSet` with the values of anther set.",46,[[["self"],["valueset"]]]],[11,"intersect","","Intersects the `ValueSet` with the given values. Indicates if the intersection was successful or if the sets should be kept separate.",46,[[["self"],["valueset"]],["bool"]]],[11,"instantiate","","Instantiates the `ValueSet` for a given input assignment.",46,[[["self"],["hashmap"],["irdesc"]],["self"]]],[11,"inverse","","Inverse the `ValueSet`. The choice must be antisymmetric.",46,[[["self"],["irdesc"]]]],[11,"is","","Indicates if the `ValueSet` will be contained into anoter after instantiation. Requires both `self` and `other` to be instantiated.",46,[[["self"],["valueset"]],["trivalent"]]],[11,"t","","Returns the type of the values.",46,[[["self"]],["valuetype"]]],[11,"adapt","","",46,[[["self"],["adaptator"]],["self"]]],[11,"clone","","",52,[[["self"]],["set"]]],[11,"hash","","",52,N],[11,"eq","","",52,[[["self"],["set"]],["bool"]]],[11,"ne","","",52,[[["self"],["set"]],["bool"]]],[11,"fmt","","",52,[[["self"],["formatter"]],["result"]]],[11,"new","","Create a new set instance.",52,[[["rc"],["option",["variable"]]],["self"]]],[11,"is_subset_of_def","","Indicates if the first set is a sub-set of the second, without matching argument names.",52,[[["self"],["set"]],["bool"]]],[11,"get_collision_level","","Returns the common superset where the two set might have an object in common.",52,[[["self"],["set"]],["option",["setdef"]]]],[11,"reverse","","Returns a superset of this set and a set parametrized by elements of the superset that iterates on the possible parameters of this set given a variable of the superset.",52,[[["self"],["variable"],["set"]],["option"]]],[11,"adapt","","",52,[[["self"],["adaptator"]],["self"]]],[11,"clone","","",53,[[["self"]],["setrefimpl"]]],[11,"hash","","",53,N],[11,"eq","","",53,[[["self"],["setrefimpl"]],["bool"]]],[11,"ne","","",53,[[["self"],["setrefimpl"]],["bool"]]],[11,"fmt","","",53,[[["self"],["formatter"]],["result"]]],[11,"def","","",53,[[["self"]],["setdef"]]],[11,"arg","","",53,[[["self"]],["option",["variable"]]]],[11,"reverse_constraint","","",53,[[["self"]],["option",["setrefimpl"]]]],[11,"clone","","",54,[[["self"]],["setdef"]]],[11,"new","","Creates a new set definition.",54,[[["string"],["option",["set"]],["option",["set"]],["option"],["indexmap",["setdefkey","string"]],["vec",["string"]]],["rc"]]],[11,"name","","The name of the set.",54,[[["self"]],["rcstr"]]],[11,"arg","","Returns the argument of the set, if any.",54,[[["self"]],["option",["set"]]]],[11,"superset","","Returns the superset of the set, if any.",54,[[["self"]],["option",["set"]]]],[11,"attributes","","The attributes of the set.",54,[[["self"]],["indexmap"]]],[11,"prefix","","Suggest a prefix for variables in the set.",54,[[["self"]],["str"]]],[11,"def_order","","Returns an integer that indicates an order in which variables can be defined to always be defined before any argument of the set they belong into.",54,[[["self"]],["usize"]]],[11,"is_subset_of_def","","Indicates if the first set is a sub-set of the second.",54,[[["self"],["setdef"]],["bool"]]],[11,"fmt","","",54,[[["self"],["formatter"]],["result"]]],[11,"eq","","",54,[[["self"],["setdef"]],["bool"]]],[11,"hash","","",54,[[["self"],["h"]]]],[11,"partial_cmp","","",54,[[["self"],["setdef"]],["option",["ordering"]]]],[11,"cmp","","",54,[[["self"],["setdef"]],["ordering"]]],[11,"fmt","","",47,[[["self"],["formatter"]],["result"]]],[11,"hash","","",47,N],[11,"eq","","",47,[[["self"],["setdefkey"]],["bool"]]],[11,"clone","","",47,[[["self"]],["setdefkey"]]],[11,"env","","Returns the variables defined for the key.",47,[[["self"]],["vec",["str"]]]],[11,"is_arg_in_env","","Indicates if the environement contains the set argument.",47,[[["self"]],["bool"]]],[18,"REQUIRED","","The list of required keys.",47,N],[11,"fmt","","",47,[[["self"],["formatter"]],["result"]]],[8,"Adaptable","","",N,N],[10,"adapt","","Adapts the object to the new environement.",55,[[["self"],["adaptator"]],["self"]]],[8,"SetRef","","Generic trait for sets.",N,N],[10,"def","","Returns the set definition.",56,[[["self"]],["setdef"]]],[10,"arg","","Returns the argument of the set, if any.",56,[[["self"]],["option",["variable"]]]],[10,"reverse_constraint","","A constraint on the variables to iterate on, issued from a set reversal.",56,[[["self"]],["option",["setrefimpl"]]]],[11,"without_reverse_constraints","","Returns the same set but without reverse constraints.",56,[[["self"]],["setrefimpl"]]],[11,"superset","","Returns the direct superset of this set, if any.",56,[[["self"]],["option",["setrefimpl"]]]],[11,"path_to_superset","","Returns the path of sets to access a super-set.",56,[[["self"],["setref"]],["vec",["setrefimpl"]]]],[11,"is_subset_of","","Indicates if the first set is a sub-set of the second.",56,[[["self"],["set"]],["bool"]]],[11,"as_ref","","Returns the `SetRefImpl` corresponding to this set.",56,[[["self"]],["setrefimpl"]]],[11,"clone","","",57,[[["self"]],["irdesc"]]],[11,"fmt","","",57,[[["self"],["formatter"]],["result"]]],[11,"add_choice","","Adds a `Choice` to the IR description.",57,[[["self"],["choice"]]]],[11,"add_enum","","Adds an `Enum` to the IR desctiption.",57,[[["self"],["enum"]]]],[11,"choices","","List the choice definitions.",57,[[["self"]],[""]]],[11,"enums","","List the enum definitions.",57,[[["self"]],[""]]],[11,"get_enum","","Returns the enum with the given name.",57,[[["self"],["str"]],["enum"]]],[11,"get_choice","","Returns the choice with the given name.",57,[[["self"],["str"]],["choice"]]],[11,"set_defs","","Iterates over all the sets.",57,[[["self"]],[""]]],[11,"add_set_def","","Register a set definition.",57,[[["self"],["rc",["setdef"]]]]],[11,"get_set_def","","Returns the set definition associated with a name.",57,[[["self"],["str"]],["rc"]]],[11,"add_filter","","Adds a filter to a choice.",57,[[["self"],["rcstr"],["filter"],["vec",["set"]],["setconstraints"]]]],[11,"add_onchange","","",57,[[["self"],["str"],["onchangeaction"]]]],[11,"add_trigger","","Adds a trigger to a choice.",57,[[["self"],["trigger"]],["usize"]]],[11,"triggers","","Iterates on the triggers.",57,[[["self"]],[""]]],[11,"adapt_env","","Generates the list of sets to iterate and to constraints to iterate on the given context, but from the point of view of the given choice instance.",57,N],[11,"adapt_env_ext","","Generates the foralls and the set constraints to iterate on the given environment, from the point of view of the given choice. Returns the foralls issued from arguments in a different list than the foralls issued from foralls in the original environment.",57,N],[11,"default","","",57,[[],["self"]]],[11,"clone","","",48,[[["self"]],["counterkind"]]],[11,"fmt","","",48,[[["self"],["formatter"]],["result"]]],[11,"eq","","",48,[[["self"],["counterkind"]],["bool"]]],[11,"zero","","Returns the neutral element of the operand.",48,[[["self"]],["u32"]]],[11,"fmt","","",58,[[["self"],["formatter"]],["result"]]],[11,"clone","","",58,[[["self"]],["enum"]]],[11,"new","","Creates a new enum definition.",58,[[["rcstr"],["option",["rcstr"]],["option",["vec"]]],["self"]]],[11,"name","","Returns the name of the enum.",58,[[["self"]],["rcstr"]]],[11,"add_value","","Adds a possible value to the enum.",58,[[["self"],["rcstr"],["option",["string"]]]]],[11,"add_alias","","Adds an alias to the enum possible values.",58,[[["self"],["rcstr"],["hashset",["rcstr"]],["option",["string"]]]]],[11,"aliases","","Lists the aliases.",58,[[["self"]],["indexmap"]]],[11,"doc","","Returns the documentation associated with the enum.",58,[[["self"]],["option",["str"]]]],[11,"values","","Returns the values the enum can take, and their associated comment.",58,[[["self"]],["indexmap"]]],[11,"expand","","Replaces aliases by the corresponding values.",58,[[["self"],["it"]],["hashset",["rcstr"]]]],[11,"inverse","","Inverse an antisymmetric value.",58,[[["self"],["rcstr"]],["rcstr"]]],[11,"inverse_mapping","","Returns the mapping to apply to obtain the symmetric of a value.",58,[[["self"]],["option"]]],[11,"clone","","",34,[[["self"]],["trigger"]]],[11,"fmt","","",34,[[["self"],["formatter"]],["result"]]],[0,"lexer","telamon_gen","",N,N],[3,"Spanned","telamon_gen::lexer","",N,N],[12,"beg","","",2,N],[12,"end","","",2,N],[12,"data","","Spanned data",2,N],[3,"LexerPosition","","A sequence's row/column position",N,N],[12,"line","","",59,N],[12,"column","","",59,N],[3,"Position","","",N,N],[12,"position","","",1,N],[12,"filename","","",1,N],[3,"Span","","A double sequence's row/column position",N,N],[12,"beg","","",60,N],[12,"end","","",60,N],[3,"LexicalError","","",N,N],[12,"cause","","",61,N],[3,"Lexer","","",N,N],[4,"Token","","",N,N],[13,"ValueIdent","","",62,N],[13,"ChoiceIdent","","",62,N],[13,"Var","","",62,N],[13,"Doc","","",62,N],[13,"CmpOp","","",62,N],[13,"Code","","",62,N],[13,"CounterKind","","",62,N],[13,"Bool","","",62,N],[13,"CounterVisibility","","",62,N],[13,"And","","",62,N],[13,"Trigger","","",62,N],[13,"When","","",62,N],[13,"Alias","","",62,N],[13,"Counter","","",62,N],[13,"Define","","",62,N],[13,"Enum","","",62,N],[13,"Equal","","",62,N],[13,"Forall","","",62,N],[13,"In","","",62,N],[13,"Is","","",62,N],[13,"Not","","",62,N],[13,"Require","","",62,N],[13,"Requires","","",62,N],[13,"Value","","",62,N],[13,"End","","",62,N],[13,"Symmetric","","",62,N],[13,"AntiSymmetric","","",62,N],[13,"Arrow","","",62,N],[13,"Colon","","",62,N],[13,"Comma","","",62,N],[13,"LParen","","",62,N],[13,"RParen","","",62,N],[13,"BitOr","","",62,N],[13,"Or","","",62,N],[13,"SetDefKey","","",62,N],[13,"Set","","",62,N],[13,"SubsetOf","","",62,N],[13,"SetIdent","","",62,N],[13,"Base","","",62,N],[13,"Disjoint","","",62,N],[13,"Quotient","","",62,N],[13,"Of","","",62,N],[13,"Divide","","",62,N],[13,"Integer","","",62,N],[4,"ErrorKind","","",N,N],[13,"InvalidToken","","",63,N],[12,"token","telamon_gen::lexer::ErrorKind","",63,N],[13,"InvalidInclude","telamon_gen::lexer","",63,N],[12,"name","telamon_gen::lexer::ErrorKind","",63,N],[12,"code","","",63,N],[11,"default","telamon_gen::lexer","",59,[[],["lexerposition"]]],[11,"clone","","",59,[[["self"]],["lexerposition"]]],[11,"fmt","","",59,[[["self"],["formatter"]],["result"]]],[11,"eq","","",59,[[["self"],["lexerposition"]],["bool"]]],[11,"ne","","",59,[[["self"],["lexerposition"]],["bool"]]],[11,"new","","",59,[[["c_uint"],["c_uint"]],["self"]]],[11,"fmt","","",59,[[["self"],["formatter"]],["result"]]],[11,"default","telamon_gen::ast","",1,[[],["position"]]],[11,"clone","","",1,[[["self"]],["position"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"eq","","",1,[[["self"],["position"]],["bool"]]],[11,"ne","","",1,[[["self"],["position"]],["bool"]]],[11,"new","","",1,[[["lexerposition"],["string"]],["self"]]],[11,"new_optional","","",1,[[["lexerposition"],["option",["pathbuf"]]],["self"]]],[11,"from","","",1,[[["lexerposition"]],["self"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"default","telamon_gen::lexer","",60,[[],["span"]]],[11,"clone","","",60,[[["self"]],["span"]]],[11,"fmt","","",60,[[["self"],["formatter"]],["result"]]],[11,"eq","","",60,[[["self"],["span"]],["bool"]]],[11,"ne","","",60,[[["self"],["span"]],["bool"]]],[11,"fmt","","",60,[[["self"],["formatter"]],["result"]]],[11,"default","telamon_gen::ast","",2,[[],["spanned"]]],[11,"clone","","",2,[[["self"]],["spanned"]]],[11,"eq","","",2,[[["self"],["spanned"]],["bool"]]],[11,"ne","","",2,[[["self"],["spanned"]],["bool"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"with_data","","",2,[[["self"],["t"]],["spanned"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"from","","",2,[[["spanned",["rcstr"]]],["spanned",["string"]]]],[11,"fmt","telamon_gen::lexer","",62,[[["self"],["formatter"]],["result"]]],[11,"clone","","",62,[[["self"]],["token"]]],[11,"eq","","",62,[[["self"],["token"]],["bool"]]],[11,"ne","","",62,[[["self"],["token"]],["bool"]]],[6,"ParserSpanned","","The alias Spanned is a definition of the stream format. The parser will accept an iterator where each item in the stream has the following structure.",N,N],[6,"LexerItem","","",N,N],[11,"fmt","","",63,[[["self"],["formatter"]],["result"]]],[11,"clone","","",63,[[["self"]],["errorkind"]]],[11,"eq","","",63,[[["self"],["errorkind"]],["bool"]]],[11,"ne","","",63,[[["self"],["errorkind"]],["bool"]]],[11,"fmt","","",61,[[["self"],["formatter"]],["result"]]],[11,"clone","","",61,[[["self"]],["lexicalerror"]]],[11,"eq","","",61,[[["self"],["lexicalerror"]],["bool"]]],[11,"ne","","",61,[[["self"],["lexicalerror"]],["bool"]]],[11,"fmt","","",61,[[["self"],["formatter"]],["result"]]],[11,"new","","Returns a lexer interface for a iterable text.",64,[[["vec",["u8"]]],["self"]]],[11,"from_input","","Returns a lexer interface for a input stream.",64,[[["read"]],["self"]]],[11,"from_file","","Returns a lexer interface for a file.",64,[[["path"]],["self"]]],[11,"next","","",64,[[["self"]],["option"]]],[11,"drop","","",64,[[["self"]]]],[0,"parser","telamon_gen","",N,N],[5,"parse_ast","telamon_gen::parser","",N,[[["__tokens"]],["result",["ast","parseerror"]]]],[8,"__ToTriple","","",N,N],[16,"Error","","",65,N],[10,"to_triple","","",65,[[["self"]],["result"]]],[0,"error","telamon_gen","",N,N],[3,"Error","telamon_gen::error","",N,N],[12,"path","","Display of filename.",66,N],[12,"span","","Position of lexeme.",66,N],[11,"fmt","","",66,[[["self"],["formatter"]],["result"]]],[11,"from","","",66,N],[11,"fmt","","",66,[[["self"],["formatter"]],["result"]]],[11,"to_tokens","telamon_gen::ir","",48,[[["self"],["tokenstream"]]]],[11,"to_tokens","","",39,[[["self"],["tokenstream"]]]],[11,"fmt","","",48,[[["self"],["formatter"]],["result"]]],[11,"to_tokens","","",45,[[["self"],["tokenstream"]]]],[11,"fmt","","",58,[[["self"],["formatter"]],["result"]]],[11,"without_reverse_constraints","","Returns the same set but without reverse constraints.",56,[[["self"]],["setrefimpl"]]],[11,"superset","","Returns the direct superset of this set, if any.",56,[[["self"]],["option",["setrefimpl"]]]],[11,"path_to_superset","","Returns the path of sets to access a super-set.",56,[[["self"],["setref"]],["vec",["setrefimpl"]]]],[11,"is_subset_of","","Indicates if the first set is a sub-set of the second.",56,[[["self"],["set"]],["bool"]]],[11,"as_ref","","Returns the `SetRefImpl` corresponding to this set.",56,[[["self"]],["setrefimpl"]]]],"paths":[[3,"TypedConstraint"],[3,"Position"],[3,"Spanned"],[3,"CounterDef"],[3,"EnumDef"],[3,"IntegerDef"],[3,"Constraint"],[3,"SetDef"],[3,"TriggerDef"],[3,"Ast"],[3,"Quotient"],[3,"CounterBody"],[3,"SetRef"],[3,"VarDef"],[3,"ChoiceInstance"],[4,"ChoiceDef"],[4,"Hint"],[4,"TypeError"],[4,"Statement"],[4,"Check"],[4,"Symmetry"],[4,"Condition"],[4,"CounterVal"],[4,"EnumStatement"],[3,"CheckerContext"],[3,"VarMap"],[3,"FilterCall"],[3,"OnChangeAction"],[3,"ChoiceCondition"],[3,"FilterAction"],[3,"Filter"],[3,"Rule"],[3,"ChoiceInstance"],[3,"Code"],[3,"Trigger"],[4,"ChoiceArguments"],[4,"ChoiceDef"],[4,"CounterVisibility"],[4,"CounterVal"],[4,"ValueType"],[4,"FilterRef"],[4,"ChoiceAction"],[4,"SubFilter"],[4,"Variable"],[4,"Condition"],[4,"CmpOp"],[4,"ValueSet"],[4,"SetDefKey"],[4,"CounterKind"],[3,"Adaptator"],[3,"Choice"],[3,"SetConstraints"],[3,"Set"],[3,"SetRefImpl"],[3,"SetDef"],[8,"Adaptable"],[8,"SetRef"],[3,"IrDesc"],[3,"Enum"],[3,"LexerPosition"],[3,"Span"],[3,"LexicalError"],[4,"Token"],[4,"ErrorKind"],[3,"Lexer"],[8,"__ToTriple"],[3,"Error"]]};
searchIndex["telamon_gen_test"]={"doc":"","items":[],"paths":[]};
searchIndex["telamon_kernels"]={"doc":"Defines common kernels used to test and benchmark Telamon.","items":[[5,"analyze_bounds","telamon_kernels","Prints an analysis of the bounds computed by the lower bound model.",N,[[["vec",["boundsample"]]]]],[0,"linalg","","Linera algebra kernels.",N,N],[3,"Axpy","telamon_kernels::linalg","Computes `z = alpha*x+y`.",N,N],[3,"MatVec","","Computes `y = A.x`.",N,N],[3,"Gesummv","","Computes `y = (alpha*A + beta*B).x`.",N,N],[3,"MatMul","","Computes `C = A.B`.",N,N],[12,"params","","",0,N],[3,"MatMulP","","",N,N],[12,"m","","",1,N],[12,"n","","",1,N],[12,"k","","",1,N],[12,"a_stride","","",1,N],[12,"transpose_a","","",1,N],[12,"transpose_b","","",1,N],[12,"generic","","",1,N],[12,"m_tiling","","",1,N],[12,"n_tiling","","",1,N],[12,"k_tiling","","",1,N],[3,"BatchMM","","Batch transposed matrix-matrix multiplication.",N,N],[3,"BatchMMP","","",N,N],[12,"m","","",2,N],[12,"n","","",2,N],[12,"k","","",2,N],[12,"batch","","",2,N],[12,"transpose_a","","",2,N],[12,"transpose_b","","",2,N],[12,"batch_b","","",2,N],[12,"generic","","",2,N],[11,"name","","",3,[[],["str"]]],[11,"build_signature","","",3,N],[11,"build_body","","",3,[[["self"],["signature"],["context"]],["vec",["candidate"]]]],[11,"get_expected_output","","",3,[[["self"],["context"]],["arrayd"]]],[11,"check_result","","",3,N],[11,"name","","",4,[[],["str"]]],[11,"build_signature","","",4,N],[11,"build_body","","",4,[[["self"],["signature"],["context"]],["vec",["candidate"]]]],[11,"get_expected_output","","",4,[[["self"],["context"]],["array1"]]],[11,"check_result","","",4,N],[11,"name","","",5,[[],["str"]]],[11,"build_signature","","",5,N],[11,"build_body","","",5,[[["self"],["signature"],["context"]],["vec",["candidate"]]]],[11,"get_expected_output","","",5,[[["self"],["context"]],["array1"]]],[11,"check_result","","",5,N],[11,"clone","","",1,[[["self"]],["matmulp"]]],[11,"new","","",1,[[["i32"],["i32"],["i32"]],["self"]]],[11,"transpose_a","","",1,[[["self"]],["self"]]],[11,"transpose_b","","",1,[[["self"]],["self"]]],[11,"stride_a","","",1,[[["self"],["u32"]],["self"]]],[11,"static_sizes","","Inline the sizes in the generated code.",1,[[["self"]],["self"]]],[11,"name","","",0,[[],["str"]]],[11,"build_signature","","",0,[[["matmulp"],["signaturebuilder"]],["self"]]],[11,"build_body","","",0,[[["self"],["signature"],["context"]],["vec",["candidate"]]]],[11,"get_expected_output","","",0,[[["self"],["context"]],["array2"]]],[11,"check_result","","",0,N],[11,"clone","","",2,[[["self"]],["batchmmp"]]],[11,"new","","",2,[[["i32"],["i32"],["i32"],["i32"]],["self"]]],[11,"transpose_a","","",2,[[["self"]],["self"]]],[11,"transpose_b","","",2,[[["self"]],["self"]]],[11,"static_sizes","","Generate code that is onyl valid for the given sizes. The batch size is still generic.",2,[[["self"]],["self"]]],[11,"reuse_b","","Reuse the `B` matrix across the batch.",2,[[["self"]],["self"]]],[11,"name","","",6,[[],["str"]]],[11,"build_signature","","",6,[[["batchmmp"],["signaturebuilder"]],["self"]]],[11,"build_body","","",6,[[["self"],["signature"],["context"]],["vec",["candidate"]]]],[11,"get_expected_output","","",6,[[["self"],["context"]],["array3"]]],[11,"check_result","","",6,N],[0,"statistics","telamon_kernels","Statistical analysis for benchmarking.",N,N],[3,"Estimate","telamon_kernels::statistics","Estimates a mean within a confidence interval.",N,N],[12,"unit","","",7,N],[12,"value","","",7,N],[12,"interval","","",7,N],[12,"confidence","","",7,N],[5,"mean","","Computes the mean of a data set.",N,N],[5,"estimate_mean","","Computes the mean and the confidence interval of the data set. The requested degree of confidence must be between 0 and 1.",N,[[["vec",["f64"]],["f64"],["str"]],["estimate"]]],[5,"estimate_ratio","","Computes the error margin of a ratio between answer of a binary choice given the number of samples with a 95% confidence interval.",N,[[["f64"],["usize"]],["estimate"]]],[11,"fmt","","",7,[[["self"],["formatter"]],["result"]]],[8,"Kernel","telamon_kernels","A kernel that can be compiled, benchmarked and used for correctness tests.",N,N],[16,"Parameters","","The input parameters of the kernel.",8,N],[16,"ExpectedOutput","","The values to expect as output.",8,N],[10,"name","","The name of the function computed by the kernel.",8,[[],["str"]]],[10,"build_signature","","Builds the signature of the kernel in the builder and returns an object that stores enough information to later build the kernel body and check its result. The `is_generic` flag indicates if th sizes should be instantiated.",8,N],[10,"build_body","","Builder the kernel body in the given builder. This builder should be based on the signature created by `build_signature`.",8,[[["self"],["signature"],["context"]],["vec",["candidate"]]]],[10,"get_expected_output","","Computes the expected output.",8,N],[10,"check_result","","Ensures the generated code performs the correct operation.",8,N],[11,"test_correctness","","Generates, executes and tests the output of candidates for the kernel.",8,N],[11,"test_bound","","Tests the correctness of the bound of kernels and returns the list of tested leafs along with the actual evaluation time.",8,N],[11,"benchmark","","Runs the search and benchmarks the resulting candidate.",8,N],[11,"deadend_ratio","","Computes the probability of encountering a dead-end when descending in the search tree.",8,N],[8,"Scalar","","A scalar that can be used as the data type for tests.",N,N],[11,"epsilon","","Returns the amount of allowed error in tests.",9,[[],["self"]]],[11,"is_err_ok","","Indicates if the scalar can be considered as zero in the context of error checking.",9,[[["self"]],["bool"]]],[11,"test_correctness","","Generates, executes and tests the output of candidates for the kernel.",8,N],[11,"test_bound","","Tests the correctness of the bound of kernels and returns the list of tested leafs along with the actual evaluation time.",8,N],[11,"benchmark","","Runs the search and benchmarks the resulting candidate.",8,N],[11,"deadend_ratio","","Computes the probability of encountering a dead-end when descending in the search tree.",8,N]],"paths":[[3,"MatMul"],[3,"MatMulP"],[3,"BatchMMP"],[3,"Axpy"],[3,"MatVec"],[3,"Gesummv"],[3,"BatchMM"],[3,"Estimate"],[8,"Kernel"],[8,"Scalar"]]};
searchIndex["telamon_utils"]={"doc":"Generic helper functions.","items":[[3,"Cache","telamon_utils","A thread-safe LRU Cache.",N,N],[3,"Dag","","A directed acyclic graph given by adjacency list.",N,N],[3,"FilterList","","Iterates over a linked list while removing some items.",N,N],[3,"ZipCopy","","Zip copies of an object with an iterator.",N,N],[3,"PartialPermutations","","",N,N],[3,"VecSet","","A set backed by an ordered vector.",N,N],[3,"RcStr","","A reference counted string, compatible with `&str`.",N,N],[4,"Trivalent","","Booleans enhanced with a third `Maybe` value.",N,N],[13,"False","","",0,N],[13,"Maybe","","",0,N],[13,"True","","",0,N],[5,"filter_list","","Iterates over a linked list while removing some items.",N,[[["linkedlist"],["f"]],["filterlist"]]],[5,"zip_copy","","Zip copies of an object with an iterator.",N,[[["i"],["t"]],["zipcopy"]]],[5,"at_most_one","","Ensures an iterator has at most one element.",N,[[["it"]],["option"]]],[5,"to_map","","Transforms an iterator into an `HashMap`. Redundant nodes are merged using `merge`.",N,[[["it"],["m"]],["hashmap"]]],[5,"div_ceil","","Performs an integer divison rounded to the upper number.",N,[[["t"],["t"]],["t"]]],[5,"log2_u32","","Returns the log2 of a power of 2.",N,[[["u32"]],["option",["u32"]]]],[5,"clone_pair","","Clones a pair of reference.",N,N],[5,"cmp_f64","","Compare two f64, panic if one of them is nan",N,[[["f64"],["f64"]],["ordering"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"new","","Returns a new `Cache` that can store `capacity` elements.",1,[[["usize"]],["self"]]],[11,"get","","Returns the element associated to `key` in the cache. Generates the element with `gen` and store it in the cache if it is not already present.",1,[[["self"],["k"],["f"]],["arc"]]],[11,"clear","","Removes all elements from the `Cache`.",1,[[["self"]]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"from_order","","Computes a minimal DAG from a partial order.",2,[[["vec"],["c"]],["dag"]]],[11,"nodes","","Returns the list of nodes, in increasing order.",2,N],[11,"before","","Returns the predecessors of the given node.",2,N],[11,"after","","Returns the successors of the given node.",2,N],[11,"minima","","Returns the id of nodes without predecessors.",2,[[["self"]],["vec",["usize"]]]],[11,"predecessors","","Returns all the predecessors of a node.",2,[[["self"],["usize"]],["vec",["usize"]]]],[11,"next","","",3,[[["self"]],["option"]]],[11,"next","","",4,[[["self"]],["option"]]],[11,"new","","Returns an iterator of the partial permuations of size `k` of values. Permutations are returned in lexicographical order.",5,[[["it"],["usize"]],["self"]]],[11,"next","","",5,[[["self"]],["option",["vec"]]]],[0,"multimap","","A `HashMap` with mutiple values for each key.",N,N],[3,"MultiHashMap","telamon_utils::multimap","A `HashMap` with mutiple values for each key.",N,N],[11,"clone","","",6,[[["self"]],["multihashmap"]]],[11,"serialize","","",6,[[["self"],["s"]],["result"]]],[11,"new","","Creates an empty `MultiHashMap`.",6,[[],["multihashmap",["randomstate"]]]],[11,"with_capacity","","Creates an empty hash map with the given initial capacity.",6,[[["usize"]],["multihashmap",["randomstate"]]]],[11,"with_hasher","","Creates an empty `MultiHashMap` which will use the given hash builder to hash keys.",6,[[["s"]],["self"]]],[11,"with_capacity_and_hasher","","Creates an empty `MultiHashMap` with space for at least `capacity`  elements, using `hasher` to hash the keys.",6,[[["usize"],["s"]],["self"]]],[11,"capacity","","Returns the number of elements the map can hold without reallocating.",6,[[["self"]],["usize"]]],[11,"reserve","","Reserves capacity for at least `additional` more elements to be inserted in the `MultiHashMap`. The collection may reserve more space to avoid frequent reallocations.",6,[[["self"],["usize"]]]],[11,"shrink_to_fit","","Shrinks the capacity of the map as much as possible. It will drop down as much as possible while maintaining the internal rules and possibly leaving some space in accordance with the resize policy.",6,[[["self"]]]],[11,"keys","","An iterator visiting all keys in arbitrary order.",6,[[["self"]],["keys",["vec"]]]],[11,"values","","An iterator visiting all values in arbitrary order.",6,[[["self"]],[""]]],[11,"values_mut","","An iterator visitinf all values mutably in arbitrary order.",6,[[["self"]],[""]]],[11,"iter","","Iterates over all the keys and returns the associated values.",6,[[["self"]],["iter",["vec"]]]],[11,"num_keys","","Returns the number of keys.",6,[[["self"]],["usize"]]],[11,"is_empty","","Indicates if the map contains no elements.",6,[[["self"]],["bool"]]],[11,"drain","","Clears the map, returning all key-value pairs as an iterator. Keeps the allocated memory for reuse.",6,[[["self"]],["drain",["vec"]]]],[11,"clear","","Clears the map, removing all keys and values.",6,[[["self"]]]],[11,"get","","Returns the values mapped to the key.",6,[[["self"],["q"]],[""]]],[11,"contains_key","","Indicates if the map contains a value for the specified key.",6,[[["self"],["q"]],["bool"]]],[11,"get_mut","","Returns an iterator over mutable reference to the values mapped to the key.",6,[[["self"],["q"]],[""]]],[11,"insert","","Inserts new value to the map.",6,[[["self"],["k"],["v"]]]],[11,"insert_many","","Inserts new value to the map.",6,[[["self"],["k"],["vec"]]]],[11,"remove","","Removes all the elements bound to a key.",6,[[["self"],["q"]],["vec"]]],[11,"eq","","",6,[[["self"],["self"]],["bool"]]],[11,"fmt","","",6,[[["self"],["formatter"]],["result"]]],[11,"default","","",6,[[],["self"]]],[11,"index","","",6,N],[11,"into_iter","","",6,N],[11,"from_iter","","",6,[[["t"]],["self"]]],[11,"from_iter","","",6,[[["t"]],["self"]]],[0,"ndarray","telamon_utils","An array with a variable number of dimensions.",N,N],[3,"NDArray","telamon_utils::ndarray","An array with a variable number of dimensions.",N,N],[12,"dims","","",7,N],[3,"NDRange","","A N-dimentional range.",N,N],[3,"ViewMut","","A mutable view on a `NDArray`, with some dimensions fixed.",N,N],[3,"ViewMutIter","","Iterator over the elements in a mutable view.",N,N],[3,"ViewIterMut","","Mutable iterator over the elements in a mutable view.",N,N],[11,"fmt","","",7,[[["self"],["formatter"]],["result"]]],[11,"new","","Create a NDArray and initializes it with the generator.",7,[[["vec",["usize"]],["vec"]],["ndarray"]]],[11,"init_default","","Initializes an NDArray with default values.",7,[[["vec",["usize"]]],["self"]]],[11,"num_dims","","Returns the number of dimensions in the array.",7,[[["self"]],["usize"]]],[11,"view_mut","","Returns a mutable view on the NDArray.",7,[[["self"]],["viewmut"]]],[11,"index","","",7,N],[11,"index_mut","","",7,N],[11,"new","","Creates a ND range with the given bounds.",8,N],[11,"next","","",8,[[["self"]],["option"]]],[11,"num_dims","","Returns the number of non-fixed dimensions in the view.",9,[[["self"]],["usize"]]],[11,"split","","Splits the view on the given dimension.",9,[[["self"],["usize"]],["vec",["viewmut"]]]],[11,"enumerate","","Enumerates the elements with their indexes.",9,[[["self"]],[""]]],[11,"enumerate_mut","","Produces mutable references to the elements, with their indexes.",9,[[["self"]],[""]]],[11,"index","","",9,N],[11,"index_mut","","",9,N],[11,"next","","",10,[[["self"]],["option"]]],[11,"next","","",11,[[["self"]],["option"]]],[11,"clone","telamon_utils","",12,[[["self"]],["vecset"]]],[11,"eq","","",12,[[["self"],["vecset"]],["bool"]]],[11,"ne","","",12,[[["self"],["vecset"]],["bool"]]],[11,"hash","","",12,N],[11,"new","","Creates a new `VecSet` with the given data.",12,[[["vec"]],["self"]]],[11,"is_empty","","Indicates if the `VecSet` is empty.",12,[[["self"]],["bool"]]],[11,"len","","Returns the number of elements in the set.",12,[[["self"]],["usize"]]],[11,"iter","","Iterates over the set, in order.",12,[[["self"]],["iter"]]],[11,"difference","","Returns the elements in self but not in other.",12,[[["self"],["vecset"]],["difference"]]],[11,"relative_difference","","Returns `self\\other` and `other\\self`.",12,N],[11,"intersection","","Returns a set containing the elements present in both `self` and `other`.",12,[[["self"],["vecset"]],["intersection"]]],[11,"intersect","","In-place intersection with another `VecSet`.",12,[[["self"],["vecset"]]]],[11,"union","","Returns a set containing the elements present in either self`or`other`.",12,[[["self"],["vecset"]],["vecset"]]],[11,"filter","","Returns a new `VecSet` with only the elements for which the predicate returned `true`.",12,[[["self"],["p"]],["self"]]],[11,"retain","","Filters out elements for wich the predicate returns false.",12,[[["self"],["p"]]]],[11,"insert","","Inserts an element in the `VecSet`. This operation has a complexity in O(n). Returns `false` if the item was already present.",12,[[["self"],["t"]],["bool"]]],[11,"contains","","Indicates if the `VecSet` contains the given object.",12,[[["self"],["t"]],["bool"]]],[11,"default","","",12,[[],["self"]]],[11,"fmt","","",12,[[["self"],["formatter"]],["result"]]],[11,"partial_cmp","","",12,[[["self"],["vecset"]],["option",["ordering"]]]],[11,"into_iter","","",12,N],[11,"from_iter","","",12,[[["it"]],["self"]]],[11,"deref","","",12,N],[0,"unwrap","","A macro to help debug unwraps.",N,N],[8,"Unwrap","telamon_utils::unwrap","",N,N],[16,"Output","","The type retruned by unwraping.",13,N],[10,"unwrap","","Unwraps the value or panics with the given message.",13,N],[0,"sequence","telamon_utils","",N,N],[4,"Sequence","telamon_utils::sequence","A type representing a sequence of values.",N,N],[13,"List","","",14,N],[13,"Vec","","",14,N],[11,"to_vec","","",14,[[["self"]],["vec"]]],[11,"into","","",14,[[["self"]],["vec"]]],[11,"serialize","","",14,[[["self"],["s"]],["result"]]],[11,"deserialize","","",14,[[["d"]],["result",["sequence"]]]],[0,"tfrecord","telamon_utils","This module provides Read and Write extensions for reading and writing TFRecord files. TFRecord is a simple container file format for embedding a sequence of data used notably by TensorFlow (see https://www.tensorflow.org/api_guides/python/python_io).",N,N],[4,"ReadError","telamon_utils::tfrecord","The error type for errors occuring while reading a tfrecord file.",N,N],[13,"IOError","","An I/O error occured.",15,N],[13,"TruncatedRecord","","The underlying data was shorter than advertised in the header's length field. If this happens because the end-of-file was reached, an I/O error will be raised instead.",15,N],[13,"CorruptedRecord","","Either the header or the data was corrupted and failed the CRC check.",15,N],[4,"WriteError","","The error type for errors occuring while writing a tfrecord file.",N,N],[13,"IOError","","An I/O error occured.",16,N],[8,"RecordReader","","A trait extension for reading records.",N,N],[11,"read_record","","Read a single record.",17,[[["self"]],["result",["vec","readerror"]]]],[8,"RecordWriter","","A trait extension for writing records.",N,N],[16,"Writer","","",18,N],[11,"write_record","","",18,N],[10,"finish","","Writes all output to the file and conclude the stream. Returns the underlying writer. Does not flush the underlying writer.",18,[[["self"]],["result",["writeerror"]]]],[10,"finish_box","","Equivalent to `finish` for boxed trait objects, because we otherwise can't move out of the unsized trait object.",18,[[["box"]],["result",["writeerror"]]]],[11,"fmt","","",15,[[["self"],["formatter"]],["result"]]],[11,"from","","",15,[[["error"]],["readerror"]]],[11,"fmt","","",16,[[["self"],["formatter"]],["result"]]],[11,"from","","",16,[[["error"]],["writeerror"]]],[11,"from","","",16,[[["intoinnererror"]],["writeerror"]]],[6,"DefaultHasher","telamon_utils","A fast but not secure `Hasher`.",N,N],[6,"HashSet","","An `HashSet` based on `DefaultHasher`.",N,N],[6,"HashMap","","An `HashMap` based on `DefaultHasher`.",N,N],[6,"MultiHashMap","","A `HashMap` based on `DefaultHasher`.",N,N],[8,"BuilderTrait","","A trait that implements useful methods on builders.",N,N],[11,"doif","","Runs the closure if the bool is true.",19,[[["self"],["bool"],["f"]],["self"]]],[11,"default","","",20,[[],["rcstr"]]],[11,"clone","","",20,[[["self"]],["rcstr"]]],[11,"eq","","",20,[[["self"],["rcstr"]],["bool"]]],[11,"ne","","",20,[[["self"],["rcstr"]],["bool"]]],[11,"hash","","",20,N],[11,"cmp","","",20,[[["self"],["rcstr"]],["ordering"]]],[11,"partial_cmp","","",20,[[["self"],["rcstr"]],["option",["ordering"]]]],[11,"lt","","",20,[[["self"],["rcstr"]],["bool"]]],[11,"le","","",20,[[["self"],["rcstr"]],["bool"]]],[11,"gt","","",20,[[["self"],["rcstr"]],["bool"]]],[11,"ge","","",20,[[["self"],["rcstr"]],["bool"]]],[11,"fmt","","",20,[[["self"],["formatter"]],["result"]]],[11,"new","","Creates a new reference-counted string.",20,[[["string"]],["self"]]],[11,"from","","",20,[[["str"]],["self"]]],[11,"serialize","","",20,[[["self"],["s"]],["result"]]],[11,"borrow","","",20,[[["self"]],["str"]]],[11,"borrow","","",20,[[["self"]],["string"]]],[11,"deref","","",20,[[["self"]],["string"]]],[11,"fmt","","",20,[[["self"],["formatter"]],["result"]]],[11,"eq","","",20,[[["self"],["str"]],["bool"]]],[11,"from","","",20,[[["string"]],["rcstr"]]],[11,"eq","","",0,[[["self"],["trivalent"]],["bool"]]],[11,"clone","","",0,[[["self"]],["trivalent"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"as_bool","","Returns the boolean represented.",0,[[["self"]],["option",["bool"]]]],[11,"maybe_true","","Returns `true` if the underlying boolean might be `true`.",0,[[["self"]],["bool"]]],[11,"maybe_false","","Returns `true` if the underlying boolean might be `false`.",0,[[["self"]],["bool"]]],[11,"is_true","","Returns `true` if the underlying boolean is `true`.",0,[[["self"]],["bool"]]],[11,"is_false","","Returns `true` if the underlying boolean is `false`.",0,[[["self"]],["bool"]]],[11,"is_maybe","","Returns `true` if the underlying boolean might be `true` and `false`.",0,[[["self"]],["bool"]]],[11,"bitand","","",0,[[["self"],["trivalent"]],["trivalent"]]],[11,"bitor","","",0,[[["self"],["trivalent"]],["trivalent"]]],[11,"not","","",0,[[["self"]],["trivalent"]]],[14,"unwrap","","Panics after if the value cannot be unwraped.",N,N],[14,"generated_file","","Includes a generates file into the current file.",N,N],[14,"eq_from_key","","Derives `Eq` based on a method that returns a key for the object.",N,N],[14,"hash_from_key","","Derives `Eq` and `Hash` based on a method that returns a key for the object.",N,N]],"paths":[[4,"Trivalent"],[3,"Cache"],[3,"Dag"],[3,"FilterList"],[3,"ZipCopy"],[3,"PartialPermutations"],[3,"MultiHashMap"],[3,"NDArray"],[3,"NDRange"],[3,"ViewMut"],[3,"ViewMutIter"],[3,"ViewIterMut"],[3,"VecSet"],[8,"Unwrap"],[4,"Sequence"],[4,"ReadError"],[4,"WriteError"],[8,"RecordReader"],[8,"RecordWriter"],[8,"BuilderTrait"],[3,"RcStr"]]};
initSearch(searchIndex);
