include "layout.exh"

set Variables:
  item_type = "ir::Variable"
  id_type = "ir::VarId"
  item_getter = "$fun.variable($id)"
  id_getter = "$item.id()"
  iterator = "$fun.variables()"
  var_prefix = "variable"
  new_objs = "$objs.variables"
end

set DefStatements($var in Variables) subsetof Statements:
  item_type = "ir::Statement"
  id_type = "ir::StmtId"
  item_getter = "$fun.statement($id)"
  id_getter = "$item.stmt_id()"
  iterator = "$var.def_points().map(|id| $fun.statement(id))"
  from_superset = "if $item.defined_vars().contains(&$var.id()) { Some($item) } else { None }"
  reverse forall $stmt in Statements = "$stmt.defined_vars().iter().map(|&id| $fun.variable(id))"
  var_prefix = "def"
  new_objs = "$objs.def_statements"
end

set UseStatements($var in Variables) subsetof Statements:
  item_type = "ir::Statement"
  id_type = "ir::StmtId"
  item_getter = "$fun.statement($id)"
  id_getter = "$item.stmt_id()"
  iterator = "$var.use_points().map(|id| $fun.statement(id))"
  from_superset = "if $item.used_vars().contains(&$var.id()) { Some($item) } else { None }"
  reverse forall $stmt in Statements = "$stmt.used_vars().iter().map(|&id| $fun.variable(id))"
  var_prefix = "use"
  new_objs = "$objs.use_statements"
end

set UseInsts($var in Variables) subsetof Instructions:
  item_type = "ir::Instruction"
  id_type = "ir::InstId"
  item_getter = "$fun.inst($id)"
  id_getter = "$item.id()"
  iterator = "$var.use_points().flat_map(|id| $fun.statement(id).as_inst())"
  from_superset = "if $item.used_vars().contains(&$var.id()) { Some($item) } else { None }"
  reverse forall $inst in Instructions = "$inst.used_vars().iter().map(|&id| $fun.variable(id))"
  var_prefix = "use"
  new_objs = "$objs.use_insts"
end

/// Lists variables $var depends of.
set PredecessorVars($var in Variables) subsetof Variables:
  item_type = "ir::Variable"
  id_type = "ir::VarId"
  item_getter = "$fun.variable($id)"
  id_getter = "$item.id()"
  iterator = "$var.predecessors().iter().map(|&id| $fun.variable(id))"
  from_superset = "if $var.predecessors().contains(&$item.id()) { Some($item) } else { None }"
  reverse forall $var in Variables = "$var.successors().iter().map(|&id| $fun.variable(id))"
  var_prefix = "predecessor"
  new_objs = "$objs.predecessors"
end

/// Lists the dimensions on which $var can vary.
set VarLayout($var in Variables) subsetof LayoutDimensions:
  item_type = "ir::LayoutDimension"
  id_type = "ir::LayoutDimId"
  item_getter = "$fun.layout_dimension($id)"
  id_getter = "$item.id()"
  iterator = "$var.layout().iter().map(|&dim| $fun.layout_dimension(dim))"
  from_superset = "if $var.layout().contains(&$item.id()) { Some($item) } else { None }"
  reverse forall $dim in LayoutDimensions =
    "$dim.variable().into_iter().map(|id| $fun.variable(id))"
  new_objs = "$objs.var_layout"
end

/// Intersection of `VarLayout` and `MemLayoutDimensions`.
set VarMemLayout($var in Variables) subsetof MemLayoutDimensions:
  item_type = "ir::LayoutDimension"
  id_type = "ir::LayoutDimId"
  item_getter = "$fun.layout_dimension($id)"
  id_getter = "$item.id()"
  iterator = "$var.layout().iter().map(|&dim| $fun.layout_dimension(dim))\
    .filter(|dim| dim.is_memory_layout())"
  from_superset = "if $var.layout().contains(&$item.id()) && $item.is_memory_layout()\
    { Some($item) } else { None }"
  reverse forall $dim in MemLayoutDimensions =
    "$dim.variable().into_iter().map(|id| $fun.variable(id))"
  new_objs = "$objs.mem_var_layout"
end

// Only dimensions with a known size may be instantiated.
require forall $var in Variables:
  forall $dim in VarLayout($var):
    "$fun.dim($dim.dim()).possible_sizes().is_some()" || is_instantiated($dim) is FALSE


// Forbid implicit broadcast of the fby intialization variable.
require forall $var in Variables:
  forall $inst in UseInsts($var):
    forall $dim in IterationDims($inst):
      forall $def in DefStatements($var):
        "!$var.def().is_fby() || $var.dimensions().contains(&$dim.id())"
        || order($dim, $def) is OUTER

// Ensure the `fby` and its `prev` variable can be stored in the same place.
require forall $fby in Variables:
  forall $pred in PredecessorVars($fby):
    forall $use in UseStatements($fby):
      forall $def in DefStatements($pred):
        "!$fby.def().is_fby_prev($pred.id())" || order($use, $def) is BEFORE

// Enforce data dependencies.
require forall $var in Variables:
  forall $def in DefStatements($var):
    forall $use in UseStatements($var):
      order($def, $use) is BEFORE

/// Specifies where to store a variable.
define enum memory_space($var in Variables):
  value REGISTER:
    requires forall $layout_dim in VarLayout($var):
      forall $dim in ActualDimension($layout_dim):
        "!$fun.device().has_vector_registers()" || dim_kind($dim) is not VECTOR
  value VECTOR_REGISTER:
    requires "$fun.device().has_vector_registers()"
    // Ensure vector registers are the same at source and destination.
    requires forall $rhs in VarLayout($var):
      forall $lhs in PredecessorLayout($rhs):
        forall $lhs_dim in ActualDimension($lhs):
          forall $rhs_dim in ActualDimension($rhs):
            dim_kind($lhs_dim) is not INNER_VECTOR || dim_kind($rhs_dim) is INNER_VECTOR
            dim_kind($lhs_dim) is not OUTER_VECTOR || dim_kind($rhs_dim) is OUTER_VECTOR
    // The order of mapped vector dimensions is preserved.
    requires forall $outer_rhs in VarLayout($var):
      forall $inner_rhs in VarLayout($var):
        forall $outer_lhs in PredecessorLayout($outer_rhs):
          forall $inner_lhs in PredecessorLayout($inner_rhs):
            forall $outer_lhs_dim in ActualDimension($outer_lhs):
              forall $outer_rhs_dim in ActualDimension($outer_rhs):
                forall $inner_lhs_dim in ActualDimension($inner_lhs):
                  forall $inner_rhs_dim in ActualDimension($inner_rhs):
                    dim_kind($outer_lhs_dim) is not VECTOR
                      || dim_kind($inner_lhs_dim) is not VECTOR
                      || order($outer_lhs_dim, $inner_lhs_dim) is not OUTER
                      || order($outer_rhs_dim, $inner_rhs_dim) is OUTER
  value GLOBAL:
    requires "$var.is_valid_memory_space(ir::MemorySpace::Global)"
  value SHARED:
    requires "$var.is_valid_memory_space(ir::MemorySpace::Shared)"
  alias MEMORY = GLOBAL | SHARED:
end

// We model synchronisation flags as vector registers to ensure the vectorization pattern
// is the same on the `DmaStart` and `DmaWait`.
require forall $var in Variables:
  "$var.t() != ir::Type::SyncFlag" || memory_space($var) is VECTOR_REGISTER

// Force `DmaStart` and `DmaWait` to have the same nesting. This supposes the
// synchronisation flag is transmitted through a DimMap(Inst(dma_start), ..) variable.
require forall $var in Variables:
  forall $pred in PredecessorVars($var):
    forall $use in UseStatements($var):
      forall $def in DefStatements($pred):
        forall $dim in Dimensions:
          "$var.t() != ir::Type::SyncFlag"
          || "$var.dimensions().contains(&$dim.id())"
          || order($use, $dim) is not INNER
          || order($def, $dim) is INNER
          "$var.t() != ir::Type::SyncFlag"
          || "$pred.dimensions().contains(&$dim.id())"
          || order($def, $dim) is not INNER
          || order($use, $dim) is INNER



/// Counts the number of time the variable is instantiated.
define half counter num_instances($var in Variables):
  forall $dim in VarLayout($var):
    forall $actual_dim in ActualStaticDimension($dim):
      mul size($actual_dim) when:
        is_instantiated($dim) is TRUE
end
/// Counts the number of time the variable is instantiated on non-vector dimensions.
define half counter num_vector_instances($var in Variables):
  forall $dim in VarLayout($var):
    forall $actual_dim in ActualStaticDimension($dim):
      mul size($actual_dim) when:
        is_instantiated($dim) is TRUE
        dim_kind($actual_dim) is not INNER_VECTOR
end

// Roughly limit the size taken by varaibles to the amount of memory available. This
// considers each variable on its own so it does not avoid spilling but avoids generating
// utterly bad candidates.
require forall $var in Variables:
  memory_space($var) is not REGISTER
    || num_instances($var) < "$fun.device().num_registers()"
  memory_space($var) is not VECTOR_REGISTER
    || "$var.t() == ir::Type::SyncFlag"
    || num_vector_instances($var) < "$fun.device().num_vector_registers()"
  memory_space($var) is not VECTOR_REGISTER
    || "$var.t() != ir::Type::SyncFlag"
    || num_vector_instances($var) < "$fun.device().num_sync_flags()"
  memory_space($var) is not SHARED
    || num_instances($var) < "$fun.available_shared_mem()"


/// Indicates if a variable is defined by copying the value of its predecessors or by just
/// aliasing with them.
define enum var_def_mode($var in Variables):
  value COPY:
    // We don't support copies with more than one predecessor (in Fby) and it doesn't
    // makes sens with 0.
    requires "$var.predecessors().len() == 1"
    requires forall $pred in PredecessorVars($var):
      // TODO(ulysse): support copies from memory.
      memory_space($pred) is not MEMORY
      // TODO(ulysse): enable REGISTER <-> VECTOR_REGISTER transfers.
      memory_space($var) is not REGISTER || memory_space($pred) is not VECTOR_REGISTER
      memory_space($var) is not VECTOR_REGISTER || memory_space($pred) is not REGISTER
    requires "$var.def_mode().allow_copies()"
  value IN_PLACE:
    requires forall $pred in PredecessorVars($var):
      memory_space($var) == memory_space($pred)
    requires forall $layout_dim in VarLayout($var):
      forall $pred in PredecessorLayout($layout_dim):
        is_instantiated($layout_dim) == is_instantiated($pred)
end

require forall $var in Variables:
  forall $rhs in VarLayout($var):
    forall $lhs in PredecessorLayout($rhs):
      forall $lhs_dim in ActualDimension($lhs):
        forall $rhs_dim in ActualDimension($rhs):
          // Ensure we only insert synchronisation where allowed.
          "$var.def_mode().allow_sync()"
            || order($lhs_dim, $rhs_dim) is MERGED
            || dim_kind($rhs_dim) is not THREAD
          // Ensure we allow point-to-point communication.
          order($lhs_dim, $rhs_dim) is MERGED
            || memory_space($var) is MEMORY
            || dim_kind($lhs_dim) is UNROLL | VECTOR | THREAD
          // .. using registers.
          order($lhs_dim, $rhs_dim) is MERGED
            || memory_space($var) is MEMORY
            || dim_kind($lhs_dim) is not UNROLL | VECTOR
            || dim_kind($rhs_dim) is UNROLL | VECTOR
  // .. or using threads
require forall $var in Variables:
  forall $rhs in VarLayout($var):
    forall $lhs in PredecessorLayout($rhs):
      forall $lhs_dim in ActualStaticDimension($lhs):
        forall $rhs_dim in ActualStaticDimension($rhs):
          order($lhs_dim, $rhs_dim) is MERGED
            || memory_space($var) is MEMORY
            || dim_kind($lhs_dim) is not THREAD
            || thread_mapping($lhs_dim, $rhs_dim) is MAPPED

// Ensure all copies from one memory space to the other are stores.
// TODO(ulysse): this artificial constraint is only needed because we don't have a generic
// memory copy instruction so we must now which instruction to generate. We should remove
// it and have a generic instruction instead.
// TODO(ulysse): It also allows us to avoid adding aliasing variables to the `Memory` set.
// Indeed only one variable in a chain of aliasing ones copies its content to memory. This
// is particularily useful for Fby variables since we don't have a good way yet to track
// aliasing in such cases.
require forall $var in Variables:
  forall $pred in PredecessorVars($var):
    memory_space($pred) is not MEMORY || memory_space($var) is MEMORY

// Lowers accesses to a variable and adds decisions to select the variable layout when it
// is placed in memory.
trigger forall $var in Variables:
  "::search_space::variable::lower_to_memory($var, ir_instance)" when
    memory_space($var) is MEMORY

// Lowers a variable definition when a copy is needed.
trigger forall $var in Variables:
  "::search_space::variable::lower_def($var, ir_instance)" when
    var_def_mode($var) is COPY

// The variable is instantiated along parallel dimensions.
require forall $var in Variables:
  forall $layout_dim in VarLayout($var):
    forall $dim in ActualDimension($layout_dim):
      dim_kind($dim) is not BLOCK
        || memory_space($var) is not GLOBAL
        || is_instantiated($layout_dim) is TRUE

// Ranks are unique.
require forall $var in Variables:
  forall $lhs in VarMemLayout($var):
    forall $rhs in VarMemLayout($var):
      rank($lhs) == "0" || rank($lhs) != rank($rhs)

// Ranks are transmitted along mappings.
require forall $var in Variables:
  forall $dim in VarMemLayout($var):
    forall $pred in PredecessorMemLayouts($dim):
      var_def_mode($var) is COPY || rank($dim) == rank($pred)

/// Lists variables that are allocated in memory and do not alias with any preceeding
/// variable.
set Memory subsetof Variables:
  item_type = "ir::Variable"
  id_type = "ir::VarId"
  item_getter = "$fun.variable($id)"
  id_getter = "$item.id()"
  iterator = "$fun.memory_vars()"
  from_superset = "if $item.is_memory() { Some($item) } else { None }"
  var_prefix = "mem"
  new_objs = "$objs.memory_vars"
end

// Ensure memory instructions are in memory.
require forall $mem in Memory:
  memory_space($mem) is MEMORY

/// Counts the total amount of shared memory used.
define half counter shared_mem_used():
  forall $mem in Memory:
    sum num_instances($mem) when:
      memory_space($mem) is SHARED
end

require shared_mem_used() < "$fun.available_shared_mem()"

/// Counts the number of instantiated decisions.
define counter num_mem_dims($var in Memory):
  forall $dim in VarMemLayout($var):
    sum "1" when: is_instantiated($dim) is TRUE
end

// Limit the rank to the number of instantiated dimensions.
require forall $var in Memory:
  forall $layout in VarMemLayout($var):
    rank($layout) <= num_mem_dims($var)

/// Lists the in-memory variables accessed by an instruction.
set AccessedVar($inst in MemInsts) subsetof Variables:
  item_type = "ir::Variable"
  id_type = "ir::VarId"
  item_getter = "$fun.variable($id)"
  id_getter = "$item.id()"
  iterator = "$inst.operator().accessed_mem_var().into_iter().map(|id| $fun.variable(id))"
  from_superset =
    "if $item.mem_accesses().contains($inst.id()) { Some($item) } else { None }"
  reverse forall $var in Variables =
    "$var.mem_accesses().iter().map(|&id| $fun.inst(id))"
  var_prefix = "var"
  new_objs = "$objs.accessed_var"
end

require forall $inst in MemInsts:
  forall $var in AccessedVar($inst):
    memory_space($var) is MEMORY
    memory_space($var) is GLOBAL || inst_flag($inst) is NO_CACHE
