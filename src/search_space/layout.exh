/// Indicates the layout of a memory block or variable.
set LayoutDimensions:
  item_type = "ir::LayoutDimension"
  id_type = "ir::LayoutDimId"
  item_getter = "$fun.layout_dimension($id)"
  id_getter = "$item.id()"
  iterator = "$fun.layout_dimensions()"
  var_prefix = "layout"
  new_objs = "$objs.layout_dims"
end

/// Maps layout dimensions to actual dimensions.
set ActualDimension($layout in LayoutDimensions) subsetof Dimensions:
  item_type = "ir::Dimension"
  id_type = "ir::DimId"
  item_getter = "$fun.dim($id)"
  id_getter = "$item.id()"
  iterator = "std::iter::once($fun.dim($layout.dim()))"
  from_superset =
    "if $item.layout_dims().contains(&$layout.id()) { Some($item) } else { None }"
  reverse forall $dim in Dimensions =
    "$dim.layout_dims().iter().map(|&id| $fun.layout_dimension(id))"
  var_prefix = "dim"
  new_objs = "$objs.actual_layout_dims"
end

/// Maps layout dimensions to actual dimensions that have a static size.
set ActualStaticDimension($layout in LayoutDimensions) subsetof StaticDims:
  item_type = "ir::Dimension"
  id_type = "ir::DimId"
  item_getter = "$fun.dim($id)"
  id_getter = "$item.id()"
  iterator =
    "{ let dim = $fun.dim($layout.dim()); dim.possible_sizes().map(|_| dim).into_iter() }"
  from_superset =
    "if $item.layout_dims().contains(&$layout.id()) { Some($item) } else { None }"
  reverse forall $dim in StaticDims =
    "$dim.layout_dims().iter().map(|&id| $fun.layout_dimension(id))"
  var_prefix = "dim"
  new_objs = "$objs.actual_layout_static_dims"
end

/// Indicates the layout dimensions that correspond to this one in preceeding variables.
set PredecessorLayout($dim in LayoutDimensions) subsetof LayoutDimensions:
  item_type = "ir::LayoutDimension"
  id_type = "ir::LayoutDimId"
  item_getter = "$fun.layout_dimension($id)"
  id_getter = "$item.id()"
  iterator = "$dim.predecessors().iter().map(|&id| $fun.layout_dimension(id))"
  from_superset =
    "if $dim.predecessors().contains(&$item.id()) { Some($item) } else { None }"
  reverse forall $dim in LayoutDimensions =
    "$dim.successors().iter().map(|&id| $fun.layout_dimension(id))"
  var_prefix = "layout"
  new_objs = "$objs.predecessor_layout_dims"
end

/// Layout dimensions of a memory block.
set MemLayoutDimensions subsetof LayoutDimensions:
  item_type = "ir::LayoutDimension"
  id_type = "ir::LayoutDimId"
  item_getter = "$fun.layout_dimension($id)"
  id_getter = "$item.id()"
  iterator = "$fun.mem_layout_dimensions()"
  from_superset = "if $item.is_memory_layout() { Some($item) } else { None }"
  var_prefix = "mem_layout"
  new_objs = "$objs.mem_layout_dims"
end

/// Indicates the layout dimensions of a memory accessed by an instruction.
set MemAccessLayout($access in MemInsts) subsetof MemLayoutDimensions:
  item_type = "ir::LayoutDimension"
  id_type = "ir::LayoutDimId"
  item_getter = "$fun.layout_dimension($id)"
  id_getter = "$item.id()"
  iterator = "$access.mem_access_layout().iter().map(|&id| $fun.layout_dimension(id))"
  from_superset =
    "if $item.access_inst() == Some($access.id()) { Some($item) } else { None }"
  reverse forall $dim in MemLayoutDimensions =
    "$dim.access_inst().map(|id| $fun.inst(id)).into_iter()"
  var_prefix = "mem_layout"
  new_objs = "$objs.mem_access_layout"
end

/// Intersection of PredecessorLayout and MemLayoutDimensions.
set PredecessorMemLayouts($dim in LayoutDimensions) subsetof MemLayoutDimensions:
  item_type = "ir::LayoutDimension"
  id_type = "ir::LayoutDimId"
  item_getter = "$fun.layout_dimension($id)"
  id_getter = "$item.id()"
  iterator = "$dim.predecessors().iter().map(|&id| $fun.layout_dimension(id))\
    .filter(|dim| dim.is_memory_layout())"
  from_superset = "if $dim.predecessors().contains(&$item.id()) && \
    $item.is_memory_layout() { Some($item) } else { None }"
  reverse forall $dim in MemLayoutDimensions =
    "$dim.successors().iter().map(|&id| $fun.layout_dimension(id))"
  var_prefix = "mem_layout"
  new_objs = "$objs.predecessor_mem_layout_dims"
end

require forall $rhs in LayoutDimensions:
  forall $lhs in PredecessorLayout($rhs):
    forall $lhs_dim in ActualDimension($lhs):
      forall $rhs_dim in ActualDimension($rhs):
        order($lhs_dim, $rhs_dim) is ORDERED | MERGED
        // For now, limit mappings to dimensions with a known size.
        // TODO(ulysse): allow generating memory blocks with a dynamic size.
        "$lhs_dim.possible_sizes().is_some()" || order($lhs_dim, $rhs_dim) is MERGED

// Ensure mapped dimensions have the same size. We currently have no way to constrain the
// size of dynamic dimensions: it would require to name the reverse set of
// `TiledDimension($logical_dim)`. However, it is enough to constrain the size of static
// dimensions as the tiling factor of dynamic dimensions only depend on the size of static
// dimensions.
require forall $rhs in LayoutDimensions:
  forall $lhs in PredecessorLayout($rhs):
    forall $lhs_dim in ActualStaticDimension($lhs):
      forall $rhs_dim in ActualStaticDimension($rhs):
        size($lhs_dim) == size($rhs_dim)

/// Indicates if the variable is instantiated along the layout dimension.
define enum is_instantiated($dim in LayoutDimensions):
  value FALSE:
  value TRUE:
end

// Instructions have the same instantiation pattern than the underlying variables.
require forall $inst in MemInsts:
  forall $layout_dim in MemAccessLayout($inst):
      forall $pred in PredecessorMemLayouts($layout_dim):
        is_instantiated($layout_dim) == is_instantiated($pred)
        rank($layout_dim) == rank($pred)

// Memory access instructions can only be vectorized along instantiated dimensions.
require forall $inst in MemInsts:
  forall $layout_dim in MemAccessLayout($inst):
      forall $dim in ActualDimension($layout_dim):
        is_instantiated($layout_dim) is TRUE || dim_kind($dim) is not VECTOR

// Point-to-point communication requires variables to be instantiated.
require forall $lhs in LayoutDimensions:
  forall $rhs in PredecessorLayout($lhs):
    forall $lhs_dim in ActualDimension($lhs):
      forall $rhs_dim in ActualDimension($rhs):
        is_instantiated($lhs) is TRUE || order($lhs_dim, $rhs_dim) is MERGED

// The variable is instantiated along parallel dimensions.
require forall $layout_dim in LayoutDimensions:
    forall $dim in ActualDimension($layout_dim):
      dim_kind($dim) is not THREAD || is_instantiated($layout_dim) is TRUE

/// Indicates the order in which layout dimensions are ordered in memory.
define integer rank($dim in MemLayoutDimensions): "unwrap!($dim.possible_ranks())" end

// Non-instantiated dimensions have no rank.
require forall $dim in MemLayoutDimensions:
  rank($dim) == "0" || is_instantiated($dim) is TRUE
  rank($dim) > "0" || is_instantiated($dim) is FALSE

require forall $inst in MemInsts:
  forall $outer in MemAccessLayout($inst):
    forall $inner in MemAccessLayout($inst):
      forall $outer_dim in ActualDimension($outer):
        forall $inner_dim in ActualDimension($inner):
          // Vector dimensions order matches the rank.
          order($outer_dim, $inner_dim) is not OUTER
          || dim_kind($inner_dim) is not VECTOR
          || dim_kind($outer_dim) is not VECTOR
          || rank($outer) > rank($inner)
          // Inner vectorization is on contiguous elements.
          rank($outer) < rank($inner)
          || dim_kind($outer_dim) is not INNER_VECTOR
          || dim_kind($inner_dim) is INNER_VECTOR
          || rank($inner) == "0"
          // Ensure we don't vectorize if there is a stride.
          order($outer_dim, $inner_dim) is not OUTER
          || "!$outer.is_strided()"
          || dim_kind($outer_dim) is not VECTOR
          || dim_kind($outer_dim) != dim_kind($inner_dim)

// Vectorization is on contiguous dimensions.
require forall $inst in MemInsts:
  forall $outer in MemAccessLayout($inst):
    forall $mid in MemAccessLayout($inst):
      forall $inner in MemAccessLayout($inst):
        forall $outer_dim in ActualDimension($outer):
          forall $mid_dim in ActualDimension($mid):
            forall $inner_dim in ActualDimension($inner):
              dim_kind($outer_dim) is not VECTOR
              || dim_kind($inner_dim) != dim_kind($outer_dim)
              || rank($outer) < rank($mid)
              || rank($mid) < rank($inner)
              || dim_kind($mid_dim) == dim_kind($outer_dim)


/// Detects if the instruction only access a sub-view of the full memory block.
define counter lesser_ranks($inst in MemInsts, $dim in MemAccessLayout($inst)):
  base "1"
  forall $other_dim in MemAccessLayout($inst):
    sum "1" when: rank($other_dim) < rank($dim)
end

// Don't vectorized if some inner dimensions are missing.
// TODO(ulysse): find a less restrictive way to detect if vectorized dimensions are
// contiguous.
require forall $inst in MemInsts:
  forall $layout_dim in MemAccessLayout($inst):
    forall $dim in ActualDimension($layout_dim):
      rank($layout_dim) == lesser_ranks($inst, $layout_dim)
        || dim_kind($dim) is not VECTOR
