initSidebarItems({"enum":[["CauseOfDeath","The possible causes for which a node can be killed."],["Event","The possible events in a trace."],["Message","A log message."],["Policy","The types of policy used."],["Selector",""]],"struct":[["ChildViewIter",""],["Edge","An edge in the search tree, which can contain additional data."],["EdgeIndex","Newtype wrapper to represent an edge index.  Like `NodeId`, we use a fixed-size representation for consistency of the serialization format."],["EdgeViewIndex","A newtype wrapper holding the indices in the `frozen` children list, which typically doesn't contain all the children and hence does not use `EdgeIndex`."],["Env","An environment in which candidates can be refined."],["MctsStore","Wrapper to interact with the `Store` trait."],["Node","Represents a node in the search tree.  This is represented by a reference-counted pointer to an internal structure; multiple clones point to the same in-memory structure."],["NodeCursor","A cursor which can be moved in the tree and remembers its trajectory."],["NodeId","Newtype wrapper to represent a node identifier.  Node identifiers should be unique inside a tree.  We use a fixed-size representation for consistency of the serialization format."],["NodeView","A locally frozen view on a node, where only some children may be present.  This typically only contains the children satisfying a certain condition, such as live children or (un)expanded children."],["TAGPolicy",""],["TAGStats","Holds the TAG statistics for a given edge."],["Timed","Wrapper struct to annotate events with timing information."],["Trace","A path in the tree."],["Tree","Helper structure to manipulate a tree."],["UCTPolicy","TODO(bclement):  The UCT formula is wrong, because 1) we are optimising as a reward while we actually have a cost and 2) the scale is wrong (evaluations are in the e6+ range but we do as if they were in 0-1)."],["UCTStats",""],["WeakNode","Non-owning reference to a node.  The node can be accessed through `upgrade`."]],"trait":[["TreePolicy",""]]});